{"mappings":"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","sources":["src/src/globals.ts","src/src/general-functions.ts","src/src/supporting-functions.ts","src/src/pseudo-methods.ts","src/src/event-emitter.ts","src/src/proxy-methods.ts","src/src/index.ts","src/index.ts"],"sourcesContent":[null,null,null,null,null,null,null,"/**\n * Copyright 2021 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nimport { proxyTypes, nodeStatuses, proxyStatuses, ND, NID, SomeProxy, DataNode, ProxyNode, TargetVariable, ProxserveInterface } from './globals';\nimport { unproxify, createNodes } from './supporting-functions';\nimport * as pseudoMethods from './pseudo-methods';\nimport * as proxyMethods from './proxy-methods';\nimport { realtypeof, splitPath, evalPath } from './general-functions';\nimport { initEmitEvent } from './event-emitter';\n\n/**\n * save an array of all reserved function names\n * and also add synonyms to these functions\n */\nlet pseudoMethodsNames = Object.keys(pseudoMethods);\nfor(let i = pseudoMethodsNames.length - 1; i >= 0; i--) {\n\tlet name = pseudoMethodsNames[i];\n\tlet synonym = '$'+name;\n\tpseudoMethods[synonym] = pseudoMethods[name];\n\tpseudoMethodsNames.push(synonym);\n}\n\ninterface ConstructorOptions {\n\tstrict: boolean;\n\temitMethods: boolean;\n\tdebug?: {\n\t\tdestroyDelay: number;\n\t};\n}\n\nexport class Proxserve implements ProxserveInterface {\n\tstrict: boolean;\n\temitMethods: boolean;\n\tdestroyDelay: number;\n\tdataTree: DataNode;\n\tproxyTree: ProxyNode;\n\n\t/**\n\t * construct a new proxserve instance\n\t * @param {Object|Array} target \n\t * @param {Object} [options]\n\t * \t@property {Boolean} [options.strict] - should destroy detached child-objects or deleted properties automatically\n\t * \t@property {Boolean} [options.emitMethods] - should splice/shift/unshift emit one event or all CRUD events\n\t */\n\tconstructor(target: TargetVariable, options: ConstructorOptions) {\n\t\tthis.strict = options.strict;\n\t\tthis.emitMethods = options.emitMethods;\n\t\tthis.destroyDelay = 1000;\n\n\t\tif(options.debug && options.debug.destroyDelay) this.destroyDelay = options.debug.destroyDelay;\n\n\t\tlet dataTreePrototype: DataNode = {\n\t\t\t[NID]: { status: nodeStatuses.ACTIVE },\n\t\t\t[ND]: { isTreePrototype: true } as DataNode[typeof ND],\n\t\t};\n\t\tlet proxyTreePrototype: ProxyNode = {\n\t\t\t[NID]: { status: proxyStatuses.ALIVE },\n\t\t\t[ND]: { isTreePrototype: true } as ProxyNode[typeof ND],\n\t\t};\n\n\t\tconst newNodes = createNodes(dataTreePrototype, proxyTreePrototype, '', target);\n\t\tthis.dataTree = newNodes.dataNode;\n\t\tthis.proxyTree = newNodes.proxyNode;\n\n\t\t// `as any` to stop TS from erroring because it wants us to return the `this` object\n\t\t// but instead we are returning a different object\n\t\treturn this.createProxy(this.dataTree) as any;\n\t}\n\n\t/**\n\t * create a new proxy and a new node for a property of the parent's target-object\n\t * @param {Object} parentDataNode\n\t * @param {String} [targetProperty]\n\t */\n\tcreateProxy(parentDataNode: DataNode, targetProperty?: string): SomeProxy {\n\t\tlet parentProxyNode = parentDataNode[ND].proxyNode\n\t\tlet dataNode: DataNode, proxyNode: ProxyNode;\n\n\t\tif(targetProperty === undefined) { //refering to own node and not a child property (meaning root object)\n\t\t\tdataNode = parentDataNode;\n\t\t\tproxyNode = parentProxyNode;\n\t\t}\n\t\telse {\n\t\t\t//creates new or reset an existing data-node and then creates a new proxy-node\n\t\t\tconst newNodes = createNodes(\n\t\t\t\tparentDataNode,\n\t\t\t\tparentProxyNode,\n\t\t\t\ttargetProperty,\n\t\t\t\tparentProxyNode[ND].target[targetProperty],\n\t\t\t);\n\t\t\tdataNode = newNodes.dataNode;\n\t\t\tproxyNode = newNodes.proxyNode;\n\t\t}\n\n\t\tlet target = proxyNode[ND].target;\n\n\t\tlet typeoftarget = realtypeof(target);\n\n\t\tif(proxyTypes[typeoftarget]) {\n\t\t\tlet revocable = Proxy.revocable<TargetVariable>(target, {\n\t\t\t\tget: (target: TargetVariable/*same as parent scope 'target'*/, property: string|symbol, proxy) => {\n\t\t\t\t\tif(this.emitMethods && Object.prototype.hasOwnProperty.call(proxyMethods, property) && property in Object.getPrototypeOf(target)) {\n\t\t\t\t\t\t// use a proxy method instead of the built-in method that is on the prototype chain\n\t\t\t\t\t\treturn proxyMethods[property].bind(this, dataNode, proxyNode);\n\t\t\t\t\t}\n\t\t\t\t\telse if(pseudoMethodsNames.includes(property as string) && typeof target[property] === 'undefined') {\n\t\t\t\t\t\t// can access a pseudo function (or its synonym) if their keywords isn't used\n\t\t\t\t\t\treturn pseudoMethods[property].bind(this, dataNode, proxyNode);\n\t\t\t\t\t}\n\t\t\t\t\telse if(!target.propertyIsEnumerable(property) || typeof property === 'symbol') {\n\t\t\t\t\t\treturn target[property]; // non-enumerable or non-path'able aren't proxied\n\t\t\t\t\t}\n\t\t\t\t\telse if(proxyNode[property] // there's a child node\n\t\t\t\t\t\t\t&& proxyNode[property][ND].proxy // it holds a proxy\n\t\t\t\t\t\t\t&& proxyNode[property][NID].status === proxyStatuses.ALIVE) {\n\t\t\t\t\t\treturn proxyNode[property][ND].proxy;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn target[property];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\n\t\t\t\tset: (target/*same as parent scope 'target'*/, property, value, proxy) => { //'receiver' is proxy\n\t\t\t\t\t/**\n\t\t\t\t\t * property can be a regular object because of 3 possible reasons:\n\t\t\t\t\t * 1. proxy is deleted from tree but user keeps accessing it then it means he saved a reference\n\t\t\t\t\t * 2. it is a non-enumerable property which means it was intentionally hidden\n\t\t\t\t\t * 3. property is a symbol and symbols can't be proxied because we can't create a normal path for them.\n\t\t\t\t\t *    these properties are not proxied and should not emit change-event.\n\t\t\t\t\t *    except for: length\n\t\t\t\t\t * TODO - make a list of all possible properties exceptions (maybe function 'name'?)\n\t\t\t\t\t */\n\t\t\t\t\tif(dataNode[NID].status === nodeStatuses.BLOCKED) { //blocked from changing values\n\t\t\t\t\t\tconsole.error('object is blocked. can\\'t change value of property:', property);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(typeof property === 'symbol') {\n\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(property !== 'length' && !target.propertyIsEnumerable(property)) {\n\t\t\t\t\t\t//if setting a whole new property then it is non-enumerable (yet) so a further test is needed\n\t\t\t\t\t\tlet descriptor = Object.getOwnPropertyDescriptor(target, property);\n\t\t\t\t\t\tif(typeof descriptor === 'object' && descriptor.enumerable === false) { //property was previously set\n\t\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet oldValue = target[property]; // should not be proxy\n\t\t\t\t\tlet isOldValueProxy = false;\n\t\t\t\t\tif(proxyNode[property] !== undefined && proxyNode[property][ND].proxy !== undefined) {\n\t\t\t\t\t\t// about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\tproxyNode[property][NID].status = proxyStatuses.DELETED;\n\t\t\t\t\t\tdelete dataNode[property][ND].proxyNode; // detach reference from data-node to proxy-node\n\t\t\t\t\t\tisOldValueProxy = true;\n\t\t\t\t\t\tif(this.strict) {\n\t\t\t\t\t\t\t// postpone this cpu intense function for later, probably when proxserve is not in use\n\t\t\t\t\t\t\tsetTimeout(Proxserve.destroy, this.destroyDelay, proxyNode[property][ND].proxy); \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue = unproxify(value);\n\t\t\t\t\ttarget[property] = value; //assign new value\n\n\t\t\t\t\tlet isValueProxy = false;\n\t\t\t\t\tlet typeofvalue = realtypeof(value);\n\t\t\t\t\tif(proxyTypes[typeofvalue]) {\n\t\t\t\t\t\tthis.createProxy(dataNode, property); //if trying to add a new value which is an object then make it a proxy\n\t\t\t\t\t\tisValueProxy = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tinitEmitEvent(dataNode, property, oldValue, isOldValueProxy, value, isValueProxy);\n\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\t/**\n\t\t\t\t * TODO - this function is incomplete and doesn't handle all of 'descriptor' scenarios\n\t\t\t\t */\n\t\t\t\tdefineProperty: (target/*same as parent scope 'target'*/, property, descriptor) => {\n\t\t\t\t\tif(typeof property === 'symbol') {\n\t\t\t\t\t\tObject.defineProperty(target, property, descriptor);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet oldValue = target[property]; //should not be proxy\n\t\t\t\t\tlet isOldValueProxy = false;\n\t\t\t\t\tif(proxyNode[property] !== undefined && proxyNode[property][ND].proxy !== undefined) {\n\t\t\t\t\t\t//about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\tproxyNode[property][NID].status = proxyStatuses.DELETED;\n\t\t\t\t\t\tdelete dataNode[property][ND].proxyNode; //detach reference from data-node to proxy-node\n\t\t\t\t\t\tisOldValueProxy = true;\n\t\t\t\t\t\tif(this.strict) {\n\t\t\t\t\t\t\t//postpone this cpu intense function for later, probably when proxserve is not is use\n\t\t\t\t\t\t\tsetTimeout(Proxserve.destroy, this.destroyDelay, proxyNode[property][ND].proxy);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdescriptor.value = unproxify(descriptor.value);\n\t\t\t\t\tObject.defineProperty(target, property, descriptor); //defining the new value\n\t\t\t\t\tlet value = descriptor.value;\n\t\t\t\t\tlet isValueProxy = false;\n\t\t\t\t\t//excluding non-enumerable properties from being proxied\n\t\t\t\t\tlet typeofvalue = realtypeof(descriptor.value);\n\t\t\t\t\tif(proxyTypes[typeofvalue] && descriptor.enumerable === true) {\n\t\t\t\t\t\tthis.createProxy(dataNode, property); //if trying to add a new value which is an object then make it a proxy\n\t\t\t\t\t\tisValueProxy = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tinitEmitEvent(dataNode, property, oldValue, isOldValueProxy, value, isValueProxy);\n\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\tdeleteProperty: (target/*same as parent scope 'target'*/, property) => {\n\t\t\t\t\tif(!target.propertyIsEnumerable(property) || typeof property === 'symbol') {\n\t\t\t\t\t\t//non-proxied properties simply get deleted and nothing more\n\t\t\t\t\t\tdelete target[property];\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dataNode[NID].status === nodeStatuses.BLOCKED) { //blocked from changing values\n\t\t\t\t\t\tconsole.error(`can't delete property '${property}'. object is blocked.`);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(property in target) {\n\t\t\t\t\t\tlet oldValue = target[property]; //should not be proxy\n\t\t\t\t\t\tlet isOldValueProxy = false;\n\t\t\t\t\t\tif(proxyNode[property] !== undefined && proxyNode[property][ND].proxy !== undefined) {\n\t\t\t\t\t\t\t//about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\t\tproxyNode[property][NID].status = proxyStatuses.DELETED;\n\t\t\t\t\t\t\tdelete dataNode[property][ND].proxyNode; //detach reference from data-node to proxy-node\n\t\t\t\t\t\t\tisOldValueProxy = true;\n\t\t\t\t\t\t\tif(this.strict) {\n\t\t\t\t\t\t\t\t//postpone this cpu intense function for later, probably when proxserve is not is use\n\t\t\t\t\t\t\t\tsetTimeout(Proxserve.destroy, this.destroyDelay, proxyNode[property][ND].proxy);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete target[property]; //actual delete\n\n\t\t\t\t\t\tinitEmitEvent(dataNode, property, oldValue, isOldValueProxy, undefined, false);\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn true; //do nothing because there's nothing to delete\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as ProxyHandler<TargetVariable>) as { proxy: SomeProxy, revoke: ()=>void };\n\n\t\t\tproxyNode[ND].proxy = revocable.proxy;\n\t\t\tproxyNode[ND].revoke = revocable.revoke;\n\n\t\t\tif(proxyTypes[typeoftarget]) {\n\t\t\t\tlet keys = Object.keys(target); //handles both Objects and Arrays\n\t\t\t\tfor(let key of keys) {\n\t\t\t\t\tlet typeofproperty = realtypeof(target[key]);\n\t\t\t\t\tif(proxyTypes[typeofproperty]) {\n\t\t\t\t\t\tthis.createProxy(dataNode, key); //recursively make child objects also proxies\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconsole.warn(`Type of \"${typeoftarget}\" is not implemented`);\n\t\t\t}\n\n\t\t\treturn revocable.proxy;\n\t\t}\n\t\telse {\n\t\t\tconst types = Object.keys(proxyTypes);\n\t\t\tthrow new Error(`Must observe an ${types.join('/')}`);\n\t\t}\n\t}\n\n\t/**\n\t * Recursively revoke proxies, allowing them to be garbage collected.\n\t * this functions delays 1000 milliseconds to let time for all events to finish\n\t * @param {*} proxy \n\t */\n\tstatic destroy(proxy) {\n\t\tlet proxyNode;\n\t\ttry {\n\t\t\t[, proxyNode] = proxy.$getProxserveNodes();\n\t\t} catch(error) {\n\t\t\treturn; // proxy variable isn't a proxy\n\t\t}\n\n\t\tif(proxyNode[NID].status === proxyStatuses.ALIVE) {\n\t\t\tproxyNode[NID].status = proxyStatuses.DELETED;\n\t\t}\n\n\t\tlet typeofproxy = realtypeof(proxy);\n\n\t\tif(proxyTypes[typeofproxy]) {\n\t\t\tlet keys = Object.keys(proxy); // handles both Objects and Arrays\n\t\t\tfor(let key of keys) {\n\t\t\t\ttry {\n\t\t\t\t\tlet typeofproperty = realtypeof(proxy[key]);\n\t\t\t\t\tif(proxyTypes[typeofproperty]) {\n\t\t\t\t\t\t// going to proxy[key], which is deleted, will return the original target so we will bypass it\n\t\t\t\t\t\tProxserve.destroy(proxyNode[key][ND].proxy);\n\t\t\t\t\t}\n\t\t\t\t} catch(error) {\n\t\t\t\t\tconsole.error(error); // don't throw and kill the whole process just if this iteration fails\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tproxyNode[ND].revoke();\n\t\t\t//proxyNode[ND].proxy = undefined;\n\t\t\tproxyNode[NID].status = proxyStatuses.REVOKED;\n\t\t}\n\t\telse {\n\t\t\tconsole.warn(`Type of \"${typeofproxy}\" is not implemented`);\n\t\t}\n\t}\n\n\tstatic splitPath(path) {\n\t\treturn splitPath(path);\n\t}\n\n\tstatic evalPath(obj, path) {\n\t\treturn evalPath(obj, path);\n\t}\n}"],"names":[],"version":3,"file":"index.d.ts.map"}