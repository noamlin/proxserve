{"version":3,"sources":["general-functions.js","supporting-functions.js","reserved-methods.js","index.js"],"names":["realtypeof","variable","rawType","Object","prototype","toString","call","substring","length","simpleCloneSet","WeakSet","simpleClone","obj","typeofobj","cloned","add","keys","key","has","i","console","warn","splitPath","path","resultsArr","tmp","char","push","evalPath","object","property","undefined","value","segments","Error","acceptableTypes","acceptableEvents","statuses","ND","Symbol","for","NID","property2path","add2emitQueue","delay","dataNode","oldValue","changeType","listeners","change","eventPool","emit","setTimeout","add2emitQueue_bubble","wasOldValueProxy","isValueProxy","objects","isDeleted","add2emitQueue_capture","target","status","parentNode","isTreePrototype","propertyPath","subValue","subOldValue","listener","type","splice","proxy","unproxify","typeofvalue","includes","$getOriginalTarget","error","createDataNode","node","create","assign","stop","block","activate","force","dataTree","on","events","id","once","Array","isArray","event","join","removeListener","arguments","fullPath","removeAllListeners","getOriginalTarget","getProxserveObjects","getProxserveDataNode","getProxserveInstance","reservedMethodsNames","reservedMethods","name","synonym","Proxserve","options","strict","emitReference","createProxy","targetProperty","typeoftarget","revocable","Proxy","get","bind","propertyIsEnumerable","getPrototypeOf","set","descriptor","getOwnPropertyDescriptor","enumerable","emitOldValue","shouldDestroy","emitValue","destroy","defineProperty","deleteProperty","revoke","typeofproperty","$getProxserveObjects","typeofproxy","module","exports"],"mappings":"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","file":"proxserve.js","sourceRoot":"../src","sourcesContent":["/**\n * Copyright 2020 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\n/**\n * return a string representing the full type of the variable\n * @param {*} variable \n * @returns {String} - Object, Array, Number, String, Boolean, Null, Undefined, BigInt, Symbol, Date ...\n */\nexport function realtypeof(variable) {\n\tlet rawType = Object.prototype.toString.call(variable); //[object Object], [object Array], [object Number] ...\n\treturn rawType.substring(8, rawType.length - 1);\n}\n\n/**\n * recursively clones objects and array\n * @param {Proxy|Object|Array} proxy \n */\nlet simpleCloneSet = new WeakSet();\nexport function simpleClone(obj) {\n\tlet typeofobj = realtypeof(obj);\n\tlet cloned;\n\tif(typeofobj === 'Object') {\n\t\tsimpleCloneSet.add(obj);\n\t\tcloned = {};\n\t\tlet keys = Object.keys(obj);\n\t\tfor(let key of keys) {\n\t\t\tif(simpleCloneSet.has(obj[key])) {\n\t\t\t\tcloned[key] = obj[key];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcloned[key] = simpleClone(obj[key]);\n\t\t\t}\n\t\t}\n\t}\n\telse if(typeofobj === 'Array') {\n\t\tsimpleCloneSet.add(obj);\n\t\tcloned = [];\n\t\tfor(let i = 0; i < obj.length; i++) {\n\t\t\tif(simpleCloneSet.has(obj[i])) {\n\t\t\t\tcloned[i] = obj[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcloned[i] = simpleClone(obj[i]);\n\t\t\t}\n\t\t}\n\t}\n\telse { //hopefully a primitive\n\t\tcloned = obj;\n\n\t\tif(typeofobj !== 'Undefined' && typeofobj !== 'Null' && typeofobj !== 'Boolean' && typeofobj !== 'Number'\n\t\t&& typeofobj !== 'BigInt' && typeofobj !== 'String') {\n\t\t\tconsole.warn(`Can't clone a variable of type ${typeofobj}`);\n\t\t}\n\t}\n\n\treturn cloned;\n}\n\n/**\n * splits a path to an array of properties\n * (benchmarked and is faster than regex and split())\n * @param {String} path \n */\nexport function splitPath(path) {\n\tif(typeof path !== 'string' || path === '') {\n\t\treturn [];\n\t}\n\t\n\tlet i = 0;\n\tif(path[0] === '.' || path[0] === '[') {\n\t\ti = 1; //loop will skip over openning '.' or '['\n\t}\n\n\tvar resultsArr = [];\n\tvar tmp='';\n\tfor(; i < path.length; i++) {\n\t\tlet char = path[i];\n\t\tif(char === '.' || char === '[') {\n\t\t\tresultsArr.push(tmp);\n\t\t\ttmp = '';\n\t\t} else if(char !== ']') {\n\t\t\ttmp += char;\n\t\t}\n\t}\n\tif(tmp!=='') {\n\t\tresultsArr.push(tmp);\n\t}\n\treturn resultsArr;\n}\n\n/**\n * evaluate a long path and return the designated object and its referred property\n * @param {Object} obj\n * @param {String} path\n * @returns {Object} - returns {object, property, value}\n */\nexport function evalPath(obj, path) {\n\tif(path === '') {\n\t\treturn { object: obj, property: undefined, value: obj };\n\t}\n\n\tlet segments = splitPath(path);\n\tlet i;\n\tfor(i = 0; i <= segments.length - 2; i++) { //iterate until one before last property because they all must exist\n\t\tobj = obj[segments[i]];\n\t\tif(typeof obj === 'undefined') {\n\t\t\tthrow new Error(`Invalid path was given - \"${path}\"`);\n\t\t}\n\t}\n\treturn { object: obj, property: segments[i], value: obj[ segments[i] ] };\n}","/**\n * Copyright 2020 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nimport { realtypeof } from './general-functions.js';\n\nexport let acceptableTypes = ['Object', 'Array', 'Map']; //acceptable types to be proxied\nexport let acceptableEvents = ['change', 'create', 'update', 'delete'];\nexport let statuses = ['active', 'stopped', 'blocked']; //statuses of proxies\n\nlet ND = Symbol.for('proxserve_node_data'); //key for the data of a node\nlet NID = Symbol.for('proxserve_node_inherited_data'); //key for the inherited data of a node\n\n/**\n * Convert property name to valid path segment\n * @param {*} obj \n * @param {String} property \n */\nexport function property2path(obj, property) {\n\tif(typeof property === 'symbol') {\n\t\tthrow new Error(`property of type \"symbol\" isn't path'able`);\n\t}\n\n\tlet typeofobj = realtypeof(obj);\n\tswitch(typeofobj) {\n\t\tcase 'Object': return `.${property}`;\n\t\tcase 'Array': return `[${property}]`;\n\t\tdefault: console.warn(`Not Implemented (type of '${typeofobj}')`); return property;\n\t}\n}\n\n/**\n * add change-events to a queue and then emits them immediately or later as a batch\n * @param {Number} delay \n * @param {Object} dataNode \n * @param {String} path\n * @param {*} oldValue \n * @param {*} value \n * @param {String} changeType\n */\nexport function add2emitQueue(delay, dataNode, path, oldValue, value, changeType) {\n\tif(dataNode[ND].listeners && dataNode[ND].listeners.length > 0) {\n\t\tlet change = {\n\t\t\t'path': path, 'value': value, 'oldValue': oldValue, 'type': changeType\n\t\t};\n\t\tdataNode[ND].eventPool.push(change);\n\n\t\tif(delay <= 0) {\n\t\t\temit(dataNode); //emit immediately\n\t\t}\n\t\telse if(dataNode[ND].eventPool.length === 1) {\n\t\t\tsetTimeout(emit, delay, dataNode); //initiate timeout once, when starting to accumulate events\n\t\t}\n\t}\n}\n\n/**\n * bubbles up the data tree for 'add2emitQueue'\n * @param {Number} delay\n * @param {Object} dataNode\n * @param {String} property\n * @param {*} oldValue\n * @param {Boolean} wasOldValueProxy\n * @param {*} value\n * @param {Boolean} isValueProxy\n */\nexport function add2emitQueue_bubble(delay, dataNode, property, oldValue, wasOldValueProxy, value, isValueProxy) {\n\tif(oldValue === value/*no new change was made*/\n\t\t|| dataNode[ND].objects.isDeleted/*altered a deleted or detached proxy*/) {\n\t\treturn;\n\t}\n\n\tlet changeType = acceptableEvents[2]; //update\n\tif(value === undefined) changeType = acceptableEvents[3]; //delete\n\telse if(oldValue === undefined) changeType = acceptableEvents[1]; //create\n\n\tlet path;\n\tif(dataNode[property]) { //changed a property which has its own data node on the tree\n\t\tdataNode = dataNode[property];\n\t\tpath = '';\n\n\t\tif(wasOldValueProxy || isValueProxy) {\n\t\t\tadd2emitQueue_capture(delay, dataNode, oldValue, value, changeType);\n\t\t}\n\t} else {\n\t\tpath = property2path(dataNode[ND].objects.target, property);\n\t}\n\n\twhile(true) {\n\t\tif(dataNode[NID].status === statuses[1]) { //stop and don't propagate\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tadd2emitQueue(delay, dataNode, path, oldValue, value, changeType);\n\t\t}\n\n\t\tif(!dataNode[ND].parentNode.isTreePrototype) { //we are not on root node yet\n\t\t\tpath = dataNode[ND].propertyPath + path;\n\t\t\tdataNode = dataNode[ND].parentNode;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * capturing phase - going down the data tree for 'add2emitQueue'\n * @param {Number} delay \n * @param {Object} dataNode - traverse down this node\n * @param {*} oldValue \n * @param {*} value \n */\nexport function add2emitQueue_capture(delay, dataNode, oldValue, value) {\n\tlet keys = Object.keys(dataNode);\n\tfor(let key of keys) {\n\t\tlet subValue = (typeof value === 'object' && value !== null) ? value[key] : undefined;\n\t\tlet subOldValue = (typeof oldValue === 'object' && oldValue !== null) ? oldValue[key] : undefined;\n\t\tif(subValue !== subOldValue) { //if not both undefined or same primitive or the same object\n\t\t\t//TODO - both will never be the same object because 'oldValue' is the target object while 'value' is the proxy,\n\t\t\t//\t\t\tbut can a concerning scenario even happen?\n\t\t\tlet changeType = acceptableEvents[2]; //update\n\t\t\tif(subValue === undefined) changeType = acceptableEvents[3]; //delete\n\t\t\telse if(subOldValue === undefined) changeType = acceptableEvents[1]; //create\n\t\t\tadd2emitQueue(delay, dataNode[key], '', subOldValue, subValue, changeType);\n\t\t\tadd2emitQueue_capture(delay, dataNode[key], subOldValue, subValue);\n\t\t}\n\t}\n}\n\nexport function emit(dataNode) {\n\t//save a reference to the event-pool because we are about to immediately empty it, so all future changes, even those\n\t//that can occur now because of the listeners, will go to a new event-pool and will be emitted next round (after delay).\n\t//NOTICE - an event listener for one path can still manipulate event-pools of other path's that are next on this cycle\n\tlet listeners = dataNode[ND].listeners;\n\tlet eventPool = dataNode[ND].eventPool;\n\tdataNode[ND].eventPool = [];\n\n\tif(!listeners || !eventPool) {\n\t\t//rare case where an event triggers a listener that removed-all-listeners and also causes a new event\n\t\t//before all emits of this loop have finished\n\t\treturn;\n\t}\n\n\t//FIFO - first event in, first event out. listeners will be called by their turn according to which event fires first\n\tfor(let change of eventPool) {\n\t\tfor(let i = listeners.length-1; i >= 0; i--) {\n\t\t\tlet listener = listeners[i]; //listener = [event, function, id, once]\n\n\t\t\tif(listener[0] === change.type) { //will invoke only create/update/delete listeners\n\t\t\t\tif(listener[3] === true) { //first delete the one-time listener, so the upcoming listener's-function won't meddle with it\n\t\t\t\t\tlisteners.splice(i, 1);\n\t\t\t\t}\n\n\t\t\t\tlistener[1].call(dataNode[ND].objects.proxy, change);\n\t\t\t}\n\t\t}\n\t}\n\n\t//iterate over all 'change' listeners and emit with an (ordered) array of all events\n\tfor(let i = listeners.length-1; i >= 0; i--) {\n\t\tlet listener = listeners[i]; //listener = [event, function, id, once]\n\n\t\tif(listener[0] === acceptableEvents[0]) { // 'change'\n\t\t\tif(listener[3] === true) { //first delete the one-time listener, so the upcoming listener's-function won't meddle with it\n\t\t\t\tlisteners.splice(i, 1);\n\t\t\t}\n\n\t\t\tlistener[1].call(dataNode[ND].objects.proxy, eventPool); //on(change) is always called with an array of one or more changes\n\t\t}\n\t}\n}\n\n/**\n * recursively switch between all proxies to their original targets.\n * note: original targets should never hold proxies under them,\n * thus altering the object references (getting from 'value') should be ok.\n * if the programmer decided to\n * \t1. create a proxy with children (sub-proxies)\n * \t2. create a regular object\n * \t3. adding sub-proxies to the regular object\n * \t4. attaching the regular object to the proxy\n * then this regular object will be altered.\n * @param {*} value\n */\nexport function unproxify(value) {\n\tlet typeofvalue = realtypeof(value);\n\tif(acceptableTypes.includes(typeofvalue)) {\n\t\tlet target = value;\n\t\ttry {\n\t\t\ttarget = value.$getOriginalTarget();\n\t\t} catch(error) {}\n\n\t\tswitch(typeofvalue) {\n\t\t\tcase 'Object':\n\t\t\t\tlet keys = Object.keys(target);\n\t\t\t\tfor(let key of keys) {\n\t\t\t\t\ttarget[key] = unproxify(target[key]); //maybe alters target and maybe returning the exact same object\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'Array':\n\t\t\t\tfor(let i=0; i < target.length; i++) {\n\t\t\t\t\ttarget[i] = unproxify(target[i]); //maybe alters target and maybe returning the exact same object\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.warn(`Not Implemented (type of '${typeofobj}')`);\n\t\t}\n\n\t\treturn target;\n\t}\n\telse {\n\t\treturn value; //primitive\n\t}\n}\n\nexport function createDataNode(parentNode, property) {\n\tlet propertyPath;\n\tif(parentNode[ND] && parentNode[ND].objects && parentNode[ND].objects.target) {\n\t\tpropertyPath = property2path(parentNode[ND].objects.target, property);\n\t} else {\n\t\tpropertyPath = property2path({}, property); //if parent doesn't have target then treat it as object\n\t}\n\t\n\tlet node = parentNode[property];\n\tif(!node) {\n\t\tnode = {\n\t\t\t[NID]: Object.create(parentNode[NID]),\n\t\t\t[ND]: {\n\t\t\t\t'parentNode': parentNode\n\t\t\t}\n\t\t};\n\t\tparentNode[property] = node;\n\t}\n\n\tdelete node[NID].status; //clear old status in case if node previously existed\n\t//updates path (for rare case where parent was array and then changed to object or vice versa)\n\t//and also makes a new and clean 'objects' property\n\tObject.assign(node[ND], {\n\t\t'path': parentNode[ND].path + propertyPath,\n\t\t'propertyPath': propertyPath,\n\t\t'objects': Object.assign(Object.create(parentNode[ND].objects), {\n\t\t\t'target': null,\n\t\t\t'proxy': null\n\t\t})\n\t});\n\n\treturn node;\n}\n","/**\n * Copyright 2020 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nimport { acceptableEvents, statuses, createDataNode } from './supporting-functions.js';\nimport { splitPath } from './general-functions.js';\n\nlet ND = Symbol.for('proxserve_node_data'); //key for the data of a node\nlet NID = Symbol.for('proxserve_node_inherited_data'); //key for the inherited data of a node\n\n/**\n * stop object and children from emitting change events\n * @param {Object} dataNode\n */\nexport function stop(dataNode) {\n\tdataNode[NID].status = statuses[1];\n}\n\n/**\n * block object and children from any changes.\n * user can't set nor delete any property\n * @param {Object} dataNode\n */\nexport function block(dataNode) {\n\tdataNode[NID].status = statuses[2];\n}\n\n/**\n * resume default behavior of emitting change events, inherited from parent\n * @param {Object} dataNode\n * @param {Object} objects\n * @param {Boolean} [force] - force being active regardless of parent\n */\nexport function activate(dataNode, objects, force=false) {\n\tif(force || dataNode === this.dataTree) { //force activation or we are on root proxy\n\t\tdataNode[NID].status = statuses[0];\n\t}\n\telse {\n\t\tdelete dataNode[NID].status;\n\t}\n}\n\n/**\n * add event listener on a proxy or on a descending path\n * @param {Object} dataNode\n * @param {Object} objects\n * @param {String|Array.String} events\n * @param {String} [path] - path selector\n * @param {Function} listener \n * @param {String} [id] - identifier for removing this listener\n * @param {Boolean} [once] - whether this listener will run only once or always\n */\nexport function on(dataNode, objects, events, path, listener, id, once=false) {\n\tif(!Array.isArray(events)) events = [events];\n\n\tfor(let event of events) {\n\t\tif(!acceptableEvents.includes(event)) {\n\t\t\tthrow new Error(`${event} is not a valid event. valid events are ${acceptableEvents.join(',')}`);\n\t\t}\n\t}\n\t\n\tif(typeof path === 'function') { //if called without path\n\t\tid = listener;\n\t\tlistener = path;\n\t\tpath = '';\n\t} else if(typeof listener !== 'function') {\n\t\tthrow new Error(`invalid arguments were given. listener must be a function`);\n\t}\n\t\n\tlet segments = splitPath(path);\n\t//traverse down the tree. create data-nodes if needed\n\tfor(let property of segments) {\n\t\tif(!dataNode[property]) {\n\t\t\tcreateDataNode(dataNode, property);\n\t\t}\n\t\tdataNode = dataNode[property];\n\t}\n\n\tif(!dataNode[ND].listeners) {\n\t\tdataNode[ND].listeners = [];\n\t\tdataNode[ND].eventPool = [];\n\t}\n\tfor(let event of events) {\n\t\tdataNode[ND].listeners.push([event, listener, id, once]);\n\t}\n}\n\n/**\n * add event listener on a proxy or on a descending path which will run only once\n * @param {Object} dataNode\n * @param {Object} objects\n * @param {String|Array.String} events\n * @param {String} [path] - path selector\n * @param {Function} listener \n * @param {String} [id] - identifier for removing this listener\n */\nexport function once(dataNode, objects, events, path, listener, id) {\n\ton.call(this, dataNode, objects, events, path, listener, id, true);\n}\n\n/**\n * removes a listener from a path by an identifier (can have multiple listeners with the same ID)\n * or by the listener function itself\n * @param {Object} dataNode\n * @param {Object} objects\n * @param {String} [path] - path selector\n * @param {String} id - the listener(s) identifier or listener-function\n */\nexport function removeListener(dataNode, objects, path, id) {\n\tif(arguments.length === 3) { //if called without path\n\t\tid = path;\n\t\tpath = '';\n\t}\n\n\tlet fullPath = `${dataNode[ND].path}${path}`;\n\tlet segments = splitPath(path);\n\t//traverse down the tree\n\tfor(let property of segments) {\n\t\tif(!dataNode[property]) {\n\t\t\tconsole.warn(`can't remove listener from a non-existent path '${fullPath}'`);\n\t\t\treturn;\n\t\t}\n\t\tdataNode = dataNode[property];\n\t}\n\n\tif(dataNode[ND].listeners) {\n\t\tlet listeners = dataNode[ND].listeners;\n\t\n\t\tfor(let i = listeners.length - 1; i >= 0; i--) {\n\t\t\tif((typeof id !== 'function' && listeners[i][2] === id)\n\t\t\t|| (typeof id === 'function' && listeners[i][1] === id)) {\n\t\t\t\tlisteners.splice(i, 1);\n\t\t\t}\n\t\t}\n\n\t\tif(listeners.length === 0) {\n\t\t\tdelete dataNode[ND].listeners;\n\t\t\tdelete dataNode[ND].eventPool;\n\t\t}\n\t}\n}\n\n/**\n * removing all listeners of a path\n * @param {Object} dataNode\n * @param {Object} objects\n * @param {String} [path] - path selector\n */\nexport function removeAllListeners(dataNode, objects, path='') {\n\tlet fullPath = `${dataNode[ND].path}${path}`;\n\tlet segments = splitPath(path);\n\t//traverse down the tree\n\tfor(let property of segments) {\n\t\tif(!dataNode[property]) {\n\t\t\tconsole.warn(`can't remove all listeners from a non-existent path '${fullPath}'`);\n\t\t\treturn;\n\t\t}\n\t\tdataNode = dataNode[property];\n\t}\n\n\tif(dataNode[ND].listeners) {\n\t\tdelete dataNode[ND].listeners;\n\t\tdelete dataNode[ND].eventPool;\n\t}\n}\n\n/**\n * the following functions (getOriginalTarget, getProxserveObjects, getProxserveDataNode, getProxserveInstance) seem silly\n * because they could have been written directly on the handler's get() method but it's here as part of the convention of\n * exposing proxy-\"inherited\"-methods\n */\n/**\n * get original target that is behind the proxy\n * @param {Object} dataNode\n * @param {Object} objects\n */\nexport function getOriginalTarget(dataNode, objects) {\n\treturn objects.target;\n}\n\n/**\n * get 'objects' (which hold all related objects) of a proxy\n * @param {Object} dataNode\n * @param {Object} objects\n */\nexport function getProxserveObjects(dataNode, objects) {\n\treturn objects;\n}\n\n/**\n * get the data-node of the proxy or sub-proxy\n * @param {Object} dataNode\n */\nexport function getProxserveDataNode(dataNode) {\n\treturn dataNode;\n}\n\n/**\n * get the Proxserve's instance that created this proxy\n */\nexport function getProxserveInstance() {\n\treturn this;\n}\n","/**\n * Copyright 2020 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nimport { acceptableTypes, statuses, add2emitQueue_bubble, unproxify, createDataNode } from './supporting-functions.js';\nimport * as reservedMethods from './reserved-methods.js';\nimport { realtypeof, simpleClone, splitPath, evalPath } from './general-functions.js';\n\nlet ND = Symbol.for('proxserve_node_data'); //key for the data of a node\nlet NID = Symbol.for('proxserve_node_inherited_data'); //key for the inherited data of a node\n\n/**\n * save an array of all reserved function names\n * and also add synonyms to these functions\n */\nlet reservedMethodsNames = Object.keys(reservedMethods);\nfor(let i = reservedMethodsNames.length - 1; i >= 0; i--) {\n\tlet name = reservedMethodsNames[i];\n\tlet synonym = '$'+name;\n\treservedMethods[synonym] = reservedMethods[name];\n\treservedMethodsNames.push(synonym);\n}\n\nclass Proxserve {\n\t/**\n\t * construct a new proxserve instance\n\t * @param {Object|Array} target \n\t * @param {Object} [options] \n\t * \t@property {Number} [options.delay] - delay change-event emitting in milliseconds, letting them pile up and then fire all at once\n\t * \t@property {Boolean} [options.strict] - should destroy detached child-objects or deleted properties automatically\n\t * \t@property {Boolean} [options.emitReference] - events emit new/old values. true: reference to original objects, false: deep clones that are created on the spot\n\t */\n\tconstructor(target, options = {}) {\n\t\tthis.delay = (options.delay !== undefined) ? options.delay : 10;\n\t\tthis.strict = (options.strict !== undefined) ? options.strict : true;\n\t\tthis.emitReference = (options.emitReference !== undefined) ? options.emitReference : false;\n\n\t\tthis.dataTree = createDataNode({\n\t\t\t[NID]: { 'status': statuses[0] },\n\t\t\t[ND]: { 'objects': { 'isDeleted': false } },\n\t\t\t'isTreePrototype': true\n\t\t}, '');\n\t\tthis.dataTree[ND].path = '';\n\t\tthis.dataTree[ND].propertyPath = '';\n\t\tthis.dataTree[ND].objects.target = target;\n\n\t\treturn this.createProxy(this.dataTree);\n\t}\n\n\t/**\n\t * create a new proxy and a new node for a property of the parent's target-object\n\t * @param {Object} parentNode\n\t * @param {String} [targetProperty]\n\t */\n\tcreateProxy(parentNode, targetProperty) {\n\t\tlet dataNode;\n\n\t\tif(targetProperty === undefined) { //refering to own node and not a child property (meaning root object)\n\t\t\tdataNode = parentNode;\n\t\t}\n\t\telse {\n\t\t\tdataNode = createDataNode(parentNode, targetProperty); //either creates new or returns an existing one with cleaned properties\n\t\t\tdataNode[ND].objects.target = parentNode[ND].objects.target[ targetProperty ]; //assign said 'target' to the dataNode\n\t\t}\n\n\t\tlet objects = dataNode[ND].objects; //a new one for every iteration\n\t\tlet target = objects.target;\n\n\t\tlet typeoftarget = realtypeof(target);\n\n\t\tif(acceptableTypes.includes(typeoftarget)) {\n\t\t\tlet revocable = Proxy.revocable(target, {\n\t\t\t\tget: (target/*same as parent scope 'target'*/, property, proxy) => {\n\t\t\t\t\t//can access a function (or its synonym) if their keywords isn't used\n\t\t\t\t\tif(reservedMethodsNames.includes(property) && typeof target[property] === 'undefined') {\n\t\t\t\t\t\treturn reservedMethods[property].bind(this, dataNode, objects);\n\t\t\t\t\t}\n\t\t\t\t\telse if(!target.propertyIsEnumerable(property) || typeof property === 'symbol') {\n\t\t\t\t\t\treturn target[property]; //non-enumerable or non-path'able aren't proxied\n\t\t\t\t\t}\n\t\t\t\t\telse if(dataNode[property] //there's a child node\n\t\t\t\t\t\t\t&& dataNode[property][ND].objects.proxy //it holds a proxy\n\t\t\t\t\t\t\t&& Object.getPrototypeOf(dataNode[property][ND].objects) === objects) { //is child of this proxy, and not a ghost object left there after deletion\n\t\t\t\t\t\treturn dataNode[property][ND].objects.proxy;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn target[property];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\n\t\t\t\tset: (target/*same as parent scope 'target'*/, property, value, proxy) => { //'receiver' is proxy\n\t\t\t\t\t/**\n\t\t\t\t\t * property can be a regular object because of 3 possible reasons:\n\t\t\t\t\t * 1. proxy is deleted from tree but user keeps accessing it then it means he saved a reference\n\t\t\t\t\t * 2. it is a non-enumerable property which means it was intentionally hidden\n\t\t\t\t\t * 3. property is a symbol and symbols can't be proxied because we can't create a normal path for them.\n\t\t\t\t\t *    these properties are not proxied and should not emit change-event.\n\t\t\t\t\t *    except for: length\n\t\t\t\t\t * TODO - make a list of all possible properties exceptions (maybe function 'name'?)\n\t\t\t\t\t */\n\t\t\t\t\tif(dataNode[NID].status === statuses[2]) { //blocked from changing values\n\t\t\t\t\t\tconsole.error(`can't change value of property '${property}'. object is blocked.`);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(typeof property === 'symbol') {\n\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(property !== 'length' && !target.propertyIsEnumerable(property)) {\n\t\t\t\t\t\t//if setting a whole new property then it is non-enumerable (yet) so a further test is needed\n\t\t\t\t\t\tlet descriptor = Object.getOwnPropertyDescriptor(target, property);\n\t\t\t\t\t\tif(typeof descriptor === 'object' && descriptor.enumerable === false) { //property was previously set\n\t\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet oldValue;\n\t\t\t\t\tlet emitOldValue = target[property]; //should not be proxy\n\t\t\t\t\tlet shouldDestroy = false;\n\t\t\t\t\tif(dataNode[property] !== undefined && dataNode[property][ND].objects.proxy !== undefined) {\n\t\t\t\t\t\t//about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\toldValue = dataNode[property][ND].objects.proxy; //the sub-proxy\n\t\t\t\t\t\tdataNode[property][ND].objects.isDeleted = true;\n\t\t\t\t\t\tif(this.strict) {\n\t\t\t\t\t\t\tshouldDestroy = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue = unproxify(value);\n\t\t\t\t\ttarget[property] = value; //assign new value\n\n\t\t\t\t\tlet emitValue = value; //currently not a proxy but this might change later\n\t\t\t\t\tlet isValueProxy = false;\n\t\t\t\t\tlet typeofvalue = realtypeof(value);\n\t\t\t\t\tif(acceptableTypes.includes(typeofvalue)) {\n\t\t\t\t\t\tthis.createProxy(dataNode, property); //if trying to add a new value which is an object then make it a proxy\n\t\t\t\t\t\temitValue = dataNode[property][ND].objects.proxy; //is a proxy\n\t\t\t\t\t\tisValueProxy = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!this.emitReference) { //deep copy with no proxies inside\n\t\t\t\t\t\temitValue = simpleClone(emitValue);\n\t\t\t\t\t\temitOldValue = simpleClone(emitOldValue);\n\t\t\t\t\t}\n\n\t\t\t\t\tadd2emitQueue_bubble(this.delay, dataNode, property, emitOldValue, oldValue!==undefined, emitValue, isValueProxy);\n\t\t\t\t\tif(shouldDestroy) {\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\tProxserve.destroy(oldValue);\n\t\t\t\t\t\t}, this.delay + 1000); //postpone this cpu intense function for later, probably when proxserve is not is use\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\t/**\n\t\t\t\t * TODO - this function is incomplete and doesn't handle all of 'descriptor' scenarios\n\t\t\t\t */\n\t\t\t\tdefineProperty: (target/*same as parent scope 'target'*/, property, descriptor) => {\n\t\t\t\t\tif(typeof property === 'symbol') {\n\t\t\t\t\t\tObject.defineProperty(target, property, descriptor);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet oldValue;\n\t\t\t\t\tlet emitOldValue = target[property]; //should not be proxy\n\t\t\t\t\tlet shouldDestroy = false;\n\t\t\t\t\tif(dataNode[property] !== undefined && dataNode[property][ND].objects.proxy !== undefined) {\n\t\t\t\t\t\t//about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\toldValue = dataNode[property][ND].objects.proxy; //the sub-proxy\n\t\t\t\t\t\tdataNode[property][ND].objects.isDeleted = true;\n\t\t\t\t\t\tif(this.strict) {\n\t\t\t\t\t\t\tshouldDestroy = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdescriptor.value = unproxify(descriptor.value);\n\t\t\t\t\tObject.defineProperty(target, property, descriptor); //defining the new value\n\t\t\t\t\tlet value = descriptor.value;\n\t\t\t\t\tlet emitValue = value; //currently not a proxy but this might change later\n\n\t\t\t\t\tlet isValueProxy = false;\n\t\t\t\t\t//excluding non-enumerable properties from being proxied\n\t\t\t\t\tlet typeofvalue = realtypeof(descriptor.value);\n\t\t\t\t\tif(acceptableTypes.includes(typeofvalue) && descriptor.enumerable === true) {\n\t\t\t\t\t\tthis.createProxy(dataNode, property); //if trying to add a new value which is an object then make it a proxy\n\n\t\t\t\t\t\tvalue = dataNode[property][ND].objects.proxy; //value is now the proxy, not the target\n\t\t\t\t\t\tisValueProxy = true;\n\t\t\t\t\t\temitValue = value; //is a proxy\n\t\t\t\t\t\tif(!this.emitReference) {\n\t\t\t\t\t\t\temitValue = simpleClone(emitValue);\n\t\t\t\t\t\t\temitOldValue = simpleClone(emitOldValue); //deep copy with no proxies inside\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tadd2emitQueue_bubble(this.delay, dataNode, property, emitOldValue, oldValue!==undefined, emitValue, isValueProxy);\n\t\t\t\t\tif(shouldDestroy) {\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\tProxserve.destroy(oldValue);\n\t\t\t\t\t\t}, this.delay + 1000); //postpone this cpu intense function for later, probably when proxserve is not is use\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\tdeleteProperty: (target/*same as parent scope 'target'*/, property) => {\n\t\t\t\t\tif(!target.propertyIsEnumerable(property) || typeof property === 'symbol') {\n\t\t\t\t\t\t//non-proxied properties simply get deleted and nothing more\n\t\t\t\t\t\tdelete target[property];\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dataNode[NID].status === statuses[2]) { //blocked from changing values\n\t\t\t\t\t\tconsole.error(`can't delete property '${property}'. object is blocked.`);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(property in target) {\n\t\t\t\t\t\tlet oldValue;\n\t\t\t\t\t\tlet emitOldValue = target[property]; //should not be proxy\n\t\t\t\t\t\tif(!this.emitReference) {\n\t\t\t\t\t\t\temitOldValue = simpleClone(emitOldValue); //deep copy with no proxies inside\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet shouldDestroy = false;\n\t\t\t\t\t\tif(dataNode[property] !== undefined && dataNode[property][ND].objects.proxy !== undefined) {\n\t\t\t\t\t\t\t//about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\t\toldValue = dataNode[property][ND].objects.proxy; //the sub-proxy\n\t\t\t\t\t\t\tdataNode[property][ND].objects.isDeleted = true;\n\t\t\t\t\t\t\tif(this.strict) {\n\t\t\t\t\t\t\t\tshouldDestroy = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete target[property]; //actual delete\n\n\t\t\t\t\t\tadd2emitQueue_bubble(this.delay, dataNode, property, emitOldValue, oldValue!==undefined, undefined, false);\n\t\t\t\t\t\tif(shouldDestroy) {\n\t\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\t\tProxserve.destroy(oldValue);\n\t\t\t\t\t\t\t}, this.delay + 1000); //postpone this cpu intense function for later, probably when proxserve is not is use\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn true; //do nothing because there's nothing to delete\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tdataNode[ND].objects.proxy = revocable.proxy;\n\t\t\tdataNode[ND].objects.revoke = revocable.revoke;\n\n\t\t\tif(typeoftarget === 'Object') {\n\t\t\t\tlet keys = Object.keys(target);\n\t\t\t\tfor(let key of keys) {\n\t\t\t\t\tlet typeofproperty = realtypeof(target[key]);\n\t\t\t\t\tif(acceptableTypes.includes(typeofproperty)) {\n\t\t\t\t\t\tthis.createProxy(dataNode, key); //recursively make child objects also proxies\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(typeoftarget === 'Array') {\n\t\t\t\tfor(let i = 0; i < target.length; i++) {\n\t\t\t\t\tlet typeofproperty = realtypeof(target[i]);\n\t\t\t\t\tif(acceptableTypes.includes(typeofproperty)) {\n\t\t\t\t\t\tthis.createProxy(dataNode, i); //recursively make child objects also proxies\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconsole.warn('Not Implemented');\n\t\t\t}\n\n\t\t\treturn revocable.proxy;\n\t\t}\n\t\telse {\n\t\t\tthrow new Error('Must observe an '+acceptableTypes.join('/'));\n\t\t}\n\t}\n\n\t/**\n\t * Recursively revoke proxies, allowing them to be garbage collected.\n\t * this functions delays by delay+1000 milliseconds to let time for all events to finish\n\t * @param {*} proxy \n\t */\n\tstatic destroy(proxy) {\n\t\tlet objects;\n\t\ttry {\n\t\t\tobjects = proxy.$getProxserveObjects();\n\t\t} catch(error) {\n\t\t\treturn; //proxy variable isn't a proxy\n\t\t}\n\n\t\tif(!objects.isDeleted) {\n\t\t\tobjects.isDeleted = true;\n\t\t}\n\n\t\tlet typeofproxy = realtypeof(proxy);\n\n\t\tif(acceptableTypes.includes(typeofproxy)) {\n\t\t\tif(typeofproxy === 'Object') {\n\t\t\t\tlet keys = Object.keys(proxy);\n\t\t\t\tfor(let key of keys) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet typeofproperty = realtypeof(proxy[key]);\n\t\t\t\t\t\tif(acceptableTypes.includes(typeofproperty)) {\n\t\t\t\t\t\t\tProxserve.destroy(proxy[key]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(error) {\n\t\t\t\t\t\tconsole.error(error); //don't throw and kill the whole process just if this iteration fails\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(typeofproxy === 'Array') {\n\t\t\t\tfor(let i = proxy.length - 1; i >= 0; i--) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet typeofproperty = realtypeof(proxy[i]);\n\t\t\t\t\t\tif(acceptableTypes.includes(typeofproperty)) {\n\t\t\t\t\t\t\tProxserve.destroy(proxy[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(error) {\n\t\t\t\t\t\tconsole.error(error); //don't throw and kill the whole process just if this iteration fails\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconsole.warn('Not Implemented');\n\t\t\t}\n\n\t\t\tobjects.revoke();\n\t\t\tobjects.proxy = null;\n\t\t}\n\t}\n\n\tstatic splitPath(path) {\n\t\treturn splitPath(path);\n\t}\n\n\tstatic evalPath(obj, path) {\n\t\treturn evalPath(obj, path);\n\t}\n}\n\nmodule.exports = exports = Proxserve; //makes ParcelJS expose this globally (for all platforms) after bundling everything"]}