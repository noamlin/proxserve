{"version":3,"names":["ND","Symbol","for","NID","proxyTypes","Object","Array","NODE_STATUSES","PROXY_STATUSES","EVENTS","realtypeof","variable","rawType","prototype","toString","call","substring","length","splitPath","path","i","betweenBrackets","onlyDigits","resultsArr","tmp","char","push","parseInt","code","charCodeAt","on","args","listener","id","deep","once","event","events","keys","isArray","names","Error","join","dataNode","this","segments","property","createNodes","listenersPool","listeners","shallow","listenerObj","type","func","undefined","removeById","listenersArr","splice","whoami","name","force","metadata","dataTree","status","active","blocked","proxyNode","target","fullPath","console","warn","stopped","property2path","obj","typeofobj","unproxify","value","typeofvalue","$getOriginalTarget","error","key","parentDataNode","parentProxyNode","propertyPath","create","parentNode","isTreePrototype","assign","noStackFlag","stackTraceLog","change","logLevel","stack","functionsTrace","split","map","trim","toLowerCase","indexOf","shift","pathname","verb","unshift","log","oldValue","getProxyValue","alive","proxy","_a","initEmitEvent","wasOldValueProxy","isValueProxy","trace","deferredEvents","changeType","update","delete","splicing","shouldCapture","bubbleEmit","captureEmit","thisValue","iterateAndEmit","nextChange","subValue","subOldValue","subChange","childNode","includes","initFunctionEmitEvent","funcName","funcArgs","isActiveByInheritance","hasOwnProperty","slice","deleted","start","deleteCount","items","newLength","pseudoMethodsNames","pseudoMethods","pseudoMethodsExtended","synonym","Proxserve","static","options","strict","methodsEmitRaw","debug","destroyDelay","_b","newNodes","proxyTree","createProxy","targetProperty","typeoftarget","revocable","Proxy","get","proxyMethods","getPrototypeOf","bind","propertyIsEnumerable","set","startsWith","descriptor","getOwnPropertyDescriptor","enumerable","isOldValueProxy","setTimeout","destroy","defineProperty","deleteProperty","revoke","typeofproperty","types","$getProxserveNodes","typeofproxy","revoked","object","evalPath"],"sources":["../src/globals.ts","../src/general-functions.ts","../src/pseudo-methods.ts","../src/supporting-functions.ts","../src/event-emitter.ts","../src/proxy-methods.ts","../src/index.ts","../src/constants.ts"],"sourcesContent":["/**\n * 2023 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nexport const ND = Symbol.for('proxserve_node_data'); // key for the data of a node\nexport const NID = Symbol.for('proxserve_node_inherited_data'); // key for the inherited data of a node\n\n// acceptable types to be proxied\nexport const proxyTypes = {\n\t\"Object\": true,\n\t\"Array\": true,\n};\n\n// statuses of data-nodes\nexport enum NODE_STATUSES {\n\tactive = 'active',\n\tstopped = 'stopped',\n\tblocked = 'blocked',\n\tsplicing = 'splicing',\n};\n\n// statuses of proxies\nexport enum PROXY_STATUSES {\n\talive = 'alive',\n\tdeleted = 'deleted',\n\trevoked = 'revoked',\n};\n\n// event names that can be emitted\nexport enum EVENTS {\n\tcreate = 'create',\n\tupdate = 'update',\n\tdelete = 'delete',\n\tsplice = 'splice',\n\tshift = 'shift',\n\tunshift = 'unshift',\n};","/**\n * 2023 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nimport { SomeObject, SomeArray, VariableTypes } from './types/globals';\n\n/**\n * return a string representing the full type of the variable\n */\nexport function realtypeof(variable: any): VariableTypes {\n\tlet rawType = Object.prototype.toString.call(variable); //[object Object], [object Array], [object Number]...\n\treturn rawType.substring(8, rawType.length - 1) as VariableTypes;\n}\n\n/**\n * check if variable is a number or a string of a number\n * @param variable \n */\n/*export function isNumeric(variable: any): boolean {\n\tif(typeof variable === 'string' && variable === '') {\n\t\treturn false;\n\t}\n\t\n\treturn !isNaN(variable as number);\n}*/\n\n/**\n * recursively clones objects and array\n */\nconst simpleCloneSet = new WeakSet();\nexport function simpleClone(variable: any): any {\n\tlet typeofvar = realtypeof(variable);\n\n\tif(typeofvar === 'Object') {\n\t\tconst obj = variable as SomeObject;\n\t\tsimpleCloneSet.add(obj);\n\t\tconst cloned = {};\n\t\tlet keys = Object.keys(obj);\n\t\tfor(let key of keys) {\n\t\t\tif(simpleCloneSet.has(obj[key])) {\n\t\t\t\tcloned[key] = obj[key];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcloned[key] = simpleClone(obj[key]);\n\t\t\t}\n\t\t}\n\t\treturn cloned;\n\t}\n\telse if(typeofvar === 'Array') {\n\t\tconst arr = variable as SomeArray;\n\t\tsimpleCloneSet.add(arr);\n\t\tconst cloned = [] as any[];\n\t\tfor(let i = 0; i < arr.length; i++) {\n\t\t\tif(simpleCloneSet.has(arr[i])) {\n\t\t\t\tcloned[i] = arr[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcloned[i] = simpleClone(arr[i]);\n\t\t\t}\n\t\t}\n\t\treturn cloned;\n\t}\n\telse { // hopefully a primitive\n\t\tif(typeofvar !== 'Undefined' && typeofvar !== 'Null' && typeofvar !== 'Boolean' && typeofvar !== 'Number'\n\t\t&& typeofvar !== 'BigInt' && typeofvar !== 'String') {\n\t\t\tconsole.warn(`Can't clone a variable of type ${typeofvar}`);\n\t\t}\n\t\treturn variable;\n\t}\n}\n\n/**\n * splits a path to an array of properties\n * (benchmarked and is faster than regex and split())\n * @param path \n */\nexport function splitPath(path: string): Array<string|number> {\n\tif(typeof path !== 'string' || path === '') {\n\t\treturn [];\n\t}\n\t\n\tlet i = 0, betweenBrackets = false, onlyDigits = false;\n\t//loop will skip over openning '.' or '['\n\tif(path[0] === '.') {\n\t\ti = 1;\n\t} else if(path[0] === '[') {\n\t\ti = 1;\n\t\tbetweenBrackets = true;\n\t\tonlyDigits = true;\n\t}\n\n\tlet resultsArr = [] as Array<string|number>;\n\tlet tmp = '';\n\tfor(; i < path.length; i++) {\n\t\tlet char = path[i];\n\n\t\tif(betweenBrackets) {\n\t\t\tif(char === ']') {\n\t\t\t\tif(onlyDigits) {\n\t\t\t\t\tresultsArr.push(parseInt(tmp, 10));\n\t\t\t\t} else {\n\t\t\t\t\tresultsArr.push(tmp);\n\t\t\t\t}\n\n\t\t\t\tbetweenBrackets = false;\n\t\t\t\tonlyDigits = false;\n\t\t\t\ttmp = '';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(onlyDigits) {\n\t\t\t\t\tlet code = char.charCodeAt(0);\n\t\t\t\t\tif(code < 48 || code > 57) { //less than '0' char or greater than '9' char\n\t\t\t\t\t\tonlyDigits = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp += char;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(char === '[') {\n\t\t\t\tbetweenBrackets = true;\n\t\t\t\tonlyDigits = true;\n\t\t\t}\n\t\t\t\n\t\t\t//check if starting a new property but avoid special case of [prop][prop]\n\t\t\tif(char === '.' || char === '[') {\n\t\t\t\tif(tmp !== '') {\n\t\t\t\t\tresultsArr.push(tmp);\n\t\t\t\t\ttmp = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttmp += char;\n\t\t\t}\n\t\t}\n\t}\n\tif(tmp !== '') {\n\t\tresultsArr.push(tmp);\n\t}\n\treturn resultsArr;\n}\n\n/**\n * evaluate a long path and return the designated object and its referred property\n */\nexport function evalPath(obj: SomeObject, path: string): {\n\tobject: SomeObject,\n\tproperty: string | number,\n\tvalue: any,\n} {\n\tif(path === '') {\n\t\treturn {\n\t\t\tobject: obj,\n\t\t\tproperty: '',\n\t\t\tvalue: obj,\n\t\t};\n\t}\n\n\tlet segments = splitPath(path);\n\tlet i: number;\n\tfor(i = 0; i <= segments.length - 2; i++) { // iterate until one before last property because they all must exist\n\t\tobj = obj[segments[i]];\n\t\tif(typeof obj === 'undefined') {\n\t\t\tthrow new Error(`Invalid path was given - \"${path}\"`);\n\t\t}\n\t}\n\treturn {\n\t\tobject: obj,\n\t\tproperty: segments[i],\n\t\tvalue: obj[ segments[i] ],\n\t};\n}","/**\n * 2023 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n// Pseudo methods are methods that aren't really on the object - not as a property nor via its prototype\n// thus they will not be retrieved via \"for..in\" and etcetera. Their property name is actually undefined, but\n// calling it will return the method via the JS proxy's \"get\" handler.\n// (i.e. someProxserve.pseudoFunction will return the pseudoFunction)\n\"use strict\"\n\nimport { EVENTS, NODE_STATUSES, ND, NID } from './globals';\nimport type { ListenerData, EVENT_NAMES } from './types/globals';\nimport type { PseudoThis } from './types/proxserve-class';\nimport type {\n\tStopFunction, BlockFunction, ActivateFunction,\n\tOnFunction, OnceFunction,\n\tRemoveListenerFunction, RemoveAllListenersFunction,\n\tGetProxserveNameFunction, WhoAMI,\n\tGetOriginalTargetFunction, GetProxserveNodesFunction,\n} from './types/pseudo-methods';\nimport { createNodes } from './supporting-functions';\nimport { splitPath } from './general-functions';\n\nexport const stop: StopFunction = function stop(this: PseudoThis) {\n\tthis.dataNode[NID].status = NODE_STATUSES.stopped;\n};\n\nexport const block: BlockFunction = function block(this: PseudoThis) {\n\tthis.dataNode[NID].status = NODE_STATUSES.blocked;\n};\n\nexport const activate: ActivateFunction = function activate(this: PseudoThis, force = false): void {\n\tif(force || this.dataNode === this.metadata.dataTree) { // force activation or we are on root proxy\n\t\tthis.dataNode[NID].status = NODE_STATUSES.active;\n\t}\n\telse {\n\t\tdelete this.dataNode[NID].status;\n\t}\n};\n\nexport const on: OnFunction = function on(this: PseudoThis, args) {\n\tconst {\n\t\tpath = '',\n\t\tlistener,\n\t\tid,\n\t\tdeep = false,\n\t\tonce = false,\n\t} = args;\n\t// its nicer to expose `event` to the user,\n\t// but since it is semi-reserved word, we internally rename it to `events`\n\tlet { event: events } = args;\n\n\tif(events === 'change') {\n\t\tevents = Object.keys(EVENTS) as EVENT_NAMES[]; // will listen to all events\n\t} else if(!Array.isArray(events)) {\n\t\tevents = [events];\n\t}\n\n\tfor(let event of events) {\n\t\tif(!EVENTS[event]) {\n\t\t\tconst names = Object.keys(EVENTS);\n\t\t\tthrow new Error(`${event} is not a valid event. valid events are ${names.join(',')}`);\n\t\t}\n\t}\n\t\n\tlet dataNode = this.dataNode;\n\tlet segments = splitPath(path);\n\tfor(let property of segments) { // traverse down the tree\n\t\tif(!dataNode[property]) {\n\t\t\t// create data-nodes if needed (in dataNode[property]), but don't create/overwrite proxy-nodes\n\t\t\tcreateNodes(dataNode, property);\n\t\t}\n\n\t\tdataNode = dataNode[property];\n\t}\n\n\tlet listenersPool = dataNode[ND].listeners.shallow;\n\tif(deep) {\n\t\tlistenersPool = dataNode[ND].listeners.deep;\n\t}\n\n\tlet listenerObj = {\n\t\ttype: events,\n\t\tonce,\n\t\tfunc: listener\n\t} as ListenerData;\n\n\tif(id !== undefined) {\n\t\tlistenerObj.id = id;\n\t}\n\tlistenersPool.push(listenerObj);\n};\n\nexport const once: OnceFunction = function once(this: PseudoThis, args) {\n\targs.once = true;\n\ton.call(this, args);\n};\n\nfunction removeById(listenersArr: ListenerData[], id: string | number | Function): void {\n\tfor(let i = listenersArr.length - 1; i >= 0; i--) {\n\t\tlet listenerObj = listenersArr[i];\n\t\tif((id !== undefined && listenerObj.id === id) || listenerObj.func === id) {\n\t\t\tlistenersArr.splice(i, 1);\n\t\t}\n\t}\n}\n\nexport const removeListener: RemoveListenerFunction = function removeListener(this: PseudoThis, args) {\n\tconst { id, path = '' } = args;\n\tconst fullPath = `${this.dataNode[ND].path}${path}`;\n\tlet dataNode = this.dataNode;\n\tconst segments = splitPath(path);\n\n\t// traverse down the tree\n\tfor(let property of segments) {\n\t\tif(!dataNode[property]) {\n\t\t\tconsole.warn(`can't remove listener from a non-existent path '${fullPath}'`);\n\t\t\treturn;\n\t\t}\n\t\tdataNode = dataNode[property];\n\t}\n\n\tremoveById(dataNode[ND].listeners.shallow, id);\n\tremoveById(dataNode[ND].listeners.deep, id);\n};\n\nexport const removeAllListeners: RemoveAllListenersFunction = function removeAllListeners(this: PseudoThis, path = '') {\n\tconst fullPath = `${this.dataNode[ND].path}${path}`;\n\tconst segments = splitPath(path);\n\tlet dataNode = this.dataNode;\n\n\t//traverse down the tree\n\tfor(let property of segments) {\n\t\tif(!dataNode[property]) {\n\t\t\tconsole.warn(`can't remove all listeners from a non-existent path '${fullPath}'`);\n\t\t\treturn;\n\t\t}\n\t\tdataNode = dataNode[property];\n\t}\n\n\tdataNode[ND].listeners.shallow = [] as ListenerData[];\n\tdataNode[ND].listeners.deep = [] as ListenerData[];\n};\n\nexport const getOriginalTarget: GetOriginalTargetFunction = function getOriginalTarget(this: PseudoThis) {\n\treturn this.proxyNode[ND].target;\n};\n\nexport const getProxserveName: GetProxserveNameFunction = function getProxserveName(this: PseudoThis) {\n\treturn this.dataNode[NID].name;\n};\n\nexport const whoami: WhoAMI = function whoami(this: PseudoThis) {\n\treturn this.dataNode[NID].name + this.dataNode[ND].path;\n};\n\nexport const getProxserveNodes: GetProxserveNodesFunction = function getProxserveNodes(this: PseudoThis) {\n\treturn { dataNode: this.dataNode, proxyNode: this.proxyNode };\n};","/**\n * 2023 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nimport { proxyTypes, ND, NID, EVENTS } from './globals';\nimport type { TargetVariable, ListenerData, ChangeEvent } from './types/globals';\nimport type { DataNode, ProxyNode, ProxserveInstanceMetadata, PseudoThis } from './types/proxserve-class';\nimport { realtypeof } from './general-functions';\nimport { whoami } from './pseudo-methods';\n\n/**\n * Convert property name to valid path segment\n */\nexport function property2path(obj: any, property: string|number): string {\n\tif(typeof property === 'symbol') {\n\t\tthrow new Error(`property of type \"symbol\" isn't path'able`);\n\t}\n\n\tconst typeofobj = realtypeof(obj);\n\tswitch(typeofobj) {\n\t\tcase 'Object': {\n\t\t\treturn `.${property}`;\n\t\t}\n\t\tcase 'Array': {\n\t\t\treturn `[${property}]`;\n\t\t}\n\t\tdefault: {\n\t\t\tconsole.warn(`Not Implemented (type of '${typeofobj}')`);\n\t\t\treturn property as string;\n\t\t}\n\t}\n}\n\n/**\n * recursively switch between all proxies to their original targets.\n * note: original targets should never hold proxies under them,\n * thus altering the object references (getting from 'value') should be ok.\n * if whoever uses this library decides to\n * \t1. create a proxy with children (sub-proxies)\n * \t2. create a regular object\n * \t3. adding sub-proxies to the regular object\n * \t4. attaching the regular object to the proxy\n * then this regular object will be altered.\n */\nexport function unproxify(value: any): any {\n\tconst typeofvalue = realtypeof(value);\n\n\tif(proxyTypes[typeofvalue]) {\n\t\tlet target = value;\n\t\ttry {\n\t\t\ttarget = value.$getOriginalTarget();\n\t\t} catch(error) {}\n\n\t\tswitch(typeofvalue) {\n\t\t\tcase 'Object':\n\t\t\t\tlet keys = Object.keys(target);\n\t\t\t\tfor(let key of keys) {\n\t\t\t\t\ttarget[key] = unproxify(target[key]); // maybe alters target and maybe returning the exact same object\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'Array':\n\t\t\t\tfor(let i=0; i < target.length; i++) {\n\t\t\t\t\ttarget[i] = unproxify(target[i]); // maybe alters target and maybe returning the exact same object\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.warn(`Not Implemented (type of '${typeofvalue}')`);\n\t\t}\n\n\t\treturn target;\n\t}\n\telse {\n\t\treturn value; // primitive\n\t}\n}\n\n/**\n * create or reset a node in a tree of meta-data (mainly path related)\n * and optionally create a node in a tree of proxy data (mainly objects related)\n */\nexport function createNodes(\n\tparentDataNode: DataNode,\n\tproperty: string | number,\n\tparentProxyNode?: ProxyNode,\n\ttarget?: TargetVariable,\n): { dataNode: DataNode, proxyNode: ProxyNode | undefined } {\n\t//handle property path\n\tlet propertyPath: string;\n\tif(parentProxyNode?.[ND].target) {\n\t\tpropertyPath = property2path(parentProxyNode[ND].target, property);\n\t} else {\n\t\tpropertyPath = property2path({}, property); // if parent doesn't have target then treat it as object\n\t}\n\t\n\t//handle data node\n\tlet dataNode: DataNode = parentDataNode[property]; // try to receive existing data-node\n\tif(!dataNode) {\n\t\tdataNode = {\n\t\t\t[NID]: Object.create(parentDataNode[NID]),\n\t\t\t[ND]: {\n\t\t\t\tparentNode: parentDataNode,\n\t\t\t\tlisteners: {\n\t\t\t\t\tshallow: [] as ListenerData[],\n\t\t\t\t\tdeep: [] as ListenerData[],\n\t\t\t\t},\n\t\t\t}\n\t\t} as DataNode;\n\t\tparentDataNode[property] = dataNode;\n\t}\n\n\tdelete dataNode[NID].status; // clears old status in case a node previously existed\n\t// updates path (for rare case where parent was array and then changed to object or vice versa)\n\tif(!parentDataNode[ND].isTreePrototype) {\n\t\tObject.assign(dataNode[ND], {\n\t\t\tpath: parentDataNode[ND].path + propertyPath,\n\t\t\tpropertyPath\n\t\t});\n\t}\n\telse {\n\t\tObject.assign(dataNode[ND], {\n\t\t\tpath: '',\n\t\t\tpropertyPath: ''\n\t\t});\n\t}\n\n\t// handle proxy node\n\tlet proxyNode: ProxyNode | undefined;\n\tif(parentProxyNode) {\n\t\tproxyNode = {\n\t\t\t[NID]: Object.create(parentProxyNode[NID]),\n\t\t\t[ND]: {\n\t\t\t\ttarget: target as TargetVariable,\n\t\t\t\tdataNode,\n\t\t\t},\n\t\t};\n\n\t\tparentProxyNode[property] = proxyNode;\n\n\t\t// attach nodes to each other\n\t\tdataNode[ND].proxyNode = proxyNode;\n\t} else {\n\t\t// this scenario is dangerous and exists only for `on()` of future variables (paths) that don't yet exist\n\t\tproxyNode = undefined;\n\t}\n\n\treturn { dataNode, proxyNode };\n}\n\nlet noStackFlag = false;\nexport function stackTraceLog(\n\tdataNode: DataNode,\n\tchange: ChangeEvent,\n\tlogLevel?: ProxserveInstanceMetadata['trace'],\n) {\n\tif (logLevel !== 'normal' && logLevel !== 'verbose') {\n\t\treturn;\n\t}\n\n\tconst err = new Error();\n\tconst stack = err.stack;\n\t\n\tif (!stack) {\n\t\tif (!noStackFlag) {\n\t\t\t// log this only once. no need to spam.\n\t\t\tconsole.error('Can\\'t log stack trace of proxserve. browser/runtime doesn\\'t support Error.stack');\n\t\t\tnoStackFlag = true;\n\t\t}\n\t\treturn;\n\t}\n\n\t// break stack to individual lines. each line will point to a file and function.\n\tconst functionsTrace = stack.split('\\n').map((value) => {\n\t\treturn value.trim();\n\t});\n\t// remove first and useless Error line.\n\tif (functionsTrace[0].toLowerCase().indexOf('error') === 0) {\n\t\tfunctionsTrace.shift();\n\t}\n\t// delete this function's own line.\n\tfunctionsTrace.shift();\n\t// delete `initEmitEvent` line - overwrite it with a title.\n\tfunctionsTrace[0] = 'Stack Trace:';\n\n\t// log the message header.\n\tconst pathname = whoami.call({ dataNode } as PseudoThis) + change.path;\n\tlet verb = change.type;\n\tif (change.type === EVENTS.shift || change.type === EVENTS.unshift) {\n\t\tverb += 'ed';\n\t} else {\n\t\tverb += 'd';\n\t}\n\n\tconsole.log(\n\t\t'%c                                                                ',\n\t\t'border-bottom: 1px solid #008;',\n\t);\n\tconsole.log(\n\t\t`%c${pathname} %chas been ${verb}:`,\n\t\t'font-weight: bold; color: #008;',\n\t\t'color: #000;',\n\t);\n\n\t// verbose message with assigned values\n\tif (logLevel === 'verbose') {\n\t\tif (change.type === 'splice' || change.type === 'unshift') {\n\t\t\tconsole.log(\n\t\t\t\t`%cArguments of ${change.type}:`,\n\t\t\t\t'color: #555; font-style: italic;',\n\t\t\t);\n\t\t\tconsole.log(change.args);\n\t\t}\n\n\t\tconsole.log(\n\t\t\t'%cOld value was:',\n\t\t\t'color: #555; font-style: italic;',\n\t\t);\n\t\tconsole.log(change.oldValue);\n\t\tconsole.log(\n\t\t\t'%cNew value is:',\n\t\t\t'color: #555; font-style: italic;',\n\t\t);\n\t\tconsole.log(change.value);\n\t}\n\n\t// the files and lines list message\n\tconsole.log(\n\t\t`%c${functionsTrace.join('\\n')}`,\n\t\t'color: #999;',\n\t);\n\tconsole.log(\n\t\t'%c                                                                ',\n\t\t'border-top: 1px solid #008;',\n\t);\n}\n","/**\n * 2023 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nimport { EVENTS, NODE_STATUSES, PROXY_STATUSES, ND, NID } from './globals';\nimport type { EVENT_NAMES, ChangeEvent, DeferredEvent, ListenerData } from './types/globals';\nimport type { DataNode, ProxserveInstanceMetadata } from './types/proxserve-class';\nimport { property2path, stackTraceLog } from './supporting-functions';\nimport { splitPath } from './general-functions';\n\n/**\n * try to get the proxy-object from a data-node. if can't then from it's parent's proxy\n * @param dataNode \n * @param property - the property as the dataNode is assigned on its parent\n */\nfunction getProxyValue(dataNode: DataNode, property?: string): any {\n\tif(dataNode[ND].proxyNode && dataNode[ND].proxyNode[NID].status === PROXY_STATUSES.alive) {\n\t\treturn dataNode[ND].proxyNode[ND].proxy; // actual proxy of child node\n\t}\n\telse {\n\t\tif(!property) {\n\t\t\t// my property on the parent\n\t\t\tproperty = splitPath(dataNode[ND].propertyPath)[0] as string;\n\t\t}\n\n\t\tlet parentNode = dataNode[ND].parentNode;\n\n\t\tif(parentNode[ND].proxyNode && parentNode[ND].proxyNode[NID].status === PROXY_STATUSES.alive) {\n\t\t\treturn parentNode[ND].proxyNode[ND].proxy?.[property]; // proxy or primitive via parent's proxy object\n\t\t}\n\t\telse {\n\t\t\t// if we reached here then probably we are on a capture phase of a deep deletion.\n\t\t\t// for example 'obj.sub1.sub2' gets 'delete obj.sub1' so now there are no values for 'sub2' nor its parent 'sub1'.\n\t\t\t// the warning is turned off because this situation seems okay\n\t\t\t// console.warn(`reached a capture level where neither child not parent proxy-nodes exist`);\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\n/**\n * process event and then bubble up and capture down the data tree\n */\nexport function initEmitEvent(\n\tdataNode: DataNode,\n\tproperty: string,\n\toldValue: any,\n\twasOldValueProxy: boolean,\n\tvalue: any,\n\tisValueProxy: boolean,\n\ttrace?: ProxserveInstanceMetadata['trace'],\n) {\n\tif(oldValue === value // no new change was made\n\t|| !dataNode[ND].proxyNode) { // proxy-node is detached from data-node\n\t\treturn;\n\t}\n\n\tlet proxyNode = dataNode[ND].proxyNode;\n\tif(proxyNode[NID].status !== PROXY_STATUSES.alive) { // altered a deleted proxy\n\t\treturn;\n\t}\n\n\tlet changeType = EVENTS.update;\n\tif(value === undefined) {\n\t\tchangeType = EVENTS.delete;\n\t} else if(oldValue === undefined) {\n\t\tchangeType = EVENTS.create;\n\t}\n\n\tlet deferredEvents: DeferredEvent[] | undefined;\n\t// altering properties of an array that's in the middle of a splicing phase\n\tif(dataNode[NID].status === NODE_STATUSES.splicing) {\n\t\t// initiate (if needed) an object to hold side effect events\n\t\tif(!dataNode[ND].deferredEvents) {\n\t\t\tdataNode[ND].deferredEvents = [];\n\t\t}\n\t\t// save a reference to the deferredEvents\n\t\tdeferredEvents = dataNode[ND].deferredEvents;\n\t}\n\n\tlet path: string;\n\tif(dataNode[property]) { // changed a property which has its own data node on the tree\n\t\tdataNode = dataNode[property];\n\t\tpath = '';\n\t} else {\n\t\tpath = property2path(proxyNode[ND].target, property);\n\t}\n\n\tlet change: ChangeEvent = {\n\t\tpath, value, oldValue, type: changeType,\n\t};\n\n\tif(!deferredEvents) {\n\t\t// (try to) log before emitting the event\n\t\tstackTraceLog(dataNode, change, trace);\n\n\t\tbubbleEmit(dataNode, change, property);\n\t\n\t\tif(wasOldValueProxy || isValueProxy) { // old value or new value are proxy meaning they are objects with children\n\t\t\tcaptureEmit(dataNode, change);\n\t\t}\n\t}\n\telse {\n\t\tdeferredEvents.push({dataNode, change, shouldCapture: wasOldValueProxy || isValueProxy});\n\t}\n}\n\n/**\n * bubbling phase - go up the data tree and emit\n * @param dataNode\n * @param change\n * @param property - property name of the data-node (i.e. as the data-node is assigned to its parent)\n */\nfunction bubbleEmit(dataNode: DataNode, change: ChangeEvent, property?: string): void {\n\tif(dataNode[NID].status === NODE_STATUSES.stopped) {\n\t\treturn; // not allowed to emit\n\t}\n\n\tlet thisValue = getProxyValue(dataNode, property);\n\n\tif(change.path === '') { // iterate over 'shallow' listeners\n\t\titerateAndEmit(dataNode[ND].listeners.shallow, thisValue, change);\n\t}\n\n\t// iterate over 'deep' listeners\n\titerateAndEmit(dataNode[ND].listeners.deep, thisValue, change);\n\n\tif(!dataNode[ND].parentNode[ND].isTreePrototype) { // we are not on root node yet\n\t\t// create a shallow copy of 'change' and update its path\n\t\t// (we don't want to alter the 'change' object that was just emitted to a listener)\n\t\tlet nextChange: ChangeEvent = {\n\t\t\t...change,\n\t\t\tpath: dataNode[ND].propertyPath + change.path\n\t\t};\n\n\t\tbubbleEmit(dataNode[ND].parentNode, nextChange);\n\t}\n}\n\n/**\n * capturing phase - go down the data tree and emit\n * @param dataNode\n * @param change\n */\nfunction captureEmit(dataNode: DataNode, change: ChangeEvent): void {\n\tlet keys = Object.keys(dataNode);\n\tfor(let key of keys) {\n\t\tlet subValue = (typeof change.value === 'object' && change.value !== null) ? change.value[key] : undefined;\n\t\tlet subOldValue = (typeof change.oldValue === 'object' && change.oldValue !== null) ? change.oldValue[key] : undefined;\n\t\tif(subValue !== subOldValue) { //if not both undefined or same primitive or the same object\n\t\t\tlet changeType = EVENTS.update;\n\t\t\tif(subValue === undefined) {\n\t\t\t\tchangeType = EVENTS.delete;\n\t\t\t} else if(subOldValue === undefined) {\n\t\t\t\tchangeType = EVENTS.create;\n\t\t\t}\n\n\t\t\tlet subChange: ChangeEvent = {\n\t\t\t\tpath: '',\n\t\t\t\toldValue: subOldValue,\n\t\t\t\tvalue: subValue,\n\t\t\t\ttype: changeType\n\t\t\t}\n\n\t\t\t// failing the status check will not emit for current property (but sub-properties might still be forcibly active)\n\t\t\tlet childNode = dataNode[key];\n\t\t\tif(childNode[NID].status !== NODE_STATUSES.stopped) {\n\t\t\t\tlet thisValue = getProxyValue(childNode, key);\n\t\t\t\titerateAndEmit(childNode[ND].listeners.shallow, thisValue, subChange);\n\t\t\t}\n\n\t\t\tcaptureEmit(childNode, subChange);\n\t\t}\n\t}\n}\n\n/**\n * iterate over an array of listeners, handle 'once' listeners and emit\n * @param listenersArr \n * @param thisValue \n * @param change \n */\nfunction iterateAndEmit(listenersArr: ListenerData[], thisValue: any, change: ChangeEvent): void {\n\tfor(let i = listenersArr.length - 1; i >= 0; i--) {\n\t\tlet listener = listenersArr[i];\n\t\tif(listener.type.includes(change.type)) {\n\t\t\tif(listener.once === true) {\n\t\t\t\tlistenersArr.splice(i, 1);\n\t\t\t}\n\t\t\tlistener.func.call(thisValue, change);\n\t\t}\n\t}\n}\n\n/**\n * process special event for a built-in method and then bubble up the data tree\n * @param dataNode\n * @param funcName - the method's name\n * @param funcArgs - the method's arguments\n * @param oldValue\n * @param value\n */\nexport function initFunctionEmitEvent(\n\tdataNode: DataNode,\n\tfuncName: EVENT_NAMES,\n\tfuncArgs: ChangeEvent['args'],\n\toldValue: any,\n\tvalue: any,\n\ttrace?: ProxserveInstanceMetadata['trace'],\n) {\n\tlet change: ChangeEvent = {\n\t\tpath: '', value, oldValue, type: funcName, args: funcArgs,\n\t};\n\n\t// (try to) log before emitting the event\n\tstackTraceLog(dataNode, change, trace);\n\n\tbubbleEmit(dataNode, change);\n\n\tif(dataNode[ND].deferredEvents) {\n\t\t// manually handle the side-effect events that were caught\n\t\t// in order to not bubble up, but should capture down\n\t\tfor(let event of dataNode[ND].deferredEvents!) {\n\t\t\tif(event.change.path === '') {\n\t\t\t\t// no path means its an event directly on the property, not on the parent.\n\t\t\t\t// i.e: not an event with path \"0\" on \".arr\", but an event with no path on \".arr[0]\".\n\t\t\t\t// function event on \"arr\" already ran, but now a regular event on \"arr[0]\" is due\n\t\t\t\tlet thisValue = getProxyValue(event.dataNode);\n\t\t\t\titerateAndEmit(event.dataNode[ND].listeners.shallow, thisValue, event.change);\n\t\t\t\titerateAndEmit(event.dataNode[ND].listeners.deep, thisValue, event.change);\n\t\t\t}\n\n\t\t\tif(event.shouldCapture) {\n\t\t\t\tcaptureEmit(event.dataNode, event.change);\n\t\t\t}\n\t\t}\n\t\tdelete dataNode[ND].deferredEvents;\n\t}\n\telse {\n\t\tconsole.warn(`no side effect events for ${funcName} were made`);\n\t}\n}","/**\n * 2023 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n// Proxy methods are methods that will proxy JS built-in methods.\n// For examply, the proxy function for \"splice\" will handle some event stuff and then use\n// the actual \"splice\" function internally\n\"use strict\"\n\nimport { NODE_STATUSES, EVENTS, ND, NID } from './globals';\nimport type { PseudoThis } from './types/proxserve-class';\nimport type { SpliceFunction, ShiftFunction, UnshiftFunction } from './types/proxy-methods';\nimport { initFunctionEmitEvent } from './event-emitter';\n\nexport const splice: SpliceFunction = function splice(\n\tthis: PseudoThis,\n\tstart,\n\tdeleteCount,\n\t...items\n) {\n\tif(this.dataNode[NID].status !== NODE_STATUSES.active) {\n\t\t// if not active then run regular `splice`\n\t\t// which will reach the `set` of the ProxyHandler and will be blocked or events stopped, etc.\n\t\treturn Array.prototype.splice.call(this.proxyNode[ND].proxy, start, deleteCount, ...items);\n\t}\n\n\tlet isActiveByInheritance = !this.dataNode[NID].hasOwnProperty('status');\n\tthis.dataNode[NID].status = NODE_STATUSES.splicing;\n\tlet oldValue = this.proxyNode[ND].target.slice(0);\n\tlet deleted = Array.prototype.splice.call(this.proxyNode[ND].proxy, start, deleteCount, ...items); // creates many side-effect events\n\tlet args = { start, deleteCount, items };\n\t\n\tif(isActiveByInheritance) {\n\t\tdelete this.dataNode[NID].status;\n\t} else {\n\t\tthis.dataNode[NID].status = NODE_STATUSES.active;\n\t}\n\n\tinitFunctionEmitEvent(this.dataNode, EVENTS.splice, args, oldValue, this.proxyNode[ND].target, this.metadata.trace);\n\n\treturn deleted;\n}\n\nexport const shift: ShiftFunction = function shift(this: PseudoThis) {\n\tif(this.dataNode[NID].status !== NODE_STATUSES.active) {\n\t\t// if not active then run regular `shift`\n\t\t// which will reach the `set` of the ProxyHandler and will be blocked or events stopped, etc.\n\t\treturn Array.prototype.shift.call(this.proxyNode[ND].proxy);\n\t}\n\n\tlet isActiveByInheritance = !this.dataNode[NID].hasOwnProperty('status');\n\tthis.dataNode[NID].status = NODE_STATUSES.splicing;\n\tlet oldValue = this.proxyNode[ND].target.slice(0);\n\tlet deleted = Array.prototype.shift.call(this.proxyNode[ND].proxy); // creates many side-effect events\n\t\n\tif(isActiveByInheritance) {\n\t\tdelete this.dataNode[NID].status;\n\t} else {\n\t\tthis.dataNode[NID].status = NODE_STATUSES.active;\n\t}\n\n\tinitFunctionEmitEvent(this.dataNode, EVENTS.shift, {}, oldValue, this.proxyNode[ND].target, this.metadata.trace);\n\n\treturn deleted;\n}\n\nexport const unshift: UnshiftFunction = function unshift(this: PseudoThis, ...items) {\n\tif(this.dataNode[NID].status !== NODE_STATUSES.active) {\n\t\t// if not active then run regular `unshift`\n\t\t// which will reach the `set` of the ProxyHandler and will be blocked or events stopped, etc.\n\t\treturn Array.prototype.unshift.call(this.proxyNode[ND].proxy, ...items);\n\t}\n\n\tlet isActiveByInheritance = !this.dataNode[NID].hasOwnProperty('status');\n\tthis.dataNode[NID].status = NODE_STATUSES.splicing;\n\tlet oldValue = this.proxyNode[ND].target.slice(0);\n\tlet newLength: number = Array.prototype.unshift.call(this.proxyNode[ND].proxy, ...items); // creates many side-effect events\n\tlet args = { items };\n\t\n\tif(isActiveByInheritance) {\n\t\tdelete this.dataNode[NID].status;\n\t} else {\n\t\tthis.dataNode[NID].status = NODE_STATUSES.active;\n\t}\n\n\tinitFunctionEmitEvent(this.dataNode, EVENTS.unshift, args, oldValue, this.proxyNode[ND].target, this.metadata.trace);\n\n\treturn newLength;\n}\n","/**\n * 2023 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nimport { proxyTypes, NODE_STATUSES, PROXY_STATUSES, ND, NID } from './globals';\nimport type { TargetVariable, SomeObject } from './types/globals';\nimport type {\n\tProxserveInstance, ProxserveInstanceAlternatives,\n\tDataNode, ProxyNode,\n\tProxserveInstanceMetadata,\n} from './types/proxserve-class';\nimport { unproxify, createNodes } from './supporting-functions';\nimport * as pseudoMethods from './pseudo-methods';\nimport * as proxyMethods from './proxy-methods';\nimport { realtypeof, splitPath, evalPath } from './general-functions';\nimport { initEmitEvent } from './event-emitter';\nimport { DONT_PROXIFY_PREFIX, PSEUDO_METHODS_ALTERNATIVE_NAMING_PREFIX } from './constants';\n\n/**\n * save an array of all reserved function names\n * and also add synonyms to these functions\n */\nlet pseudoMethodsNames = Object.keys(pseudoMethods);\nlet pseudoMethodsExtended: Record<string | symbol, any> = {};\nfor(let i = pseudoMethodsNames.length - 1; i >= 0; i--) {\n\tlet name = pseudoMethodsNames[i];\n\tlet synonym = PSEUDO_METHODS_ALTERNATIVE_NAMING_PREFIX + name;\n\n\tpseudoMethodsNames.push(synonym);\n\tpseudoMethodsExtended[name] = pseudoMethods[name];\n\tpseudoMethodsExtended[synonym] = pseudoMethods[name];\n}\n\ninterface MakeOptions {\n\tstrict?: ProxserveInstanceMetadata['strict'];\n\tmethodsEmitRaw?: ProxserveInstanceMetadata['methodsEmitRaw'];\n\t/** internal root name of the instance */\n\tname?: string;\n\tdebug?: {\n\t\tdestroyDelay?: ProxserveInstanceMetadata['destroyDelay'];\n\t\ttrace?: ProxserveInstanceMetadata['trace'];\n\t};\n}\n\nexport class Proxserve {\n\t/**\n\t * make a new proxserve instance\n\t */\n\tstatic make<T>(target: TargetVariable, options = {} as MakeOptions): ProxserveInstance & T {\n\t\tconst {\n\t\t\tstrict = true,\n\t\t\tmethodsEmitRaw = false,\n\t\t\tname = '',\n\t\t\tdebug,\n\t\t} = options;\n\n\t\tconst destroyDelay = debug?.destroyDelay ?? 1000;\n\t\tconst trace = debug?.trace ?? 'none';\n\n\t\tlet dataTreePrototype: DataNode = {\n\t\t\t[NID]: {\n\t\t\t\tstatus: NODE_STATUSES.active,\n\t\t\t\tname,\n\t\t\t},\n\t\t\t[ND]: { isTreePrototype: true } as DataNode[typeof ND],\n\t\t};\n\t\tlet proxyTreePrototype: ProxyNode = {\n\t\t\t[NID]: { status: PROXY_STATUSES.alive },\n\t\t\t[ND]: { isTreePrototype: true } as ProxyNode[typeof ND],\n\t\t};\n\n\t\tconst newNodes = createNodes(dataTreePrototype, '', proxyTreePrototype, target);\n\n\t\tconst metadata = {\n\t\t\tstrict,\n\t\t\tmethodsEmitRaw,\n\t\t\tdestroyDelay,\n\t\t\ttrace,\n\t\t\tdataTree: newNodes.dataNode,\n\t\t\tproxyTree: newNodes.proxyNode,\n\t\t} as ProxserveInstanceMetadata;\n\n\t\treturn Proxserve.createProxy<T>(metadata, metadata.dataTree);\n\t}\n\n\t/**\n\t * create a new proxy and a new node for a property of the parent's target-object\n\t */\n\tstatic createProxy<T>(\n\t\tmetadata: ProxserveInstanceMetadata,\n\t\tparentDataNode: DataNode,\n\t\ttargetProperty?: string,\n\t): ProxserveInstance & T {\n\t\tconst parentProxyNode = parentDataNode[ND].proxyNode!;\n\t\tlet dataNode: DataNode;\n\t\tlet proxyNode: ProxyNode;\n\n\t\tif(targetProperty === undefined) { //refering to own node and not a child property (meaning root object)\n\t\t\tdataNode = parentDataNode;\n\t\t\tproxyNode = parentProxyNode;\n\t\t}\n\t\telse {\n\t\t\t//create new or reset an existing data-node and then creates a new proxy-node\n\t\t\tconst newNodes = createNodes(\n\t\t\t\tparentDataNode,\n\t\t\t\ttargetProperty,\n\t\t\t\tparentProxyNode,\n\t\t\t\tparentProxyNode[ND].target[targetProperty],\n\t\t\t);\n\t\t\tdataNode = newNodes.dataNode;\n\t\t\tproxyNode = newNodes.proxyNode!;\n\t\t}\n\n\t\tconst target = proxyNode[ND].target;\n\n\t\tconst typeoftarget = realtypeof(target);\n\n\t\tif(proxyTypes[typeoftarget]) {\n\t\t\tconst revocable = Proxy.revocable<TargetVariable>(target, {\n\t\t\t\tget: (target: TargetVariable/*same as parent scope 'target'*/, property: string|symbol, proxy) => {\n\t\t\t\t\tif(metadata.methodsEmitRaw === false && Object.prototype.hasOwnProperty.call(proxyMethods, property) && property in Object.getPrototypeOf(target)) {\n\t\t\t\t\t\t// use a proxy method instead of the built-in method that is on the prototype chain\n\t\t\t\t\t\treturn proxyMethods[property].bind({ metadata, dataNode, proxyNode });\n\t\t\t\t\t}\n\t\t\t\t\telse if(pseudoMethodsNames.includes(property as string) && typeof target[property] === 'undefined') {\n\t\t\t\t\t\t// can access a pseudo function (or its synonym) if their keywords isn't used\n\t\t\t\t\t\treturn pseudoMethodsExtended[property].bind({ metadata, dataNode, proxyNode });\n\t\t\t\t\t}\n\t\t\t\t\telse if(!target.propertyIsEnumerable(property) || typeof property === 'symbol') {\n\t\t\t\t\t\treturn target[property]; // non-enumerable or non-path'able aren't proxied\n\t\t\t\t\t}\n\t\t\t\t\telse if(\n\t\t\t\t\t\tproxyNode[property] // there's a child node\n\t\t\t\t\t\t&& proxyNode[property][ND].proxy // it holds a proxy\n\t\t\t\t\t\t&& proxyNode[property][NID].status === PROXY_STATUSES.alive\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn proxyNode[property][ND].proxy;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn target[property];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\n\t\t\t\tset: (target/*same as parent scope 'target'*/, property, value, proxy) => { //'receiver' is proxy\n\t\t\t\t\t/**\n\t\t\t\t\t * property can be a regular object because of a few possible reasons:\n\t\t\t\t\t * 1. proxy is deleted from tree but user keeps accessing it then it means he saved a reference.\n\t\t\t\t\t * 2. it is a non-enumerable property which means it was intentionally hidden.\n\t\t\t\t\t * 3. property is a symbol and symbols can't be proxied because we can't create a normal path for them.\n\t\t\t\t\t *    these properties are not proxied and should not emit change-event.\n\t\t\t\t\t *    except for: length\n\t\t\t\t\t * 4. property is manually set as raw object with the special prefix.\n\t\t\t\t\t * TODO - make a list of all possible properties exceptions (maybe function 'name'?)\n\t\t\t\t\t */\n\t\t\t\t\tif(dataNode[NID].status === NODE_STATUSES.blocked) { //blocked from changing values\n\t\t\t\t\t\tconsole.error('object is blocked. can\\'t change value of property:', property);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(\n\t\t\t\t\t\ttypeof property === 'symbol'\n\t\t\t\t\t\t|| property.startsWith(DONT_PROXIFY_PREFIX)\n\t\t\t\t\t) {\n\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(property !== 'length' && !target.propertyIsEnumerable(property)) {\n\t\t\t\t\t\t//if setting a whole new property then it is non-enumerable (yet) so a further test is needed\n\t\t\t\t\t\tlet descriptor = Object.getOwnPropertyDescriptor(target, property);\n\t\t\t\t\t\tif(typeof descriptor === 'object' && descriptor.enumerable === false) { //property was previously set\n\t\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet oldValue = target[property]; // should not be proxy\n\t\t\t\t\tlet isOldValueProxy = false;\n\t\t\t\t\tif(proxyNode[property] !== undefined && proxyNode[property][ND].proxy !== undefined) {\n\t\t\t\t\t\t// about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\tproxyNode[property][NID].status = PROXY_STATUSES.deleted;\n\t\t\t\t\t\tdelete dataNode[property][ND].proxyNode; // detach reference from data-node to proxy-node\n\t\t\t\t\t\tisOldValueProxy = true;\n\t\t\t\t\t\tif(metadata.strict) {\n\t\t\t\t\t\t\t// postpone this cpu intense function for later, probably when proxserve is not in use\n\t\t\t\t\t\t\tsetTimeout(Proxserve.destroy, metadata.destroyDelay, proxyNode[property][ND].proxy);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue = unproxify(value);\n\t\t\t\t\ttarget[property] = value; //assign new value\n\n\t\t\t\t\tlet isValueProxy = false;\n\t\t\t\t\tlet typeofvalue = realtypeof(value);\n\t\t\t\t\tif(proxyTypes[typeofvalue]) {\n\t\t\t\t\t\tProxserve.createProxy(metadata, dataNode, property); // if trying to add a new value which is an object then make it a proxy\n\t\t\t\t\t\tisValueProxy = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tinitEmitEvent(dataNode, property, oldValue, isOldValueProxy, value, isValueProxy, metadata.trace);\n\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\t/**\n\t\t\t\t * TODO - this function is incomplete and doesn't handle all of 'descriptor' scenarios\n\t\t\t\t */\n\t\t\t\tdefineProperty: (target/*same as parent scope 'target'*/, property, descriptor) => {\n\t\t\t\t\tif(typeof property === 'symbol') {\n\t\t\t\t\t\tObject.defineProperty(target, property, descriptor);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet oldValue = target[property]; //should not be proxy\n\t\t\t\t\tlet isOldValueProxy = false;\n\t\t\t\t\tif(proxyNode[property] !== undefined && proxyNode[property][ND].proxy !== undefined) {\n\t\t\t\t\t\t//about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\tproxyNode[property][NID].status = PROXY_STATUSES.deleted;\n\t\t\t\t\t\tdelete dataNode[property][ND].proxyNode; //detach reference from data-node to proxy-node\n\t\t\t\t\t\tisOldValueProxy = true;\n\t\t\t\t\t\tif(metadata.strict) {\n\t\t\t\t\t\t\t//postpone this cpu intense function for later, probably when proxserve is not is use\n\t\t\t\t\t\t\tsetTimeout(Proxserve.destroy, metadata.destroyDelay, proxyNode[property][ND].proxy);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdescriptor.value = unproxify(descriptor.value);\n\t\t\t\t\tObject.defineProperty(target, property, descriptor); //defining the new value\n\t\t\t\t\tlet value = descriptor.value;\n\t\t\t\t\tlet isValueProxy = false;\n\t\t\t\t\t//excluding non-enumerable properties from being proxied\n\t\t\t\t\tlet typeofvalue = realtypeof(descriptor.value);\n\t\t\t\t\tif(proxyTypes[typeofvalue] && descriptor.enumerable === true) {\n\t\t\t\t\t\tProxserve.createProxy(metadata, dataNode, property); //if trying to add a new value which is an object then make it a proxy\n\t\t\t\t\t\tisValueProxy = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tinitEmitEvent(dataNode, property, oldValue, isOldValueProxy, value, isValueProxy, metadata.trace);\n\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\tdeleteProperty: (target/*same as parent scope 'target'*/, property) => {\n\t\t\t\t\tif(!target.propertyIsEnumerable(property) || typeof property === 'symbol') {\n\t\t\t\t\t\t//non-proxied properties simply get deleted and nothing more\n\t\t\t\t\t\tdelete target[property];\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dataNode[NID].status === NODE_STATUSES.blocked) { //blocked from changing values\n\t\t\t\t\t\tconsole.error(`can't delete property '${property}'. object is blocked.`);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(property in target) {\n\t\t\t\t\t\tlet oldValue = target[property]; //should not be proxy\n\t\t\t\t\t\tlet isOldValueProxy = false;\n\t\t\t\t\t\tif(proxyNode[property] !== undefined && proxyNode[property][ND].proxy !== undefined) {\n\t\t\t\t\t\t\t//about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\t\tproxyNode[property][NID].status = PROXY_STATUSES.deleted;\n\t\t\t\t\t\t\tdelete dataNode[property][ND].proxyNode; //detach reference from data-node to proxy-node\n\t\t\t\t\t\t\tisOldValueProxy = true;\n\t\t\t\t\t\t\tif(metadata.strict) {\n\t\t\t\t\t\t\t\t//postpone this cpu intense function for later, probably when proxserve is not is use\n\t\t\t\t\t\t\t\tsetTimeout(Proxserve.destroy, metadata.destroyDelay, proxyNode[property][ND].proxy);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete target[property]; // actual delete\n\n\t\t\t\t\t\tinitEmitEvent(dataNode, property, oldValue, isOldValueProxy, undefined, false, metadata.trace);\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn true; //do nothing because there's nothing to delete\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as ProxyHandler<TargetVariable>) as { proxy: ProxserveInstance & T, revoke: () => void };\n\n\t\t\tproxyNode[ND].proxy = revocable.proxy;\n\t\t\tproxyNode[ND].revoke = revocable.revoke;\n\n\t\t\tif(proxyTypes[typeoftarget]) {\n\t\t\t\tlet keys = Object.keys(target); //handles both Objects and Arrays\n\t\t\t\tfor(let key of keys) {\n\t\t\t\t\tif (key.startsWith(DONT_PROXIFY_PREFIX)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tlet typeofproperty = realtypeof(target[key]);\n\t\t\t\t\tif(proxyTypes[typeofproperty]) {\n\t\t\t\t\t\tProxserve.createProxy(metadata, dataNode, key); //recursively make child objects also proxies\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconsole.warn(`Type of \"${typeoftarget}\" is not implemented`);\n\t\t\t}\n\n\t\t\treturn revocable.proxy;\n\t\t}\n\t\telse {\n\t\t\tconst types = Object.keys(proxyTypes);\n\t\t\tthrow new Error(`Must observe an ${types.join('/')}`);\n\t\t}\n\t}\n\n\t/**\n\t * Recursively revoke proxies, allowing them to be garbage collected.\n\t * this functions delays 1000 milliseconds to let time for all events to finish\n\t */\n\tstatic destroy(proxy: ProxserveInstance) {\n\t\tlet proxyNode: ProxyNode;\n\t\ttry {\n\t\t\tconst nodes = (proxy as ProxserveInstanceAlternatives).$getProxserveNodes();\n\t\t\tproxyNode = nodes.proxyNode;\n\t\t} catch(error) {\n\t\t\treturn; // proxy variable isn't a proxy\n\t\t}\n\n\t\tif(proxyNode[NID].status === PROXY_STATUSES.alive) {\n\t\t\tproxyNode[NID].status = PROXY_STATUSES.deleted;\n\t\t}\n\n\t\tlet typeofproxy = realtypeof(proxy);\n\n\t\tif(proxyTypes[typeofproxy]) {\n\t\t\tlet keys = Object.keys(proxy); // handles both Objects and Arrays\n\t\t\tfor(let key of keys) {\n\t\t\t\tif (key.startsWith(DONT_PROXIFY_PREFIX)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tlet typeofproperty = realtypeof(proxy[key]);\n\t\t\t\t\tif(proxyTypes[typeofproperty]) {\n\t\t\t\t\t\t// going to proxy[key], which is deleted, will return the original target so we will bypass it\n\t\t\t\t\t\tProxserve.destroy(proxyNode[key][ND].proxy!);\n\t\t\t\t\t}\n\t\t\t\t} catch(error) {\n\t\t\t\t\tconsole.error(error); // don't throw and kill the whole process just if this iteration fails\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tproxyNode[ND].revoke?.();\n\t\t\t//proxyNode[ND].proxy = undefined;\n\t\t\tproxyNode[NID].status = PROXY_STATUSES.revoked;\n\t\t}\n\t\telse {\n\t\t\tconsole.warn(`Type of \"${typeofproxy}\" is not implemented`);\n\t\t}\n\t}\n\n\t/**\n\t * splits a path to an array of properties\n\t */\n\tstatic splitPath(path: string): Array<string|number> {\n\t\treturn splitPath(path);\n\t}\n\n\t/**\n\t * evaluate a long path and return the designated object and its referred property\n\t */\n\tstatic evalPath(obj: SomeObject, path: string): {\n\t\tobject: SomeObject,\n\t\tproperty: string|number,\n\t\tvalue: any,\n\t} {\n\t\treturn evalPath(obj, path);\n\t}\n}\n\n// for importing this type from the main generated d.ts\nexport type { ProxserveInstance };\n","export const DONT_PROXIFY_PREFIX = '_$';\nexport const PSEUDO_METHODS_ALTERNATIVE_NAMING_PREFIX = '$';"],"mappings":"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"}