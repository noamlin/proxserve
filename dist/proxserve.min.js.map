{"version":3,"sources":["global-vars.js","general-functions.js","supporting-functions.js","reserved-methods.js","index.js"],"names":["proxyTypes","proxyStatuses","eventNames","ND","Symbol","for","NID","realtypeof","variable","rawType","Object","prototype","toString","call","substring","length","simpleCloneSet","WeakSet","simpleClone","obj","typeofobj","cloned","add","keys","key","has","i","console","warn","splitPath","path","betweenBrackets","onlyDigits","resultsArr","tmp","char","push","parseInt","code","charCodeAt","evalPath","object","property","undefined","value","segments","Error","property2path","unproxify","typeofvalue","includes","target","$getOriginalTarget","error","createDataNode","parentNode","propertyPath","objects","node","create","status","assign","stop","dataNode","block","activate","force","dataTree","on","events","listener","id","once","Array","isArray","event","join","listeners","eventPool","removeListener","arguments","fullPath","splice","removeAllListeners","getOriginalTarget","getProxserveObjects","getProxserveDataNode","getProxserveInstance","start","deleteCount","items","proxy","slice","oldValue","deleted","reservedMethodsNames","reservedMethods","name","synonym","Proxserve","constructor","strict","emitReference","emitSplice","createProxy","targetProperty","typeoftarget","revocable","Proxy","get","bind","propertyIsEnumerable","getPrototypeOf","set","descriptor","getOwnPropertyDescriptor","enumerable","emitOldValue","shouldDestroy","isDeleted","emitValue","isValueProxy","emitEvent","setTimeout","destroy","defineProperty","deleteProperty","revoke","typeofproperty","$getProxserveObjects","typeofproxy","module","exports"],"mappings":"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","file":"proxserve.min.js","sourceRoot":"../src","sourcesContent":["/**\n * Copyright 2021 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nexport let proxyTypes = ['Object', 'Array', 'Map']; //acceptable types to be proxied\nexport let proxyStatuses = ['active', 'stopped', 'blocked', 'splicing']; //statuses of proxies\nexport let eventNames = ['create', 'update', 'delete', 'splice'];\n\nexport let ND = Symbol.for('proxserve_node_data'); //key for the data of a node\nexport let NID = Symbol.for('proxserve_node_inherited_data'); //key for the inherited data of a node","/**\n * Copyright 2020 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\n/**\n * return a string representing the full type of the variable\n * @param {*} variable \n * @returns {String} - Object, Array, Number, String, Boolean, Null, Undefined, BigInt, Symbol, Date ...\n */\nexport function realtypeof(variable) {\n\tlet rawType = Object.prototype.toString.call(variable); //[object Object], [object Array], [object Number] ...\n\treturn rawType.substring(8, rawType.length - 1);\n}\n\n/**\n * check if variable is a number or a string of a number\n * @param {*} variable \n */\n/*export function isNumeric(variable) {\n\tif(typeof variable === 'string' && variable === '') return false;\n\telse return !isNaN(variable);\n}*/\n\n/**\n * recursively clones objects and array\n * @param {Proxy|Object|Array} proxy \n */\nlet simpleCloneSet = new WeakSet();\nexport function simpleClone(obj) {\n\tlet typeofobj = realtypeof(obj);\n\tlet cloned;\n\tif(typeofobj === 'Object') {\n\t\tsimpleCloneSet.add(obj);\n\t\tcloned = {};\n\t\tlet keys = Object.keys(obj);\n\t\tfor(let key of keys) {\n\t\t\tif(simpleCloneSet.has(obj[key])) {\n\t\t\t\tcloned[key] = obj[key];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcloned[key] = simpleClone(obj[key]);\n\t\t\t}\n\t\t}\n\t}\n\telse if(typeofobj === 'Array') {\n\t\tsimpleCloneSet.add(obj);\n\t\tcloned = [];\n\t\tfor(let i = 0; i < obj.length; i++) {\n\t\t\tif(simpleCloneSet.has(obj[i])) {\n\t\t\t\tcloned[i] = obj[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcloned[i] = simpleClone(obj[i]);\n\t\t\t}\n\t\t}\n\t}\n\telse { //hopefully a primitive\n\t\tcloned = obj;\n\n\t\tif(typeofobj !== 'Undefined' && typeofobj !== 'Null' && typeofobj !== 'Boolean' && typeofobj !== 'Number'\n\t\t&& typeofobj !== 'BigInt' && typeofobj !== 'String') {\n\t\t\tconsole.warn(`Can't clone a variable of type ${typeofobj}`);\n\t\t}\n\t}\n\n\treturn cloned;\n}\n\n/**\n * splits a path to an array of properties\n * (benchmarked and is faster than regex and split())\n * @param {String} path \n */\nexport function splitPath(path) {\n\tif(typeof path !== 'string' || path === '') {\n\t\treturn [];\n\t}\n\t\n\tlet i = 0, betweenBrackets = false, onlyDigits = false;\n\t//loop will skip over openning '.' or '['\n\tif(path[0] === '.') {\n\t\ti = 1;\n\t} else if(path[0] === '[') {\n\t\ti = 1;\n\t\tbetweenBrackets = true;\n\t\tonlyDigits = true;\n\t}\n\n\tlet resultsArr = [];\n\tlet tmp='';\n\tfor(; i < path.length; i++) {\n\t\tlet char = path[i];\n\n\t\tif(betweenBrackets) {\n\t\t\tif(char === ']') {\n\t\t\t\tif(onlyDigits) resultsArr.push(parseInt(tmp, 10));\n\t\t\t\telse resultsArr.push(tmp);\n\n\t\t\t\tbetweenBrackets = false;\n\t\t\t\tonlyDigits = false;\n\t\t\t\ttmp = '';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(onlyDigits) {\n\t\t\t\t\tlet code = char.charCodeAt(0);\n\t\t\t\t\tif(code < 48 || code > 57) { //less than '0' char or greater than '9' char\n\t\t\t\t\t\tonlyDigits = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp += char;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(char === '[') {\n\t\t\t\tbetweenBrackets = true;\n\t\t\t\tonlyDigits = true;\n\t\t\t}\n\t\t\t\n\t\t\t//check if starting a new property but avoid special case of [prop][prop]\n\t\t\tif(char === '.' || char === '[') {\n\t\t\t\tif(tmp !== '') {\n\t\t\t\t\tresultsArr.push(tmp);\n\t\t\t\t\ttmp = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttmp += char;\n\t\t\t}\n\t\t}\n\t}\n\tif(tmp!=='') {\n\t\tresultsArr.push(tmp);\n\t}\n\treturn resultsArr;\n}\n\n/**\n * evaluate a long path and return the designated object and its referred property\n * @param {Object} obj\n * @param {String} path\n * @returns {Object} - returns {object, property, value}\n */\nexport function evalPath(obj, path) {\n\tif(path === '') {\n\t\treturn { object: obj, property: undefined, value: obj };\n\t}\n\n\tlet segments = splitPath(path);\n\tlet i;\n\tfor(i = 0; i <= segments.length - 2; i++) { //iterate until one before last property because they all must exist\n\t\tobj = obj[segments[i]];\n\t\tif(typeof obj === 'undefined') {\n\t\t\tthrow new Error(`Invalid path was given - \"${path}\"`);\n\t\t}\n\t}\n\treturn { object: obj, property: segments[i], value: obj[ segments[i] ] };\n}","/**\n * Copyright 2021 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nimport { proxyTypes, ND, NID } from './global-vars.js';\nimport { realtypeof } from './general-functions.js';\n\n/**\n * Convert property name to valid path segment\n * @param {*} obj \n * @param {String} property \n */\nexport function property2path(obj, property) {\n\tif(typeof property === 'symbol') {\n\t\tthrow new Error(`property of type \"symbol\" isn't path'able`);\n\t}\n\n\tlet typeofobj = realtypeof(obj);\n\tswitch(typeofobj) {\n\t\tcase 'Object': return `.${property}`;\n\t\tcase 'Array': return `[${property}]`;\n\t\tdefault: console.warn(`Not Implemented (type of '${typeofobj}')`); return property;\n\t}\n}\n\n/**\n * recursively switch between all proxies to their original targets.\n * note: original targets should never hold proxies under them,\n * thus altering the object references (getting from 'value') should be ok.\n * if the programmer decided to\n * \t1. create a proxy with children (sub-proxies)\n * \t2. create a regular object\n * \t3. adding sub-proxies to the regular object\n * \t4. attaching the regular object to the proxy\n * then this regular object will be altered.\n * @param {*} value\n */\nexport function unproxify(value) {\n\tlet typeofvalue = realtypeof(value);\n\tif(proxyTypes.includes(typeofvalue)) {\n\t\tlet target = value;\n\t\ttry {\n\t\t\ttarget = value.$getOriginalTarget();\n\t\t} catch(error) {}\n\n\t\tswitch(typeofvalue) {\n\t\t\tcase 'Object':\n\t\t\t\tlet keys = Object.keys(target);\n\t\t\t\tfor(let key of keys) {\n\t\t\t\t\ttarget[key] = unproxify(target[key]); //maybe alters target and maybe returning the exact same object\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'Array':\n\t\t\t\tfor(let i=0; i < target.length; i++) {\n\t\t\t\t\ttarget[i] = unproxify(target[i]); //maybe alters target and maybe returning the exact same object\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.warn(`Not Implemented (type of '${typeofobj}')`);\n\t\t}\n\n\t\treturn target;\n\t}\n\telse {\n\t\treturn value; //primitive\n\t}\n}\n\n/**\n * create a node in a tree that mimics the proxserve's object and holds meta-data\n * @param {Object} parentNode \n * @param {String|Number} property \n */\nexport function createDataNode(parentNode, property) {\n\tlet propertyPath;\n\tif(parentNode[ND] && parentNode[ND].objects && parentNode[ND].objects.target) {\n\t\tpropertyPath = property2path(parentNode[ND].objects.target, property);\n\t} else {\n\t\tpropertyPath = property2path({}, property); //if parent doesn't have target then treat it as object\n\t}\n\t\n\tlet node = parentNode[property];\n\tif(!node) {\n\t\tnode = {\n\t\t\t[NID]: Object.create(parentNode[NID]),\n\t\t\t[ND]: {\n\t\t\t\t'parentNode': parentNode,\n\t\t\t\t'listeners': {\n\t\t\t\t\t'shallow': [],\n\t\t\t\t\t'deep': []\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tparentNode[property] = node;\n\t}\n\n\tdelete node[NID].status; //clears old status in case a node previously existed\n\t//updates path (for rare case where parent was array and then changed to object or vice versa)\n\t//and also makes a new and clean 'objects' property\n\tObject.assign(node[ND], {\n\t\t'path': parentNode[ND].path + propertyPath,\n\t\t'propertyPath': propertyPath,\n\t\t'objects': Object.assign(Object.create(parentNode[ND].objects), {\n\t\t\t'target': undefined,\n\t\t\t'proxy': undefined,\n\t\t\t'revoke': undefined\n\t\t})\n\t});\n\n\treturn node;\n}\n","/**\n * Copyright 2020 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nimport { eventNames, proxyStatuses, ND, NID } from './global-vars.js';\nimport { createDataNode } from './supporting-functions.js';\nimport { splitPath } from './general-functions.js';\n\n/**\n * stop object and children from emitting change events\n * @param {Object} dataNode\n */\nexport function stop(dataNode) {\n\tdataNode[NID].status = proxyStatuses[1];\n}\n\n/**\n * block object and children from any changes.\n * user can't set nor delete any property\n * @param {Object} dataNode\n */\nexport function block(dataNode) {\n\tdataNode[NID].status = proxyStatuses[2];\n}\n\n/**\n * resume default behavior of emitting change events, inherited from parent\n * @param {Object} dataNode\n * @param {Object} objects\n * @param {Boolean} [force] - force being active regardless of parent\n */\nexport function activate(dataNode, objects, force=false) {\n\tif(force || dataNode === this.dataTree) { //force activation or we are on root proxy\n\t\tdataNode[NID].status = proxyStatuses[0];\n\t}\n\telse {\n\t\tdelete dataNode[NID].status;\n\t}\n}\n\n/**\n * add event listener on a proxy or on a descending path\n * @param {Object} dataNode\n * @param {Object} objects\n * @param {String|Array.String} events\n * @param {String} [path] - path selector\n * @param {Function} listener \n * @param {String} [id] - identifier for removing this listener\n * @param {Boolean} [once] - whether this listener will run only once or always\n */\nexport function on(dataNode, objects, events, path, listener, id, once=false) {\n\tif(!Array.isArray(events)) events = [events];\n\n\tfor(let event of events) {\n\t\tif(!eventNames.includes(event)) {\n\t\t\tthrow new Error(`${event} is not a valid event. valid events are ${eventNames.join(',')}`);\n\t\t}\n\t}\n\t\n\tif(typeof path === 'function') { //if called without path\n\t\tid = listener;\n\t\tlistener = path;\n\t\tpath = '';\n\t} else if(typeof listener !== 'function') {\n\t\tthrow new Error(`invalid arguments were given. listener must be a function`);\n\t}\n\t\n\tlet segments = splitPath(path);\n\t//traverse down the tree. create data-nodes if needed\n\tfor(let property of segments) {\n\t\tif(!dataNode[property]) {\n\t\t\tcreateDataNode(dataNode, property);\n\t\t}\n\t\tdataNode = dataNode[property];\n\t}\n\n\tif(!dataNode[ND].listeners) {\n\t\tdataNode[ND].listeners = [];\n\t\tdataNode[ND].eventPool = [];\n\t}\n\tfor(let event of events) {\n\t\tdataNode[ND].listeners.push([event, listener, id, once]);\n\t}\n}\n\n/**\n * add event listener on a proxy or on a descending path which will run only once\n * @param {Object} dataNode\n * @param {Object} objects\n * @param {String|Array.String} events\n * @param {String} [path] - path selector\n * @param {Function} listener \n * @param {String} [id] - identifier for removing this listener\n */\nexport function once(dataNode, objects, events, path, listener, id) {\n\ton.call(this, dataNode, objects, events, path, listener, id, true);\n}\n\n/**\n * removes a listener from a path by an identifier (can have multiple listeners with the same ID)\n * or by the listener function itself\n * @param {Object} dataNode\n * @param {Object} objects\n * @param {String} [path] - path selector\n * @param {String} id - the listener(s) identifier or listener-function\n */\nexport function removeListener(dataNode, objects, path, id) {\n\tif(arguments.length === 3) { //if called without path\n\t\tid = path;\n\t\tpath = '';\n\t}\n\n\tlet fullPath = `${dataNode[ND].path}${path}`;\n\tlet segments = splitPath(path);\n\t//traverse down the tree\n\tfor(let property of segments) {\n\t\tif(!dataNode[property]) {\n\t\t\tconsole.warn(`can't remove listener from a non-existent path '${fullPath}'`);\n\t\t\treturn;\n\t\t}\n\t\tdataNode = dataNode[property];\n\t}\n\n\tif(dataNode[ND].listeners) {\n\t\tlet listeners = dataNode[ND].listeners;\n\t\n\t\tfor(let i = listeners.length - 1; i >= 0; i--) {\n\t\t\tif((typeof id !== 'function' && listeners[i][2] === id)\n\t\t\t|| (typeof id === 'function' && listeners[i][1] === id)) {\n\t\t\t\tlisteners.splice(i, 1);\n\t\t\t}\n\t\t}\n\n\t\tif(listeners.length === 0) {\n\t\t\tdelete dataNode[ND].listeners;\n\t\t\tdelete dataNode[ND].eventPool;\n\t\t}\n\t}\n}\n\n/**\n * removing all listeners of a path\n * @param {Object} dataNode\n * @param {Object} objects\n * @param {String} [path] - path selector\n */\nexport function removeAllListeners(dataNode, objects, path='') {\n\tlet fullPath = `${dataNode[ND].path}${path}`;\n\tlet segments = splitPath(path);\n\t//traverse down the tree\n\tfor(let property of segments) {\n\t\tif(!dataNode[property]) {\n\t\t\tconsole.warn(`can't remove all listeners from a non-existent path '${fullPath}'`);\n\t\t\treturn;\n\t\t}\n\t\tdataNode = dataNode[property];\n\t}\n\n\tif(dataNode[ND].listeners) {\n\t\tdelete dataNode[ND].listeners;\n\t\tdelete dataNode[ND].eventPool;\n\t}\n}\n\n/**\n * the following functions (getOriginalTarget, getProxserveObjects, getProxserveDataNode, getProxserveInstance) seem silly\n * because they could have been written directly on the handler's get() method but it's here as part of the convention of\n * exposing proxy-\"inherited\"-methods\n */\n/**\n * get original target that is behind the proxy\n * @param {Object} dataNode\n * @param {Object} objects\n */\nexport function getOriginalTarget(dataNode, objects) {\n\treturn objects.target;\n}\n\n/**\n * get 'objects' (which holds all related objects) of a proxy\n * @param {Object} dataNode\n * @param {Object} objects\n */\nexport function getProxserveObjects(dataNode, objects) {\n\treturn objects;\n}\n\n/**\n * get the data-node of the proxy or sub-proxy\n * @param {Object} dataNode\n */\nexport function getProxserveDataNode(dataNode) {\n\treturn dataNode;\n}\n\n/**\n * get the Proxserve's instance that created this proxy\n */\nexport function getProxserveInstance() {\n\treturn this;\n}\n\n/**\n * a wrapper function for the 'splice' method\n * @param {Array} target - the target array behind the proxy\n * @param {Object} dataNode \n * @param {Number} start \n * @param {Number} deleteCount \n * @param  {...any} items \n */\nexport function splice(dataNode, objects, start, deleteCount, ...items) {\n\tif(dataNode[NID].status !== proxyStatuses[0]) { //not 'active'\n\t\treturn Array.prototype.splice.call(objects.proxy, start, deleteCount, ...items);\n\t}\n\n\tdataNode[NID].status = proxyStatuses[3]; //'splicing'\n\tlet oldValue = objects.target.slice(0);\n\tlet deleted = Array.prototype.splice.call(objects.proxy, start, deleteCount, ...items);\n\tdataNode[NID].status = proxyStatuses[0];\n\n\treturn deleted;\n}\n","/**\n * Copyright 2020 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nimport { proxyTypes, proxyStatuses, add2emitQueue_bubble, unproxify, createDataNode } from './supporting-functions.js';\nimport * as reservedMethods from './reserved-methods.js';\nimport { realtypeof, simpleClone, splitPath, evalPath } from './general-functions.js';\n\nlet ND = Symbol.for('proxserve_node_data'); //key for the data of a node\nlet NID = Symbol.for('proxserve_node_inherited_data'); //key for the inherited data of a node\n\n/**\n * save an array of all reserved function names\n * and also add synonyms to these functions\n */\nlet reservedMethodsNames = Object.keys(reservedMethods);\nfor(let i = reservedMethodsNames.length - 1; i >= 0; i--) {\n\tlet name = reservedMethodsNames[i];\n\tlet synonym = '$'+name;\n\treservedMethods[synonym] = reservedMethods[name];\n\treservedMethodsNames.push(synonym);\n}\n\nclass Proxserve {\n\t/**\n\t * construct a new proxserve instance\n\t * @param {Object|Array} target \n\t * @param {Object} [options]\n\t * \t@property {Boolean} [options.strict] - should destroy detached child-objects or deleted properties automatically\n\t * \t@property {Boolean} [options.emitReference] - events emit new/old values. true: reference to original objects, false: deep clones that are created on the spot\n\t * \t@property {Boolean} [options.emitSplice] - should splice emit one 'splice' event or all CRUD events\n\t */\n\tconstructor(target, { strict=true, emitReference=false, emitSplice=true } = {}) {\n\t\tthis.strict = strict;\n\t\tthis.emitReference = emitReference;\n\t\tthis.emitSplice = emitSplice;\n\n\t\tthis.dataTree = createDataNode({\n\t\t\t[NID]: { 'status': proxyStatuses[0] },\n\t\t\t[ND]: { 'objects': { 'isDeleted': false } },\n\t\t\t'isTreePrototype': true\n\t\t}, '');\n\t\tthis.dataTree[ND].path = '';\n\t\tthis.dataTree[ND].propertyPath = '';\n\t\tthis.dataTree[ND].objects.target = target;\n\n\t\treturn this.createProxy(this.dataTree);\n\t}\n\n\t/**\n\t * create a new proxy and a new node for a property of the parent's target-object\n\t * @param {Object} parentNode\n\t * @param {String} [targetProperty]\n\t */\n\tcreateProxy(parentNode, targetProperty) {\n\t\tlet dataNode;\n\n\t\tif(targetProperty === undefined) { //refering to own node and not a child property (meaning root object)\n\t\t\tdataNode = parentNode;\n\t\t}\n\t\telse {\n\t\t\tdataNode = createDataNode(parentNode, targetProperty); //either creates new or returns an existing one with cleaned properties\n\t\t\tdataNode[ND].objects.target = parentNode[ND].objects.target[ targetProperty ]; //assign said 'target' to the dataNode\n\t\t}\n\n\t\tlet objects = dataNode[ND].objects; //a new one for every iteration\n\t\tlet target = objects.target;\n\n\t\tlet typeoftarget = realtypeof(target);\n\n\t\tif(proxyTypes.includes(typeoftarget)) {\n\t\t\tlet revocable = Proxy.revocable(target, {\n\t\t\t\tget: (target/*same as parent scope 'target'*/, property, proxy) => {\n\t\t\t\t\t//can access a function (or its synonym) if their keywords isn't used\n\t\t\t\t\tif(reservedMethodsNames.includes(property)\n\t\t\t\t\t&& (typeof target[property] === 'undefined' || (property === 'splice' && Array.isArray(target)))) {\n\t\t\t\t\t\treturn reservedMethods[property].bind(this, dataNode, objects);\n\t\t\t\t\t}\n\t\t\t\t\telse if(!target.propertyIsEnumerable(property) || typeof property === 'symbol') {\n\t\t\t\t\t\treturn target[property]; //non-enumerable or non-path'able aren't proxied\n\t\t\t\t\t}\n\t\t\t\t\telse if(dataNode[property] //there's a child node\n\t\t\t\t\t\t\t&& dataNode[property][ND].objects.proxy //it holds a proxy\n\t\t\t\t\t\t\t&& Object.getPrototypeOf(dataNode[property][ND].objects) === objects) { //is child of this proxy, and not a ghost object left there after deletion\n\t\t\t\t\t\treturn dataNode[property][ND].objects.proxy;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn target[property];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\n\t\t\t\tset: (target/*same as parent scope 'target'*/, property, value, proxy) => { //'receiver' is proxy\n\t\t\t\t\t/**\n\t\t\t\t\t * property can be a regular object because of 3 possible reasons:\n\t\t\t\t\t * 1. proxy is deleted from tree but user keeps accessing it then it means he saved a reference\n\t\t\t\t\t * 2. it is a non-enumerable property which means it was intentionally hidden\n\t\t\t\t\t * 3. property is a symbol and symbols can't be proxied because we can't create a normal path for them.\n\t\t\t\t\t *    these properties are not proxied and should not emit change-event.\n\t\t\t\t\t *    except for: length\n\t\t\t\t\t * TODO - make a list of all possible properties exceptions (maybe function 'name'?)\n\t\t\t\t\t */\n\t\t\t\t\tif(dataNode[NID].status === proxyStatuses[2]) { //blocked from changing values\n\t\t\t\t\t\tconsole.error(`can't change value of property '${property}'. object is blocked.`);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(typeof property === 'symbol') {\n\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(property !== 'length' && !target.propertyIsEnumerable(property)) {\n\t\t\t\t\t\t//if setting a whole new property then it is non-enumerable (yet) so a further test is needed\n\t\t\t\t\t\tlet descriptor = Object.getOwnPropertyDescriptor(target, property);\n\t\t\t\t\t\tif(typeof descriptor === 'object' && descriptor.enumerable === false) { //property was previously set\n\t\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet oldValue;\n\t\t\t\t\tlet emitOldValue = target[property]; //should not be proxy\n\t\t\t\t\tlet shouldDestroy = false;\n\t\t\t\t\tif(dataNode[property] !== undefined && dataNode[property][ND].objects.proxy !== undefined) {\n\t\t\t\t\t\t//about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\toldValue = dataNode[property][ND].objects.proxy; //the sub-proxy\n\t\t\t\t\t\tdataNode[property][ND].objects.isDeleted = true;\n\t\t\t\t\t\tif(this.strict) {\n\t\t\t\t\t\t\tshouldDestroy = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue = unproxify(value);\n\t\t\t\t\ttarget[property] = value; //assign new value\n\n\t\t\t\t\tlet emitValue = value; //currently not a proxy but this might change later\n\t\t\t\t\tlet isValueProxy = false;\n\t\t\t\t\tlet typeofvalue = realtypeof(value);\n\t\t\t\t\tif(proxyTypes.includes(typeofvalue)) {\n\t\t\t\t\t\tthis.createProxy(dataNode, property); //if trying to add a new value which is an object then make it a proxy\n\t\t\t\t\t\temitValue = dataNode[property][ND].objects.proxy; //is a proxy\n\t\t\t\t\t\tisValueProxy = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!this.emitReference) { //deep copy with no proxies inside\n\t\t\t\t\t\temitValue = simpleClone(emitValue);\n\t\t\t\t\t\temitOldValue = simpleClone(emitOldValue);\n\t\t\t\t\t}\n\n\t\t\t\t\t//add2emitQueue_bubble(dataNode, property, emitOldValue, oldValue!==undefined, emitValue, isValueProxy);\n\t\t\t\t\tlet isOldValueProxy = oldValue !== undefined;\n\t\t\t\t\temitEvent(dataNode, property, emitOldValue, isOldValueProxy, emitValue, isValueProxy);\n\t\t\t\t\tif(shouldDestroy) {\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\tProxserve.destroy(oldValue);\n\t\t\t\t\t\t}, 1000); //postpone this cpu intense function for later, probably when proxserve is not in use\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\t/**\n\t\t\t\t * TODO - this function is incomplete and doesn't handle all of 'descriptor' scenarios\n\t\t\t\t */\n\t\t\t\tdefineProperty: (target/*same as parent scope 'target'*/, property, descriptor) => {\n\t\t\t\t\tif(typeof property === 'symbol') {\n\t\t\t\t\t\tObject.defineProperty(target, property, descriptor);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet oldValue;\n\t\t\t\t\tlet emitOldValue = target[property]; //should not be proxy\n\t\t\t\t\tlet shouldDestroy = false;\n\t\t\t\t\tif(dataNode[property] !== undefined && dataNode[property][ND].objects.proxy !== undefined) {\n\t\t\t\t\t\t//about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\toldValue = dataNode[property][ND].objects.proxy; //the sub-proxy\n\t\t\t\t\t\tdataNode[property][ND].objects.isDeleted = true;\n\t\t\t\t\t\tif(this.strict) {\n\t\t\t\t\t\t\tshouldDestroy = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdescriptor.value = unproxify(descriptor.value);\n\t\t\t\t\tObject.defineProperty(target, property, descriptor); //defining the new value\n\t\t\t\t\tlet value = descriptor.value;\n\t\t\t\t\tlet emitValue = value; //currently not a proxy but this might change later\n\n\t\t\t\t\tlet isValueProxy = false;\n\t\t\t\t\t//excluding non-enumerable properties from being proxied\n\t\t\t\t\tlet typeofvalue = realtypeof(descriptor.value);\n\t\t\t\t\tif(proxyTypes.includes(typeofvalue) && descriptor.enumerable === true) {\n\t\t\t\t\t\tthis.createProxy(dataNode, property); //if trying to add a new value which is an object then make it a proxy\n\n\t\t\t\t\t\tvalue = dataNode[property][ND].objects.proxy; //value is now the proxy, not the target\n\t\t\t\t\t\tisValueProxy = true;\n\t\t\t\t\t\temitValue = value; //is a proxy\n\t\t\t\t\t\tif(!this.emitReference) {\n\t\t\t\t\t\t\temitValue = simpleClone(emitValue);\n\t\t\t\t\t\t\temitOldValue = simpleClone(emitOldValue); //deep copy with no proxies inside\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tadd2emitQueue_bubble(dataNode, property, emitOldValue, oldValue!==undefined, emitValue, isValueProxy);\n\t\t\t\t\tif(shouldDestroy) {\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\tProxserve.destroy(oldValue);\n\t\t\t\t\t\t}, 1000); //postpone this cpu intense function for later, probably when proxserve is not is use\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\tdeleteProperty: (target/*same as parent scope 'target'*/, property) => {\n\t\t\t\t\tif(!target.propertyIsEnumerable(property) || typeof property === 'symbol') {\n\t\t\t\t\t\t//non-proxied properties simply get deleted and nothing more\n\t\t\t\t\t\tdelete target[property];\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dataNode[NID].status === proxyStatuses[2]) { //blocked from changing values\n\t\t\t\t\t\tconsole.error(`can't delete property '${property}'. object is blocked.`);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(property in target) {\n\t\t\t\t\t\tlet oldValue;\n\t\t\t\t\t\tlet emitOldValue = target[property]; //should not be proxy\n\t\t\t\t\t\tif(!this.emitReference) {\n\t\t\t\t\t\t\temitOldValue = simpleClone(emitOldValue); //deep copy with no proxies inside\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet shouldDestroy = false;\n\t\t\t\t\t\tif(dataNode[property] !== undefined && dataNode[property][ND].objects.proxy !== undefined) {\n\t\t\t\t\t\t\t//about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\t\toldValue = dataNode[property][ND].objects.proxy; //the sub-proxy\n\t\t\t\t\t\t\tdataNode[property][ND].objects.isDeleted = true;\n\t\t\t\t\t\t\tif(this.strict) {\n\t\t\t\t\t\t\t\tshouldDestroy = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete target[property]; //actual delete\n\n\t\t\t\t\t\tadd2emitQueue_bubble(dataNode, property, emitOldValue, oldValue!==undefined, undefined, false);\n\t\t\t\t\t\tif(shouldDestroy) {\n\t\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\t\tProxserve.destroy(oldValue);\n\t\t\t\t\t\t\t}, 1000); //postpone this cpu intense function for later, probably when proxserve is not is use\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn true; //do nothing because there's nothing to delete\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tdataNode[ND].objects.proxy = revocable.proxy;\n\t\t\tdataNode[ND].objects.revoke = revocable.revoke;\n\n\t\t\tif(typeoftarget === 'Object') {\n\t\t\t\tlet keys = Object.keys(target);\n\t\t\t\tfor(let key of keys) {\n\t\t\t\t\tlet typeofproperty = realtypeof(target[key]);\n\t\t\t\t\tif(proxyTypes.includes(typeofproperty)) {\n\t\t\t\t\t\tthis.createProxy(dataNode, key); //recursively make child objects also proxies\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(typeoftarget === 'Array') {\n\t\t\t\tfor(let i = 0; i < target.length; i++) {\n\t\t\t\t\tlet typeofproperty = realtypeof(target[i]);\n\t\t\t\t\tif(proxyTypes.includes(typeofproperty)) {\n\t\t\t\t\t\tthis.createProxy(dataNode, i); //recursively make child objects also proxies\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconsole.warn('Not Implemented');\n\t\t\t}\n\n\t\t\treturn revocable.proxy;\n\t\t}\n\t\telse {\n\t\t\tthrow new Error('Must observe an '+proxyTypes.join('/'));\n\t\t}\n\t}\n\n\t/**\n\t * Recursively revoke proxies, allowing them to be garbage collected.\n\t * this functions delays 1000 milliseconds to let time for all events to finish\n\t * @param {*} proxy \n\t */\n\tstatic destroy(proxy) {\n\t\tlet objects;\n\t\ttry {\n\t\t\tobjects = proxy.$getProxserveObjects();\n\t\t} catch(error) {\n\t\t\treturn; //proxy variable isn't a proxy\n\t\t}\n\n\t\tif(!objects.isDeleted) {\n\t\t\tobjects.isDeleted = true;\n\t\t}\n\n\t\tlet typeofproxy = realtypeof(proxy);\n\n\t\tif(proxyTypes.includes(typeofproxy)) {\n\t\t\tif(typeofproxy === 'Object') {\n\t\t\t\tlet keys = Object.keys(proxy);\n\t\t\t\tfor(let key of keys) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet typeofproperty = realtypeof(proxy[key]);\n\t\t\t\t\t\tif(proxyTypes.includes(typeofproperty)) {\n\t\t\t\t\t\t\tProxserve.destroy(proxy[key]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(error) {\n\t\t\t\t\t\tconsole.error(error); //don't throw and kill the whole process just if this iteration fails\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(typeofproxy === 'Array') {\n\t\t\t\tfor(let i = proxy.length - 1; i >= 0; i--) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet typeofproperty = realtypeof(proxy[i]);\n\t\t\t\t\t\tif(proxyTypes.includes(typeofproperty)) {\n\t\t\t\t\t\t\tProxserve.destroy(proxy[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(error) {\n\t\t\t\t\t\tconsole.error(error); //don't throw and kill the whole process just if this iteration fails\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconsole.warn('Not Implemented');\n\t\t\t}\n\n\t\t\tobjects.revoke();\n\t\t\tobjects.proxy = undefined;\n\t\t}\n\t}\n\n\tstatic splitPath(path) {\n\t\treturn splitPath(path);\n\t}\n\n\tstatic evalPath(obj, path) {\n\t\treturn evalPath(obj, path);\n\t}\n}\n\nmodule.exports = exports = Proxserve; //makes ParcelJS expose this globally (for all platforms) after bundling everything"]}