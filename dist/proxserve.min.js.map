{"version":3,"sources":["global-vars.js","general-functions.js","supporting-functions.js","pseudo-methods.js","event-emitter.js","proxy-methods.js","index.js"],"names":["proxyTypes","OBJECT","ARRAY","nodeStatuses","ACTIVE","STOPPED","BLOCKED","SPLICING","proxyStatuses","ALIVE","DELETED","REVOKED","eventNames","CREATE","UPDATE","DELETE","SPLICE","SHIFT","UNSHIFT","ND","Symbol","for","NID","realtypeof","variable","rawType","Object","prototype","toString","call","substring","length","simpleCloneSet","WeakSet","simpleClone","obj","typeofobj","cloned","add","keys","key","has","i","console","warn","splitPath","path","betweenBrackets","onlyDigits","resultsArr","tmp","char","push","parseInt","code","charCodeAt","evalPath","object","property","undefined","value","segments","Error","property2path","unproxify","typeofvalue","includes","target","$getOriginalTarget","error","createDataNode","parentNode","propertyPath","objects","node","create","status","assign","stop","dataNode","block","activate","force","dataTree","on","events","listener","deep","id","once","slice","Array","isArray","event","join","listenersPool","listeners","shallow","listenerObj","type","func","options","removeListener","arguments","fullPath","removeById","listenersArr","splice","removeAllListeners","getOriginalTarget","getProxserveObjects","getProxserveDataNode","getProxserveInstance","initEmitEvent","oldValue","wasOldValueProxy","isValueProxy","changeType","deferredEvents","change","shouldCapture","bubbleEmit","captureEmit","initFunctionEmitEvent","funcName","funcArgs","iterateAndEmit","proxy","isTreePrototype","nextChange","subValue","subOldValue","subChange","thisValue","start","deleteCount","items","isActiveByInheritance","hasOwnProperty","deleted","args","shift","unshift","newLength","pseudoMethodsNames","pseudoMethods","name","synonym","Proxserve","constructor","strict","emitMethods","debug","destroyDelay","createProxy","targetProperty","typeoftarget","revocable","Proxy","get","proxyMethods","getPrototypeOf","bind","propertyIsEnumerable","set","descriptor","getOwnPropertyDescriptor","enumerable","isOldValueProxy","setTimeout","destroy","defineProperty","deleteProperty","revoke","typeofproperty","$getProxserveDataNode","$getProxserveObjects","typeofproxy","module","exports"],"mappings":";AAOA,aA0BuD,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,IAAA,QAAA,GAAA,QAAA,WAAA,QAAA,cAAA,QAAA,aAAA,QAAA,gBAAA,EAxBvD,IAAIA,EAAa,CAAC,SAAU,SAwB2B,QAAA,WAAA,EAvBvDA,EAAWC,OAASD,EAAW,GAC/BA,EAAWE,MAAQF,EAAW,GAE9B,IAAIG,EAAe,CAAC,SAAU,UAAW,UAAW,YAoBG,QAAA,aAAA,EAnBvDA,EAAaC,OAASD,EAAa,GACnCA,EAAaE,QAAUF,EAAa,GACpCA,EAAaG,QAAUH,EAAa,GACpCA,EAAaI,SAAWJ,EAAa,GAErC,IAAIK,EAAgB,CAAC,QAAS,UAAW,WAcc,QAAA,cAAA,EAbvDA,EAAcC,MAAQD,EAAc,GACpCA,EAAcE,QAAUF,EAAc,GACtCA,EAAcG,QAAUH,EAAc,GAEtC,IAAII,EAAa,CAAC,SAAU,SAAU,SAAU,SAAU,QAAS,WASZ,QAAA,WAAA,EARvDA,EAAWC,OAASD,EAAW,GAC/BA,EAAWE,OAASF,EAAW,GAC/BA,EAAWG,OAASH,EAAW,GAC/BA,EAAWI,OAASJ,EAAW,GAC/BA,EAAWK,MAAQL,EAAW,GAC9BA,EAAWM,QAAUN,EAAW,GAEhC,IAAIO,EAAKC,OAAOC,IAAI,uBACmC,QAAA,GAAA,EAAvD,IAAIC,EAAMF,OAAOC,IAAI,iCAAkC,QAAA,IAAA;;AC1BvD,aAOO,SAASE,EAAWC,GACtBC,IAAAA,EAAUC,OAAOC,UAAUC,SAASC,KAAKL,GACtCC,OAAAA,EAAQK,UAAU,EAAGL,EAAQM,OAAS,GAiJ7C,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,WAAA,EAAA,QAAA,YAAA,EAAA,QAAA,UAAA,EAAA,QAAA,SAAA,EAjID,IAAIC,EAAiB,IAAIC,QAClB,SAASC,EAAYC,GACvBC,IACAC,EADAD,EAAYb,EAAWY,GAExBC,GAAc,WAAdA,EAAwB,CAC1BJ,EAAeM,IAAIH,GACnBE,EAAS,GACLE,IAAAA,EAAOb,OAAOa,KAAKJ,GACnB,IAAA,IAAIK,KAAOD,EACXP,EAAeS,IAAIN,EAAIK,IACzBH,EAAOG,GAAOL,EAAIK,GAGlBH,EAAOG,GAAON,EAAYC,EAAIK,SAI5B,GAAiB,UAAdJ,EAAuB,CAC9BJ,EAAeM,IAAIH,GACnBE,EAAS,GACL,IAAA,IAAIK,EAAI,EAAGA,EAAIP,EAAIJ,OAAQW,IAC3BV,EAAeS,IAAIN,EAAIO,IACzBL,EAAOK,GAAKP,EAAIO,GAGhBL,EAAOK,GAAKR,EAAYC,EAAIO,SAK9BL,EAASF,EAEQ,cAAdC,GAA2C,SAAdA,GAAsC,YAAdA,GAAyC,WAAdA,GAClE,WAAdA,GAAwC,WAAdA,GAC5BO,QAAQC,uCAAuCR,KAI1CC,OAAAA,EAQD,SAASQ,EAAUC,GACtB,GAAgB,iBAATA,GAA8B,KAATA,EACvB,MAAA,GAGJJ,IAAAA,EAAI,EAAGK,GAAkB,EAAOC,GAAa,EAElC,MAAZF,EAAK,GACPJ,EAAI,EACiB,MAAZI,EAAK,KACdJ,EAAI,EACJK,GAAkB,EAClBC,GAAa,GAGVC,IAAAA,EAAa,GACbC,EAAI,GACFR,KAAAA,EAAII,EAAKf,OAAQW,IAAK,CACvBS,IAAAA,EAAOL,EAAKJ,GAEbK,GAAAA,EACCI,GAAS,MAATA,EACCH,EAAYC,EAAWG,KAAKC,SAASH,EAAK,KACxCD,EAAWG,KAAKF,GAErBH,GAAkB,EAClBC,GAAa,EACbE,EAAM,OAEF,CACDF,GAAAA,EAAY,CACVM,IAAAA,EAAOH,EAAKI,WAAW,IACxBD,EAAO,IAAMA,EAAO,MACtBN,GAAa,GAGfE,GAAOC,MAII,MAATA,IACFJ,GAAkB,EAClBC,GAAa,GAIF,MAATG,GAAyB,MAATA,EACP,KAARD,IACFD,EAAWG,KAAKF,GAChBA,EAAM,IAIPA,GAAOC,EAOHF,MAHE,KAANC,GACFD,EAAWG,KAAKF,GAEVD,EASD,SAASO,EAASrB,EAAKW,GAC1BA,GAAS,KAATA,EACK,MAAA,CAAEW,OAAQtB,EAAKuB,cAAUC,EAAWC,MAAOzB,GAG/C0B,IACAnB,EADAmB,EAAWhB,EAAUC,GAErBJ,IAAAA,EAAI,EAAGA,GAAKmB,EAAS9B,OAAS,EAAGW,IAEjC,QAAe,KADlBP,EAAMA,EAAI0B,EAASnB,KAEZ,MAAA,IAAIoB,mCAAmChB,MAGxC,MAAA,CAAEW,OAAQtB,EAAKuB,SAAUG,EAASnB,GAAIkB,MAAOzB,EAAK0B,EAASnB;;ACzJnE,aA6GC,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,cAAA,EAAA,QAAA,UAAA,EAAA,QAAA,eAAA,EA3GD,IAAA,EAAA,QAAA,oBACA,EAAA,QAAA,0BAOO,SAASqB,EAAc5B,EAAKuB,GAC/B,GAAoB,iBAAbA,EACH,MAAA,IAAII,MAAO,+CAGd1B,IAAAA,GAAY,EAAWD,EAAAA,YAAAA,GACpBC,OAAAA,GACD,IAAA,SAAkB,UAAGsB,IACrB,IAAA,QAAiB,UAAGA,KACzB,QAA0EA,OAAjEf,QAAQC,kCAAkCR,OAAuBsB,GAgBrE,SAASM,EAAUJ,GACrBK,IAAAA,GAAc,EAAWL,EAAAA,YAAAA,GAC1B5D,GAAAA,EAAWkE,WAAAA,SAASD,GAAc,CAChCE,IAAAA,EAASP,EACT,IACHO,EAASP,EAAMQ,qBACd,MAAMC,IAEDJ,OAAAA,GACD,IAAA,SACA1B,IAAAA,EAAOb,OAAOa,KAAK4B,GACnB,IAAA,IAAI3B,KAAOD,EACd4B,EAAO3B,GAAOwB,EAAUG,EAAO3B,IAEhC,MACI,IAAA,QACA,IAAA,IAAIE,EAAE,EAAGA,EAAIyB,EAAOpC,OAAQW,IAC/ByB,EAAOzB,GAAKsB,EAAUG,EAAOzB,IAE9B,MACD,QACCC,QAAQC,kCAAkCR,eAGrC+B,OAAAA,EAGAP,OAAAA,EASF,SAASU,EAAeC,EAAYb,GACtCc,IAAAA,EAEHA,EADED,EAAWpD,EAAD,KAAQoD,EAAWpD,EAAD,IAAKsD,SAAWF,EAAWpD,EAAD,IAAKsD,QAAQN,OACtDJ,EAAcQ,EAAWpD,EAAD,IAAKsD,QAAQN,OAAQT,GAE7CK,EAAc,GAAIL,GAG9BgB,IAAAA,EAAOH,EAAWb,GA6BfgB,OA5BHA,IACHA,EAAO,CACLpD,CAAAA,EAAD,KAAOI,OAAOiD,OAAOJ,EAAWjD,EAAD,MAC9BH,CAAAA,EAAD,IAAM,CACSoD,WAAAA,EACD,UAAA,CACD,QAAA,GACH,KAAA,MAIXA,EAAWb,GAAYgB,UAGjBA,EAAKpD,EAAD,KAAMsD,OAGjBlD,OAAOmD,OAAOH,EAAKvD,EAAD,IAAM,CACfoD,KAAAA,EAAWpD,EAAD,IAAK2B,KAAO0B,EACdA,aAAAA,EACL9C,QAAAA,OAAOmD,OAAOnD,OAAOiD,OAAOJ,EAAWpD,EAAD,IAAKsD,SAAU,CACrDd,YAAAA,EACDA,WAAAA,EACCA,YAAAA,MAKLe;;ACxGR,aA8MC,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,KAAA,EAAA,QAAA,MAAA,EAAA,QAAA,SAAA,EAAA,QAAA,GAAA,EAAA,QAAA,KAAA,EAAA,QAAA,eAAA,EAAA,QAAA,mBAAA,EAAA,QAAA,kBAAA,EAAA,QAAA,oBAAA,EAAA,QAAA,qBAAA,EAAA,QAAA,qBAAA,EA5MD,IAAA,EAAA,QAAA,oBACA,EAAA,QAAA,6BACA,EAAA,QAAA,0BAMO,SAASI,EAAKC,GACpBA,EAASzD,EAAD,KAAMsD,OAASzE,EAAaE,aAAAA,QAQ9B,SAAS2E,EAAMD,GACrBA,EAASzD,EAAD,KAAMsD,OAASzE,EAAaG,aAAAA,QAS9B,SAAS2E,EAASF,EAAUN,EAASS,GAAM,GAC9CA,GAASH,IAAa,KAAKI,SAC7BJ,EAASzD,EAAD,KAAMsD,OAASzE,EAAaC,aAAAA,cAG7B2E,EAASzD,EAAD,KAAMsD,OAgBhB,SAASQ,EAAGL,EAAUN,EAASY,EAAQvC,EAAMwC,GAAU,KAACC,GAAK,EAAN,GAAaC,EAAb,KAA2BC,GAAK,GAAS,IACxF,WAAXJ,EAAqBA,EAASzE,EAAW8E,WAAAA,MAAM,GACzCC,MAAMC,QAAQP,KAASA,EAAS,CAACA,IAEtC,IAAA,IAAIQ,KAASR,EACb,IAACzE,EAAWsD,WAAAA,SAAS2B,GACjB,MAAA,IAAI/B,SAAS+B,4CAAgDjF,EAAWkF,WAAAA,KAAK,QAIlF,GAAgB,mBAAThD,EACc,iBAAbwC,IACmB,kBAAlBA,EAASC,OAAoBA,EAAOD,EAASC,WACpC5B,IAAhB2B,EAASE,KAAkBA,EAAKF,EAASE,IAChB,kBAAlBF,EAASG,OAAoBA,EAAOH,EAASG,OAExDH,EAAWxC,EACXA,EAAO,QACD,GAAuB,mBAAbwC,EACV,MAAA,IAAIxB,MAAO,6DAGdD,IAAAA,GAAW,EAAUf,EAAAA,WAAAA,GAErB,IAAA,IAAIY,KAAYG,EACfkB,EAASrB,KACGqB,EAAAA,EAAAA,gBAAAA,EAAUrB,GAE1BqB,EAAWA,EAASrB,GAGjBqC,IAAAA,EAAgBhB,EAAS5D,EAAD,IAAK6E,UAAUC,QACxCV,IAAMQ,EAAgBhB,EAAS5D,EAAD,IAAK6E,UAAUT,MAE5CW,IAAAA,EAAc,CACjBC,KAAMd,EACNI,KAAMA,EACNW,KAAMd,QAEG3B,IAAP6B,IACFU,EAAYV,GAAKA,GAElBO,EAAc3C,KAAK8C,GAYb,SAAST,EAAKV,EAAUN,EAASY,EAAQvC,EAAMwC,EAAUe,GACzC,iBAAZA,IAAsBA,EAAU,IAC1CA,EAAQZ,MAAO,EACfL,EAAGvD,KAAK,KAAMkD,EAAUN,EAASY,EAAQvC,EAAMwC,EAAUe,GAWnD,SAASC,EAAevB,EAAUN,EAAS3B,EAAM0C,GAC/B,IAArBe,UAAUxE,SACZyD,EAAK1C,EACLA,EAAO,IAGJ0D,IAAAA,KAAczB,EAAS5D,EAAD,IAAK2B,OAAOA,IAClCe,GAAW,EAAUf,EAAAA,WAAAA,GAErB,IAAA,IAAIY,KAAYG,EAAU,CAC1B,IAACkB,EAASrB,GAEZ,YADAf,QAAQC,wDAAwD4D,MAGjEzB,EAAWA,EAASrB,GAGZ+C,SAAAA,EAAWC,EAAclB,GAC7B,IAAA,IAAI9C,EAAIgE,EAAa3E,OAAS,EAAGW,GAAK,EAAGA,IAAK,CAC7CwD,IAAAA,EAAcQ,EAAahE,SACpBiB,IAAP6B,GAAoBU,EAAYV,KAAOA,GAAOU,EAAYE,OAASZ,IACtEkB,EAAaC,OAAOjE,EAAG,IAK1B+D,EAAW1B,EAAS5D,EAAD,IAAK6E,UAAUC,QAAST,GAC3CiB,EAAW1B,EAAS5D,EAAD,IAAK6E,UAAUT,KAAMC,GASlC,SAASoB,EAAmB7B,EAAUN,EAAS3B,EAAK,IACtD0D,IAAAA,KAAczB,EAAS5D,EAAD,IAAK2B,OAAOA,IAClCe,GAAW,EAAUf,EAAAA,WAAAA,GAErB,IAAA,IAAIY,KAAYG,EAAU,CAC1B,IAACkB,EAASrB,GAEZ,YADAf,QAAQC,6DAA6D4D,MAGtEzB,EAAWA,EAASrB,GAGrBqB,EAAS5D,EAAD,IAAK6E,UAAUC,QAAU,GACjClB,EAAS5D,EAAD,IAAK6E,UAAUT,KAAO,GAaxB,SAASsB,EAAkB9B,EAAUN,GACpCA,OAAAA,EAAQN,OAQT,SAAS2C,EAAoB/B,EAAUN,GACtCA,OAAAA,EAOD,SAASsC,EAAqBhC,GAC7BA,OAAAA,EAMD,SAASiC,IACR,OAAA;;ACjNR,aAkLC,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,cAAA,EAAA,QAAA,sBAAA,EAhLD,IAAA,EAAA,QAAA,oBACA,EAAA,QAAA,6BAWO,SAASC,EAAclC,EAAUrB,EAAUwD,EAAUC,EAAkBvD,EAAOwD,GACjFF,GAAAA,IAAatD,GACbmB,EAAS5D,EAAD,IAAKsD,QAAQG,SAAWpE,EAAcC,cAAAA,MAChD,OAGG4G,IAIAC,EASAxE,EAbAuE,EAAazG,EAAWE,WAAAA,YACf6C,IAAVC,EAAqByD,EAAazG,EAAWG,WAAAA,YAC3B4C,IAAbuD,IAAwBG,EAAazG,EAAWC,WAAAA,QAIrDkE,EAASzD,EAAD,KAAMsD,SAAWzE,EAAaI,aAAAA,WAEpCwE,EAAS5D,EAAD,IAAKmG,iBAAgBvC,EAAS5D,EAAD,IAAKmG,eAAiB,IAE/DA,EAAiBvC,EAAS5D,EAAD,IAAKmG,gBAI5BvC,EAASrB,IACXqB,EAAWA,EAASrB,GACpBZ,EAAO,IAEPA,GAAO,EAAciC,EAAAA,eAAAA,EAAS5D,EAAD,IAAKsD,QAAQN,OAAQT,GAG/C6D,IAAAA,EAAS,CACJzE,KAAAA,EAAec,MAAAA,EAAmBsD,SAAAA,EAAkBG,KAAAA,GAGzDC,EAQHA,EAAelE,KAAK,CAAC2B,SAAAA,EAAUwC,OAAAA,EAAQC,cAAeL,GAAoBC,KAP1EK,EAAW1C,EAAUwC,IAElBJ,GAAoBC,IACtBM,EAAY3C,EAAUwC,IAgBlB,SAASI,EAAsB5C,EAAU6C,EAAUC,EAAUX,EAAUtD,GAO1EmB,GAFH0C,EAAW1C,EAJE,CACJ,KAAA,GAAanB,MAAAA,EAAmBsD,SAAAA,EAAkBU,KAAAA,EAAkBC,KAAAA,IAK1E9C,EAAS5D,EAAD,IAAKmG,eAAgB,CAC3B,IAAA,IAAIzB,KAASd,EAAS5D,EAAD,IAAKmG,eACJ,KAAtBzB,EAAM0B,OAAOzE,OAIfgF,EAAejC,EAAMd,SAAS5D,EAAf,IAAmB6E,UAAUC,QAASJ,EAAMd,SAAS5D,EAAf,IAAmBsD,QAAQsD,MAAOlC,EAAM0B,QAC7FO,EAAejC,EAAMd,SAAS5D,EAAf,IAAmB6E,UAAUT,KAAMM,EAAMd,SAAS5D,EAAf,IAAmBsD,QAAQsD,MAAOlC,EAAM0B,SAGxF1B,EAAM2B,eACRE,EAAY7B,EAAMd,SAAUc,EAAM0B,eAG7BxC,EAAS5D,EAAD,IAAKmG,oBAGpB3E,QAAQC,kCAAkCgF,eAa5C,SAASH,EAAW1C,EAAUwC,GAC1BxC,GAAAA,EAASzD,EAAD,KAAMsD,SAAWzE,EAAaE,aAAAA,UAItB,KAAhBkH,EAAOzE,MACTgF,EAAe/C,EAAS5D,EAAD,IAAK6E,UAAUC,QAASlB,EAAS5D,EAAD,IAAKsD,QAAQsD,MAAOR,GAI5EO,EAAe/C,EAAS5D,EAAD,IAAK6E,UAAUT,KAAMR,EAAS5D,EAAD,IAAKsD,QAAQsD,MAAOR,IAEpExC,EAAS5D,EAAD,IAAKoD,WAAWyD,iBAAiB,CAGxCC,IAAAA,EAAa,IACbV,EACHzE,KAAMiC,EAAS5D,EAAD,IAAKqD,aAAe+C,EAAOzE,MAG1C2E,EADA1C,EAAWA,EAAS5D,EAAD,IAAKoD,WACH0D,IAavB,SAASP,EAAY3C,EAAUwC,GAC1BhF,IAAAA,EAAOb,OAAOa,KAAKwC,GACnB,IAAA,IAAIvC,KAAOD,EAAM,CAChB2F,IAAAA,EAAoC,iBAAjBX,EAAO3D,OAAuC,OAAjB2D,EAAO3D,MAAkB2D,EAAO3D,MAAMpB,QAAOmB,EAC7FwE,EAA0C,iBAApBZ,EAAOL,UAA6C,OAApBK,EAAOL,SAAqBK,EAAOL,SAAS1E,QAAOmB,EAC1GuE,GAAAA,IAAaC,EAAa,CACxBd,IAAAA,EAAazG,EAAWE,WAAAA,YACZ6C,IAAbuE,EAAwBb,EAAazG,EAAWG,WAAAA,YAC3B4C,IAAhBwE,IAA2Bd,EAAazG,EAAWC,WAAAA,QAEvDuH,IAAAA,EAAY,CACftF,KAAM,GACNoE,SAAUiB,EACVvE,MAAOsE,EACP/B,KAAMkB,GAIJtC,EAASvC,GAAKlB,EAAd,KAAmBsD,SAAWzE,EAAaE,aAAAA,SAC7CyH,EAAe/C,EAASvC,GAAKrB,EAAd,IAAkB6E,UAAUC,QAASlB,EAASvC,GAAKrB,EAAd,IAAkBsD,QAAQsD,MAAOK,GAGtFV,EAAY3C,EAASvC,GAAM4F,KAW9B,SAASN,EAAepB,EAAc2B,EAAWd,GAC5C,IAAA,IAAI7E,EAAIgE,EAAa3E,OAAS,EAAGW,GAAK,EAAGA,IAAK,CAC7C4C,IAAAA,EAAWoB,EAAahE,GACzB4C,EAASa,KAAKjC,SAASqD,EAAOpB,SACX,IAAlBb,EAASG,MACXiB,EAAaC,OAAOjE,EAAG,GAExB4C,EAASc,KAAKvE,KAAKwG,EAAWd;;AC5KjC,aA8EC,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,OAAA,EAAA,QAAA,MAAA,EAAA,QAAA,QAAA,EA5ED,IAAA,EAAA,QAAA,oBACA,EAAA,QAAA,sBAUO,SAASZ,EAAO5B,EAAUN,EAAS6D,EAAOC,KAAgBC,GAC7DzD,GAAAA,EAASzD,EAAD,KAAMsD,SAAWzE,EAAaC,aAAAA,OACjCuF,OAAAA,MAAMhE,UAAUgF,OAAO9E,KAAK4C,EAAQsD,MAAOO,EAAOC,KAAgBC,GAGtEC,IAAAA,GAAyB1D,EAASzD,EAAD,KAAMoH,eAAe,UAC1D3D,EAASzD,EAAD,KAAMsD,OAASzE,EAAaI,aAAAA,SAChC2G,IAAAA,EAAWzC,EAAQN,OAAOuB,MAAM,GAChCiD,EAAUhD,MAAMhE,UAAUgF,OAAO9E,KAAK4C,EAAQsD,MAAOO,EAAOC,KAAgBC,GAC5EI,EAAO,CAAEN,MAAAA,EAAOC,YAAAA,EAAaC,MAAAA,GAO1BG,OALJF,SAA8B1D,EAASzD,EAAD,KAAMsD,OAC1CG,EAASzD,EAAD,KAAMsD,OAASzE,EAAaC,aAAAA,QAEnB2E,EAAAA,EAAAA,uBAAAA,EAAUnE,EAAWI,WAAAA,OAAQ4H,EAAM1B,EAAUzC,EAAQN,QAEpEwE,EAQD,SAASE,EAAM9D,EAAUN,GAC5BM,GAAAA,EAASzD,EAAD,KAAMsD,SAAWzE,EAAaC,aAAAA,OACjCuF,OAAAA,MAAMhE,UAAUkH,MAAMhH,KAAK4C,EAAQsD,OAGvCU,IAAAA,GAAyB1D,EAASzD,EAAD,KAAMoH,eAAe,UAC1D3D,EAASzD,EAAD,KAAMsD,OAASzE,EAAaI,aAAAA,SAChC2G,IAAAA,EAAWzC,EAAQN,OAAOuB,MAAM,GAChCiD,EAAUhD,MAAMhE,UAAUkH,MAAMhH,KAAK4C,EAAQsD,OAO1CY,OALJF,SAA8B1D,EAASzD,EAAD,KAAMsD,OAC1CG,EAASzD,EAAD,KAAMsD,OAASzE,EAAaC,aAAAA,QAEnB2E,EAAAA,EAAAA,uBAAAA,EAAUnE,EAAWK,WAAAA,MAAO,GAAIiG,EAAUzC,EAAQN,QAEjEwE,EASD,SAASG,EAAQ/D,EAAUN,KAAY+D,GAC1CzD,GAAAA,EAASzD,EAAD,KAAMsD,SAAWzE,EAAaC,aAAAA,OACjCuF,OAAAA,MAAMhE,UAAUkH,MAAMhH,KAAK4C,EAAQsD,OAGvCU,IAAAA,GAAyB1D,EAASzD,EAAD,KAAMoH,eAAe,UAC1D3D,EAASzD,EAAD,KAAMsD,OAASzE,EAAaI,aAAAA,SAChC2G,IAAAA,EAAWzC,EAAQN,OAAOuB,MAAM,GAChCqD,EAAYpD,MAAMhE,UAAUmH,QAAQjH,KAAK4C,EAAQsD,SAAUS,GAC3DI,EAAO,CAAEJ,MAAAA,GAONO,OALJN,SAA8B1D,EAASzD,EAAD,KAAMsD,OAC1CG,EAASzD,EAAD,KAAMsD,OAASzE,EAAaC,aAAAA,QAEnB2E,EAAAA,EAAAA,uBAAAA,EAAUnE,EAAWM,WAAAA,QAAS0H,EAAM1B,EAAUzC,EAAQN,QAErE4E;;AChFR,aAEA,IAAA,EAAA,QAAA,oBACA,EAAA,QAAA,6BACA,EAAA,EAAA,QAAA,wBACA,EAAA,EAAA,QAAA,uBACA,EAAA,QAAA,0BACA,EAAA,QAAA,sBA8SsC,SAAA,IAAA,GAAA,mBAAA,QAAA,OAAA,KAAA,IAAA,EAAA,IAAA,QAAA,OAAA,EAAA,WAAA,OAAA,GAAA,EAAA,SAAA,EAAA,GAAA,GAAA,GAAA,EAAA,WAAA,OAAA,EAAA,GAAA,OAAA,GAAA,iBAAA,GAAA,mBAAA,EAAA,MAAA,CAAA,QAAA,GAAA,IAAA,EAAA,IAAA,GAAA,GAAA,EAAA,IAAA,GAAA,OAAA,EAAA,IAAA,GAAA,IAAA,EAAA,GAAA,EAAA,OAAA,gBAAA,OAAA,yBAAA,IAAA,IAAA,KAAA,EAAA,GAAA,OAAA,UAAA,eAAA,KAAA,EAAA,GAAA,CAAA,IAAA,EAAA,EAAA,OAAA,yBAAA,EAAA,GAAA,KAAA,IAAA,EAAA,KAAA,EAAA,KAAA,OAAA,eAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,OAAA,EAAA,QAAA,EAAA,GAAA,EAAA,IAAA,EAAA,GAAA,EA5StC,IAAI5H,EAAKC,OAAOC,IAAI,uBAChBC,EAAMF,OAAOC,IAAI,iCAMjB2H,EAAqBtH,OAAOa,KAAK0G,GACrC,IAAI,IAAIvG,EAAIsG,EAAmBjH,OAAS,EAAGW,GAAK,EAAGA,IAAK,CACnDwG,IAAAA,EAAOF,EAAmBtG,GAC1ByG,EAAU,IAAID,EAClBD,EAAcE,GAAWF,EAAcC,GACvCF,EAAmB5F,KAAK+F,GAGzB,MAAMC,EAQLC,YAAYlF,GAAQ,OAAEmF,GAAO,EAAT,YAAeC,GAAY,EAA3B,MAAiCC,EAAM,IAAO,IAoB1D,OAnBFF,KAAAA,OAASA,EACTC,KAAAA,YAAcA,EACdE,KAAAA,aAAe,IAEjBD,GAASA,EAAMC,eAAc,KAAKA,aAAeD,EAAMC,cAErDtE,KAAAA,UAAW,EAAe,EAAA,gBAAA,CAC7B7D,CAAAA,GAAM,CACNsD,OAAQzE,EAAaC,aAAAA,QAErBe,CAAAA,GAAK,CACLsD,QAAS,CAAEG,OAAQpE,EAAcC,cAAAA,QAElCuH,iBAAiB,GACf,IACE7C,KAAAA,SAAShE,GAAI2B,KAAO,GACpBqC,KAAAA,SAAShE,GAAIqD,aAAe,GAC5BW,KAAAA,SAAShE,GAAIsD,QAAQN,OAASA,EAE5B,KAAKuF,YAAY,KAAKvE,UAQ9BuE,YAAYnF,EAAYoF,GACnB5E,IAAAA,OAEkBpB,IAAnBgG,EACF5E,EAAWR,GAGXQ,GAAW,EAAeR,EAAAA,gBAAAA,EAAYoF,IAC7BxI,GAAIsD,QAAQN,OAASI,EAAWpD,GAAIsD,QAAQN,OAAQwF,GAG1DlF,IAAAA,EAAUM,EAAS5D,GAAIsD,QACvBN,EAASM,EAAQN,OAEjByF,GAAe,EAAWzF,EAAAA,YAAAA,GAE3BnE,GAAAA,EAAWkE,WAAAA,SAAS0F,GAAe,CACjCC,IAAAA,EAAYC,MAAMD,UAAU1F,EAAQ,CACvC4F,IAAK,CAAC5F,EAAyCT,EAAUqE,IACrD,KAAKwB,aAAeS,EAAatB,eAAehF,IAAaA,KAAYhC,OAAOuI,eAAe9F,GAE1F6F,EAAatG,GAAUwG,KAAK,KAAMnF,EAAUN,GAE5CuE,EAAmB9E,SAASR,SAAyC,IAArBS,EAAOT,GAEvDuF,EAAcvF,GAAUwG,KAAK,KAAMnF,EAAUN,GAE5CN,EAAOgG,qBAAqBzG,IAAiC,iBAAbA,GAGjDqB,EAASrB,IACZqB,EAASrB,GAAUvC,GAAIsD,QAAQsD,OAC/BhD,EAASrB,GAAUvC,GAAIsD,QAAQG,SAAWpE,EAAcC,cAAAA,MACrDsE,EAASrB,GAAUvC,GAAIsD,QAAQsD,MAL/B5D,EAAOT,GAWhB0G,IAAK,CAACjG,EAAyCT,EAAUE,EAAOmE,KAU5DhD,GAAAA,EAASzD,GAAKsD,SAAWzE,EAAaG,aAAAA,QAEjC,OADPqC,QAAQ0B,yCAAyCX,2BAC1C,EAEH,GAAuB,iBAAbA,EAEP,OADPS,EAAOT,GAAYE,GACZ,EAEH,GAAgB,WAAbF,IAA0BS,EAAOgG,qBAAqBzG,GAAW,CAEpE2G,IAAAA,EAAa3I,OAAO4I,yBAAyBnG,EAAQT,GACtD,GAAsB,iBAAf2G,IAAqD,IAA1BA,EAAWE,WAExC,OADPpG,EAAOT,GAAYE,GACZ,EAILsD,IAAAA,EAAW/C,EAAOT,GAClB8G,GAAkB,OACI7G,IAAvBoB,EAASrB,SAAoEC,IAAzCoB,EAASrB,GAAUvC,GAAIsD,QAAQsD,QAErEhD,EAASrB,GAAUvC,GAAIsD,QAAQG,OAASpE,EAAcE,cAAAA,QACtD8J,GAAkB,EACf,KAAKlB,QAEPmB,WAAWrB,EAAUsB,QAAS,KAAKjB,aAAc1E,EAASrB,GAAUvC,GAAIsD,QAAQsD,QAIlFnE,GAAQ,EAAUA,EAAAA,WAAAA,GAClBO,EAAOT,GAAYE,EAEfwD,IAAAA,GAAe,EACfnD,GAAc,EAAWL,EAAAA,YAAAA,GAQtB,OAPJ5D,EAAWkE,WAAAA,SAASD,KACjByF,KAAAA,YAAY3E,EAAUrB,GAC3B0D,GAAe,IAGFrC,EAAAA,EAAAA,eAAAA,EAAUrB,EAAUwD,EAAUsD,EAAiB5G,EAAOwD,IAE7D,GAMRuD,eAAgB,CAACxG,EAAyCT,EAAU2G,KAChE,GAAoB,iBAAb3G,EAEF,OADPhC,OAAOiJ,eAAexG,EAAQT,EAAU2G,IACjC,EAGJnD,IAAAA,EAAW/C,EAAOT,GAClB8G,GAAkB,OACI7G,IAAvBoB,EAASrB,SAAoEC,IAAzCoB,EAASrB,GAAUvC,GAAIsD,QAAQsD,QAErEhD,EAASrB,GAAUvC,GAAIsD,QAAQG,OAASpE,EAAcE,cAAAA,QACtD8J,GAAkB,EACf,KAAKlB,QAEPmB,WAAWrB,EAAUsB,QAAS,KAAKjB,aAAc1E,EAASrB,GAAUvC,GAAIsD,QAAQsD,QAIlFsC,EAAWzG,OAAQ,EAAUyG,EAAAA,WAAAA,EAAWzG,OACxClC,OAAOiJ,eAAexG,EAAQT,EAAU2G,GACpCzG,IAAAA,EAAQyG,EAAWzG,MACnBwD,GAAe,EAEfnD,GAAc,EAAWoG,EAAAA,YAAAA,EAAWzG,OAQjC,OAPJ5D,EAAWkE,WAAAA,SAASD,KAA0C,IAA1BoG,EAAWE,aAC5Cb,KAAAA,YAAY3E,EAAUrB,GAC3B0D,GAAe,IAGFrC,EAAAA,EAAAA,eAAAA,EAAUrB,EAAUwD,EAAUsD,EAAiB5G,EAAOwD,IAE7D,GAGRwD,eAAgB,CAACzG,EAAyCT,KACtD,IAACS,EAAOgG,qBAAqBzG,IAAiC,iBAAbA,EAG5C,cADAS,EAAOT,IACP,EAGLqB,GAAAA,EAASzD,GAAKsD,SAAWzE,EAAaG,aAAAA,QAEjC,OADPqC,QAAQ0B,gCAAgCX,2BACjC,EAGLA,GAAAA,KAAYS,EAAQ,CAClB+C,IAAAA,EAAW/C,EAAOT,GAClB8G,GAAkB,EAef,YAdmB7G,IAAvBoB,EAASrB,SAAoEC,IAAzCoB,EAASrB,GAAUvC,GAAIsD,QAAQsD,QAErEhD,EAASrB,GAAUvC,GAAIsD,QAAQG,OAASpE,EAAcE,cAAAA,QACtD8J,GAAkB,EACf,KAAKlB,QAEPmB,WAAWrB,EAAUsB,QAAS,KAAKjB,aAAc1E,EAASrB,GAAUvC,GAAIsD,QAAQsD,eAI3E5D,EAAOT,IAEAqB,EAAAA,EAAAA,eAAAA,EAAUrB,EAAUwD,EAAUsD,OAAiB7G,GAAW,IAEjE,EAGA,OAAA,KAQPiG,GAHH7E,EAAS5D,GAAIsD,QAAQsD,MAAQ8B,EAAU9B,MACvChD,EAAS5D,GAAIsD,QAAQoG,OAAShB,EAAUgB,OAEpB,WAAjBjB,EAA2B,CACzBrH,IAAAA,EAAOb,OAAOa,KAAK4B,GACnB,IAAA,IAAI3B,KAAOD,EAAM,CAChBuI,IAAAA,GAAiB,EAAW3G,EAAAA,YAAAA,EAAO3B,IACpCxC,EAAWkE,WAAAA,SAAS4G,IACjBpB,KAAAA,YAAY3E,EAAUvC,SAIzB,GAAoB,UAAjBoH,EACH,IAAA,IAAIlH,EAAI,EAAGA,EAAIyB,EAAOpC,OAAQW,IAAK,CAClCoI,IAAAA,GAAiB,EAAW3G,EAAAA,YAAAA,EAAOzB,IACpC1C,EAAWkE,WAAAA,SAAS4G,IACjBpB,KAAAA,YAAY3E,EAAUrC,QAK7BC,QAAQC,KAAK,mBAGPiH,OAAAA,EAAU9B,MAGX,MAAA,IAAIjE,MAAM,mBAAmB9D,EAAW8F,WAAAA,KAAK,MAS9C4E,eAAQ3C,GACVhD,IAAAA,EAAUN,EACV,IACHM,EAAWgD,EAAMgD,wBACjBtG,EAAUsD,EAAMiD,uBACf,MAAM3G,GAAO,OAIZI,EAAQG,SAAWpE,EAAcC,cAAAA,QACnCgE,EAAQG,OAASpE,EAAcE,cAAAA,SAG5BuK,IAAAA,GAAc,EAAWlD,EAAAA,YAAAA,GAE1B/H,GAAAA,EAAWkE,WAAAA,SAAS+G,GAAc,CAChC1I,IAAAA,EAAOb,OAAOa,KAAKwF,GACnB,IAAA,IAAIvF,KAAOD,EACV,IACCuI,IAAAA,GAAiB,EAAW/C,EAAAA,YAAAA,EAAMvF,IACnCxC,EAAWkE,WAAAA,SAAS4G,IACtB1B,EAAUsB,QAAQ3F,EAASvC,GAAKrB,GAAIsD,QAAQsD,OAE5C,MAAM1D,GACP1B,QAAQ0B,MAAMA,GAIhBI,EAAQoG,SACRpG,EAAQsD,WAAQpE,EAChBc,EAAQG,OAASpE,EAAcG,cAAAA,aAG/BgC,QAAQC,iBAAiBqI,yBAIpBpI,iBAAUC,GACT,OAAA,EAAUA,EAAAA,WAAAA,GAGXU,gBAASrB,EAAKW,GACb,OAAA,EAASX,EAAAA,UAAAA,EAAKW,IAIvBoI,OAAOC,QAAUA,QAAU/B","file":"proxserve.min.js","sourceRoot":"../src","sourcesContent":["/**\n * Copyright 2021 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nlet proxyTypes = ['Object', 'Array']; //acceptable types to be proxied\nproxyTypes.OBJECT = proxyTypes[0];\nproxyTypes.ARRAY = proxyTypes[1];\n\nlet nodeStatuses = ['active', 'stopped', 'blocked', 'splicing']; //statuses of data-nodes\nnodeStatuses.ACTIVE = nodeStatuses[0];\nnodeStatuses.STOPPED = nodeStatuses[1];\nnodeStatuses.BLOCKED = nodeStatuses[2];\nnodeStatuses.SPLICING = nodeStatuses[3];\n\nlet proxyStatuses = ['alive', 'deleted', 'revoked']; //statuses of proxies\nproxyStatuses.ALIVE = proxyStatuses[0];\nproxyStatuses.DELETED = proxyStatuses[1];\nproxyStatuses.REVOKED = proxyStatuses[2];\n\nlet eventNames = ['create', 'update', 'delete', 'splice', 'shift', 'unshift'];\neventNames.CREATE = eventNames[0];\neventNames.UPDATE = eventNames[1];\neventNames.DELETE = eventNames[2];\neventNames.SPLICE = eventNames[3];\neventNames.SHIFT = eventNames[4];\neventNames.UNSHIFT = eventNames[5];\n\nlet ND = Symbol.for('proxserve_node_data'); //key for the data of a node\nlet NID = Symbol.for('proxserve_node_inherited_data'); //key for the inherited data of a node\n\nexport { proxyTypes, nodeStatuses, proxyStatuses, eventNames, ND, NID };","/**\n * Copyright 2020 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\n/**\n * return a string representing the full type of the variable\n * @param {*} variable \n * @returns {String} - Object, Array, Number, String, Boolean, Null, Undefined, BigInt, Symbol, Date ...\n */\nexport function realtypeof(variable) {\n\tlet rawType = Object.prototype.toString.call(variable); //[object Object], [object Array], [object Number] ...\n\treturn rawType.substring(8, rawType.length - 1);\n}\n\n/**\n * check if variable is a number or a string of a number\n * @param {*} variable \n */\n/*export function isNumeric(variable) {\n\tif(typeof variable === 'string' && variable === '') return false;\n\telse return !isNaN(variable);\n}*/\n\n/**\n * recursively clones objects and array\n * @param {Proxy|Object|Array} proxy \n */\nlet simpleCloneSet = new WeakSet();\nexport function simpleClone(obj) {\n\tlet typeofobj = realtypeof(obj);\n\tlet cloned;\n\tif(typeofobj === 'Object') {\n\t\tsimpleCloneSet.add(obj);\n\t\tcloned = {};\n\t\tlet keys = Object.keys(obj);\n\t\tfor(let key of keys) {\n\t\t\tif(simpleCloneSet.has(obj[key])) {\n\t\t\t\tcloned[key] = obj[key];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcloned[key] = simpleClone(obj[key]);\n\t\t\t}\n\t\t}\n\t}\n\telse if(typeofobj === 'Array') {\n\t\tsimpleCloneSet.add(obj);\n\t\tcloned = [];\n\t\tfor(let i = 0; i < obj.length; i++) {\n\t\t\tif(simpleCloneSet.has(obj[i])) {\n\t\t\t\tcloned[i] = obj[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcloned[i] = simpleClone(obj[i]);\n\t\t\t}\n\t\t}\n\t}\n\telse { //hopefully a primitive\n\t\tcloned = obj;\n\n\t\tif(typeofobj !== 'Undefined' && typeofobj !== 'Null' && typeofobj !== 'Boolean' && typeofobj !== 'Number'\n\t\t&& typeofobj !== 'BigInt' && typeofobj !== 'String') {\n\t\t\tconsole.warn(`Can't clone a variable of type ${typeofobj}`);\n\t\t}\n\t}\n\n\treturn cloned;\n}\n\n/**\n * splits a path to an array of properties\n * (benchmarked and is faster than regex and split())\n * @param {String} path \n */\nexport function splitPath(path) {\n\tif(typeof path !== 'string' || path === '') {\n\t\treturn [];\n\t}\n\t\n\tlet i = 0, betweenBrackets = false, onlyDigits = false;\n\t//loop will skip over openning '.' or '['\n\tif(path[0] === '.') {\n\t\ti = 1;\n\t} else if(path[0] === '[') {\n\t\ti = 1;\n\t\tbetweenBrackets = true;\n\t\tonlyDigits = true;\n\t}\n\n\tlet resultsArr = [];\n\tlet tmp='';\n\tfor(; i < path.length; i++) {\n\t\tlet char = path[i];\n\n\t\tif(betweenBrackets) {\n\t\t\tif(char === ']') {\n\t\t\t\tif(onlyDigits) resultsArr.push(parseInt(tmp, 10));\n\t\t\t\telse resultsArr.push(tmp);\n\n\t\t\t\tbetweenBrackets = false;\n\t\t\t\tonlyDigits = false;\n\t\t\t\ttmp = '';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(onlyDigits) {\n\t\t\t\t\tlet code = char.charCodeAt(0);\n\t\t\t\t\tif(code < 48 || code > 57) { //less than '0' char or greater than '9' char\n\t\t\t\t\t\tonlyDigits = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp += char;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(char === '[') {\n\t\t\t\tbetweenBrackets = true;\n\t\t\t\tonlyDigits = true;\n\t\t\t}\n\t\t\t\n\t\t\t//check if starting a new property but avoid special case of [prop][prop]\n\t\t\tif(char === '.' || char === '[') {\n\t\t\t\tif(tmp !== '') {\n\t\t\t\t\tresultsArr.push(tmp);\n\t\t\t\t\ttmp = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttmp += char;\n\t\t\t}\n\t\t}\n\t}\n\tif(tmp!=='') {\n\t\tresultsArr.push(tmp);\n\t}\n\treturn resultsArr;\n}\n\n/**\n * evaluate a long path and return the designated object and its referred property\n * @param {Object} obj\n * @param {String} path\n * @returns {Object} - returns {object, property, value}\n */\nexport function evalPath(obj, path) {\n\tif(path === '') {\n\t\treturn { object: obj, property: undefined, value: obj };\n\t}\n\n\tlet segments = splitPath(path);\n\tlet i;\n\tfor(i = 0; i <= segments.length - 2; i++) { //iterate until one before last property because they all must exist\n\t\tobj = obj[segments[i]];\n\t\tif(typeof obj === 'undefined') {\n\t\t\tthrow new Error(`Invalid path was given - \"${path}\"`);\n\t\t}\n\t}\n\treturn { object: obj, property: segments[i], value: obj[ segments[i] ] };\n}","/**\n * Copyright 2021 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nimport { proxyTypes, ND, NID } from './global-vars.js';\nimport { realtypeof } from './general-functions.js';\n\n/**\n * Convert property name to valid path segment\n * @param {*} obj \n * @param {String} property \n */\nexport function property2path(obj, property) {\n\tif(typeof property === 'symbol') {\n\t\tthrow new Error(`property of type \"symbol\" isn't path'able`);\n\t}\n\n\tlet typeofobj = realtypeof(obj);\n\tswitch(typeofobj) {\n\t\tcase 'Object': return `.${property}`;\n\t\tcase 'Array': return `[${property}]`;\n\t\tdefault: console.warn(`Not Implemented (type of '${typeofobj}')`); return property;\n\t}\n}\n\n/**\n * recursively switch between all proxies to their original targets.\n * note: original targets should never hold proxies under them,\n * thus altering the object references (getting from 'value') should be ok.\n * if the programmer decided to\n * \t1. create a proxy with children (sub-proxies)\n * \t2. create a regular object\n * \t3. adding sub-proxies to the regular object\n * \t4. attaching the regular object to the proxy\n * then this regular object will be altered.\n * @param {*} value\n */\nexport function unproxify(value) {\n\tlet typeofvalue = realtypeof(value);\n\tif(proxyTypes.includes(typeofvalue)) {\n\t\tlet target = value;\n\t\ttry {\n\t\t\ttarget = value.$getOriginalTarget();\n\t\t} catch(error) {}\n\n\t\tswitch(typeofvalue) {\n\t\t\tcase 'Object':\n\t\t\t\tlet keys = Object.keys(target);\n\t\t\t\tfor(let key of keys) {\n\t\t\t\t\ttarget[key] = unproxify(target[key]); //maybe alters target and maybe returning the exact same object\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'Array':\n\t\t\t\tfor(let i=0; i < target.length; i++) {\n\t\t\t\t\ttarget[i] = unproxify(target[i]); //maybe alters target and maybe returning the exact same object\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.warn(`Not Implemented (type of '${typeofobj}')`);\n\t\t}\n\n\t\treturn target;\n\t}\n\telse {\n\t\treturn value; //primitive\n\t}\n}\n\n/**\n * create a node in a tree that mimics the proxserve's object and holds meta-data\n * @param {Object} parentNode \n * @param {String|Number} property \n */\nexport function createDataNode(parentNode, property) {\n\tlet propertyPath;\n\tif(parentNode[ND] && parentNode[ND].objects && parentNode[ND].objects.target) {\n\t\tpropertyPath = property2path(parentNode[ND].objects.target, property);\n\t} else {\n\t\tpropertyPath = property2path({}, property); //if parent doesn't have target then treat it as object\n\t}\n\t\n\tlet node = parentNode[property];\n\tif(!node) {\n\t\tnode = {\n\t\t\t[NID]: Object.create(parentNode[NID]),\n\t\t\t[ND]: {\n\t\t\t\t'parentNode': parentNode,\n\t\t\t\t'listeners': {\n\t\t\t\t\t'shallow': [],\n\t\t\t\t\t'deep': []\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tparentNode[property] = node;\n\t}\n\n\tdelete node[NID].status; //clears old status in case a node previously existed\n\t//updates path (for rare case where parent was array and then changed to object or vice versa)\n\t//and also makes a new and clean 'objects' property\n\tObject.assign(node[ND], {\n\t\t'path': parentNode[ND].path + propertyPath,\n\t\t'propertyPath': propertyPath,\n\t\t'objects': Object.assign(Object.create(parentNode[ND].objects), {\n\t\t\t'target': undefined,\n\t\t\t'proxy': undefined,\n\t\t\t'revoke': undefined\n\t\t\t/* inherits status */\n\t\t})\n\t});\n\n\treturn node;\n}\n","/**\n * Copyright 2021 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n// Pseudo methods are methods that aren't really on the object - not as a property nor via its prototype\n// thus they will not be retrieved via \"for..in\" and etcetera. Their property name is actually undefined, but\n// calling it will return the method via the JS proxy's \"get\" handler.\n// (i.e. someProxserve.pseudoFunction will return the pseudoFunction)\n\"use strict\"\n\nimport { eventNames, nodeStatuses, ND, NID } from './global-vars.js';\nimport { createDataNode } from './supporting-functions.js';\nimport { splitPath } from './general-functions.js';\n\n/**\n * stop object and children from emitting change events\n * automatically filled param {Object} dataNode\n */\nexport function stop(dataNode) {\n\tdataNode[NID].status = nodeStatuses.STOPPED;\n}\n\n/**\n * block object and children from any changes.\n * user can't set nor delete any property\n * automatically filled param {Object} dataNode\n */\nexport function block(dataNode) {\n\tdataNode[NID].status = nodeStatuses.BLOCKED;\n}\n\n/**\n * resume default behavior of emitting change events, inherited from parent\n * automatically filled param {Object} dataNode\n * automatically filled param {Object} objects\n * @param {Boolean} [force] - force being active regardless of parent\n */\nexport function activate(dataNode, objects, force=false) {\n\tif(force || dataNode === this.dataTree) { //force activation or we are on root proxy\n\t\tdataNode[NID].status = nodeStatuses.ACTIVE;\n\t}\n\telse {\n\t\tdelete dataNode[NID].status;\n\t}\n}\n\n/**\n * add event listener on a proxy or on a descending path\n * automatically filled param {Object} dataNode\n * automatically filled param {Object} objects\n * @param {String|Array.String} events\n * @param {String} [path] - path selector\n * @param {Function} listener\n * @param {Object} [options]\n * \t@property {Boolean} [options.deep] - should listen for event emitted by sub-objects or not\n * \t@property {Boolean} [options.id] - identifier for removing this listener later\n * \t@property {Boolean} [options.once] - whether this listener will run only once or always\n */\nexport function on(dataNode, objects, events, path, listener, {deep=false, id=undefined, once=false} = {}) {\n\tif(events === 'change') events = eventNames.slice(0); //will listen to all events\n\telse if(!Array.isArray(events)) events = [events];\n\n\tfor(let event of events) {\n\t\tif(!eventNames.includes(event)) {\n\t\t\tthrow new Error(`${event} is not a valid event. valid events are ${eventNames.join(',')}`);\n\t\t}\n\t}\n\t\n\tif(typeof path === 'function') { //if called without path\n\t\tif(typeof listener === 'object') {\n\t\t\tif(typeof listener.deep === 'boolean') deep = listener.deep;\n\t\t\tif(listener.id !== undefined) id = listener.id;\n\t\t\tif(typeof listener.once === 'boolean') once = listener.once;\n\t\t}\n\t\tlistener = path;\n\t\tpath = '';\n\t} else if(typeof listener !== 'function') {\n\t\tthrow new Error(`invalid arguments were given. listener must be a function`);\n\t}\n\t\n\tlet segments = splitPath(path);\n\t//traverse down the tree. create data-nodes if needed\n\tfor(let property of segments) {\n\t\tif(!dataNode[property]) {\n\t\t\tcreateDataNode(dataNode, property);\n\t\t}\n\t\tdataNode = dataNode[property];\n\t}\n\n\tlet listenersPool = dataNode[ND].listeners.shallow;\n\tif(deep) listenersPool = dataNode[ND].listeners.deep;\n\n\tlet listenerObj = {\n\t\ttype: events,\n\t\tonce: once,\n\t\tfunc: listener\n\t};\n\tif(id !== undefined) {\n\t\tlistenerObj.id = id;\n\t}\n\tlistenersPool.push(listenerObj);\n}\n\n/**\n * add event listener on a proxy or on a descending path which will run only once\n * automatically filled param {Object} dataNode\n * automatically filled param {Object} objects\n * @param {String|Array.String} events\n * @param {String} [path] - path selector\n * @param {Function} listener \n * @param {String} [options]\n */\nexport function once(dataNode, objects, events, path, listener, options) {\n\tif(typeof options !== 'object') options = {};\n\toptions.once = true;\n\ton.call(this, dataNode, objects, events, path, listener, options);\n}\n\n/**\n * removes a listener from a path by an identifier (can have multiple listeners with the same ID)\n * or by the listener function itself\n * automatically filled param {Object} dataNode\n * automatically filled param {Object} objects\n * @param {String} [path] - path selector\n * @param {String|Function} id - the listener(s) identifier or listener-function\n */\nexport function removeListener(dataNode, objects, path, id) {\n\tif(arguments.length === 3) { //if called without path\n\t\tid = path;\n\t\tpath = '';\n\t}\n\n\tlet fullPath = `${dataNode[ND].path}${path}`;\n\tlet segments = splitPath(path);\n\t//traverse down the tree\n\tfor(let property of segments) {\n\t\tif(!dataNode[property]) {\n\t\t\tconsole.warn(`can't remove listener from a non-existent path '${fullPath}'`);\n\t\t\treturn;\n\t\t}\n\t\tdataNode = dataNode[property];\n\t}\n\n\tfunction removeById(listenersArr, id) {\n\t\tfor(let i = listenersArr.length - 1; i >= 0; i--) {\n\t\t\tlet listenerObj = listenersArr[i];\n\t\t\tif((id !== undefined && listenerObj.id === id) || listenerObj.func === id) {\n\t\t\t\tlistenersArr.splice(i, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tremoveById(dataNode[ND].listeners.shallow, id);\n\tremoveById(dataNode[ND].listeners.deep, id);\n}\n\n/**\n * removing all listeners of a path\n * automatically filled param {Object} dataNode\n * automatically filled param {Object} objects\n * @param {String} [path] - path selector\n */\nexport function removeAllListeners(dataNode, objects, path='') {\n\tlet fullPath = `${dataNode[ND].path}${path}`;\n\tlet segments = splitPath(path);\n\t//traverse down the tree\n\tfor(let property of segments) {\n\t\tif(!dataNode[property]) {\n\t\t\tconsole.warn(`can't remove all listeners from a non-existent path '${fullPath}'`);\n\t\t\treturn;\n\t\t}\n\t\tdataNode = dataNode[property];\n\t}\n\n\tdataNode[ND].listeners.shallow = [];\n\tdataNode[ND].listeners.deep = [];\n}\n\n/**\n * the following functions (getOriginalTarget, getProxserveObjects, getProxserveDataNode, getProxserveInstance) seem silly\n * because they could have been written directly on the handler's get() method but it's here as part of the convention of\n * exposing proxy-\"inherited\"-methods\n */\n/**\n * get original target that is behind the proxy\n * automatically filled param {Object} dataNode\n * automatically filled param {Object} objects\n */\nexport function getOriginalTarget(dataNode, objects) {\n\treturn objects.target;\n}\n\n/**\n * get 'objects' (which holds all related objects) of a proxy\n * automatically filled param {Object} dataNode\n * automatically filled param {Object} objects\n */\nexport function getProxserveObjects(dataNode, objects) {\n\treturn objects;\n}\n\n/**\n * get the data-node of the proxy or sub-proxy\n * automatically filled param {Object} dataNode\n */\nexport function getProxserveDataNode(dataNode) {\n\treturn dataNode;\n}\n\n/**\n * get the Proxserve's instance that created this proxy\n */\nexport function getProxserveInstance() {\n\treturn this;\n}","/**\n * Copyright 2021 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nimport { eventNames, nodeStatuses, proxyStatuses, ND, NID } from './global-vars.js';\nimport { property2path } from './supporting-functions.js';\n\n/**\n * process event and then bubble up and capture down the data tree\n * @param {Object} dataNode\n * @param {String} property\n * @param {*} oldValue\n * @param {Boolean} wasOldValueProxy\n * @param {*} value\n * @param {Boolean} isValueProxy\n */\nexport function initEmitEvent(dataNode, property, oldValue, wasOldValueProxy, value, isValueProxy) {\n\tif(oldValue === value/*no new change was made*/\n\t|| dataNode[ND].objects.status !== proxyStatuses.ALIVE/*altered a deleted or detached proxy*/) {\n\t\treturn;\n\t}\n\n\tlet changeType = eventNames.UPDATE;\n\tif(value === undefined) changeType = eventNames.DELETE;\n\telse if(oldValue === undefined) changeType = eventNames.CREATE;\n\n\tlet deferredEvents;\n\t//altering properties of an array that's in the middle of a splicing phase\n\tif(dataNode[NID].status === nodeStatuses.SPLICING) {\n\t\t//initiate (if needed) an object to hold side effect events\n\t\tif(!dataNode[ND].deferredEvents) dataNode[ND].deferredEvents = [];\n\t\t//save a reference to the deferredEvents\n\t\tdeferredEvents = dataNode[ND].deferredEvents;\n\t}\n\n\tlet path;\n\tif(dataNode[property]) { //changed a property which has its own data node on the tree\n\t\tdataNode = dataNode[property];\n\t\tpath = '';\n\t} else {\n\t\tpath = property2path(dataNode[ND].objects.target, property);\n\t}\n\n\tlet change = {\n\t\t'path': path, 'value': value, 'oldValue': oldValue, 'type': changeType\n\t};\n\n\tif(!deferredEvents) {\n\t\tbubbleEmit(dataNode, change);\n\t\n\t\tif(wasOldValueProxy || isValueProxy) { //old value or new value are proxy meaning they are objects with children\n\t\t\tcaptureEmit(dataNode, change);\n\t\t}\n\t}\n\telse {\n\t\tdeferredEvents.push({dataNode, change, shouldCapture: wasOldValueProxy || isValueProxy});\n\t}\n}\n\n/**\n * process special event for a built-in method and then bubble up the data tree\n * @param {Object} dataNode\n * @param {String} funcName - the method's name\n * @param {Object} funcArgs - the method's arguments\n * @param {*} oldValue\n * @param {*} value\n */\nexport function initFunctionEmitEvent(dataNode, funcName, funcArgs, oldValue, value) {\n\tlet change = {\n\t\t'path': '', 'value': value, 'oldValue': oldValue, 'type': funcName, 'args': funcArgs\n\t};\n\n\tbubbleEmit(dataNode, change);\n\n\tif(dataNode[ND].deferredEvents) {\n\t\tfor(let event of dataNode[ND].deferredEvents) {\n\t\t\tif(event.change.path === '') {\n\t\t\t\t//no path means its an event directly on the property, not on the parent.\n\t\t\t\t//i.e: not an event on \"arr\" with path \"0\", but on \"arr[0]\" with no path.\n\t\t\t\t//function event on \"arr\" already ran, but now a regular event on \"arr[0]\" is due\n\t\t\t\titerateAndEmit(event.dataNode[ND].listeners.shallow, event.dataNode[ND].objects.proxy, event.change);\n\t\t\t\titerateAndEmit(event.dataNode[ND].listeners.deep, event.dataNode[ND].objects.proxy, event.change);\n\t\t\t}\n\n\t\t\tif(event.shouldCapture) {\n\t\t\t\tcaptureEmit(event.dataNode, event.change);\n\t\t\t}\n\t\t}\n\t\tdelete dataNode[ND].deferredEvents;\n\t}\n\telse {\n\t\tconsole.warn(`no side effect events for ${funcName} were made`);\n\t}\n}\n\n/**\n * bubbling phase - go up the data tree and emit\n * @param {Object} dataNode\n * @param {Object} change\n * \t@property {String} change.path\n * \t@property {*} change.oldValue\n * \t@property {*} change.value\n * \t@property {String} change.type\n */\nfunction bubbleEmit(dataNode, change) {\n\tif(dataNode[NID].status === nodeStatuses.STOPPED) {\n\t\treturn; //not allowed to emit\n\t}\n\n\tif(change.path === '') { //iterate over 'shallow' listeners\n\t\titerateAndEmit(dataNode[ND].listeners.shallow, dataNode[ND].objects.proxy, change);\n\t}\n\n\t//iterate over 'deep' listeners\n\titerateAndEmit(dataNode[ND].listeners.deep, dataNode[ND].objects.proxy, change);\n\n\tif(!dataNode[ND].parentNode.isTreePrototype) { //we are not on root node yet\n\t\t//create a shallow copy of 'change' and update its path\n\t\t//(we don't want to alter the 'change' object just emitted to the listener)\n\t\tlet nextChange = {\n\t\t\t...change,\n\t\t\tpath: dataNode[ND].propertyPath + change.path\n\t\t};\n\t\tdataNode = dataNode[ND].parentNode;\n\t\tbubbleEmit(dataNode, nextChange);\n\t}\n}\n\n/**\n * capturing phase - go down the data tree and emit\n * @param {Object} dataNode\n * @param {Object} change\n * \t@property {String} change.path\n * \t@property {*} change.oldValue\n * \t@property {*} change.value\n * \t@property {String} change.type\n */\nfunction captureEmit(dataNode, change) {\n\tlet keys = Object.keys(dataNode);\n\tfor(let key of keys) {\n\t\tlet subValue = (typeof change.value === 'object' && change.value !== null) ? change.value[key] : undefined;\n\t\tlet subOldValue = (typeof change.oldValue === 'object' && change.oldValue !== null) ? change.oldValue[key] : undefined;\n\t\tif(subValue !== subOldValue) { //if not both undefined or same primitive or the same object\n\t\t\tlet changeType = eventNames.UPDATE;\n\t\t\tif(subValue === undefined) changeType = eventNames.DELETE;\n\t\t\telse if(subOldValue === undefined) changeType = eventNames.CREATE;\n\n\t\t\tlet subChange = {\n\t\t\t\tpath: '',\n\t\t\t\toldValue: subOldValue,\n\t\t\t\tvalue: subValue,\n\t\t\t\ttype: changeType\n\t\t\t}\n\n\t\t\t//failing the status check will not emit for current property (but sub-properties might still be forcibly active)\n\t\t\tif(dataNode[key][NID].status !== nodeStatuses.STOPPED) {\n\t\t\t\titerateAndEmit(dataNode[key][ND].listeners.shallow, dataNode[key][ND].objects.proxy, subChange);\n\t\t\t}\n\n\t\t\tcaptureEmit(dataNode[key], subChange);\n\t\t}\n\t}\n}\n\n/**\n * iterate over an array of listeners, handle 'once' listeners and emit\n * @param {Array} listenersArr \n * @param {*} thisValue \n * @param {Object} change \n */\nfunction iterateAndEmit(listenersArr, thisValue, change) {\n\tfor(let i = listenersArr.length - 1; i >= 0; i--) {\n\t\tlet listener = listenersArr[i];\n\t\tif(listener.type.includes(change.type)) {\n\t\t\tif(listener.once === true) {\n\t\t\t\tlistenersArr.splice(i, 1);\n\t\t\t}\n\t\t\tlistener.func.call(thisValue, change);\n\t\t}\n\t}\n}","/**\n * Copyright 2021 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n// Proxy methods are methods that will proxy JS built-in methods.\n// For examply, the proxy function for \"splice\" will handle some event stuff and then use\n// the actual \"splice\" function internally\n\"use strict\"\n\nimport { nodeStatuses, eventNames, NID } from './global-vars.js';\nimport { initFunctionEmitEvent } from './event-emitter.js';\n\n/**\n * a wrapper function for the 'splice' method\n * automatically filled param {Object} dataNode\n * automatically filled param {Object} objects\n * @param {Number} start \n * @param {Number} deleteCount \n * @param  {...any} items \n */\nexport function splice(dataNode, objects, start, deleteCount, ...items) {\n\tif(dataNode[NID].status !== nodeStatuses.ACTIVE) {\n\t\treturn Array.prototype.splice.call(objects.proxy, start, deleteCount, ...items);\n\t}\n\n\tlet isActiveByInheritance = !dataNode[NID].hasOwnProperty('status');\n\tdataNode[NID].status = nodeStatuses.SPLICING;\n\tlet oldValue = objects.target.slice(0);\n\tlet deleted = Array.prototype.splice.call(objects.proxy, start, deleteCount, ...items); //creates many side-effect events\n\tlet args = { start, deleteCount, items };\n\t\n\tif(isActiveByInheritance) delete dataNode[NID].status;\n\telse dataNode[NID].status = nodeStatuses.ACTIVE;\n\n\tinitFunctionEmitEvent(dataNode, eventNames.SPLICE, args, oldValue, objects.target);\n\n\treturn deleted;\n}\n\n/**\n * a wrapper function for the 'shift' method\n * automatically filled param {Object} dataNode\n * automatically filled param {Object} objects\n */\nexport function shift(dataNode, objects) {\n\tif(dataNode[NID].status !== nodeStatuses.ACTIVE) {\n\t\treturn Array.prototype.shift.call(objects.proxy);\n\t}\n\n\tlet isActiveByInheritance = !dataNode[NID].hasOwnProperty('status');\n\tdataNode[NID].status = nodeStatuses.SPLICING;\n\tlet oldValue = objects.target.slice(0);\n\tlet deleted = Array.prototype.shift.call(objects.proxy); //creates many side-effect events\n\t\n\tif(isActiveByInheritance) delete dataNode[NID].status;\n\telse dataNode[NID].status = nodeStatuses.ACTIVE;\n\n\tinitFunctionEmitEvent(dataNode, eventNames.SHIFT, {}, oldValue, objects.target);\n\n\treturn deleted;\n}\n\n/**\n * a wrapper function for the 'unshift' method\n * automatically filled param {Object} dataNode\n * automatically filled param {Object} objects\n * @param  {...any} items \n */\nexport function unshift(dataNode, objects, ...items) {\n\tif(dataNode[NID].status !== nodeStatuses.ACTIVE) {\n\t\treturn Array.prototype.shift.call(objects.proxy);\n\t}\n\n\tlet isActiveByInheritance = !dataNode[NID].hasOwnProperty('status');\n\tdataNode[NID].status = nodeStatuses.SPLICING;\n\tlet oldValue = objects.target.slice(0);\n\tlet newLength = Array.prototype.unshift.call(objects.proxy, ...items); //creates many side-effect events\n\tlet args = { items };\n\t\n\tif(isActiveByInheritance) delete dataNode[NID].status;\n\telse dataNode[NID].status = nodeStatuses.ACTIVE;\n\n\tinitFunctionEmitEvent(dataNode, eventNames.UNSHIFT, args, oldValue, objects.target);\n\n\treturn newLength;\n}\n","/**\n * Copyright 2021 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nimport { proxyTypes, nodeStatuses, proxyStatuses } from './global-vars.js';\nimport { unproxify, createDataNode } from './supporting-functions.js';\nimport * as pseudoMethods from './pseudo-methods.js';\nimport * as proxyMethods from './proxy-methods.js';\nimport { realtypeof, splitPath, evalPath } from './general-functions.js';\nimport { initEmitEvent } from './event-emitter.js';\n\nlet ND = Symbol.for('proxserve_node_data'); //key for the data of a node\nlet NID = Symbol.for('proxserve_node_inherited_data'); //key for the inherited data of a node\n\n/**\n * save an array of all reserved function names\n * and also add synonyms to these functions\n */\nlet pseudoMethodsNames = Object.keys(pseudoMethods);\nfor(let i = pseudoMethodsNames.length - 1; i >= 0; i--) {\n\tlet name = pseudoMethodsNames[i];\n\tlet synonym = '$'+name;\n\tpseudoMethods[synonym] = pseudoMethods[name];\n\tpseudoMethodsNames.push(synonym);\n}\n\nclass Proxserve {\n\t/**\n\t * construct a new proxserve instance\n\t * @param {Object|Array} target \n\t * @param {Object} [options]\n\t * \t@property {Boolean} [options.strict] - should destroy detached child-objects or deleted properties automatically\n\t * \t@property {Boolean} [options.emitMethods] - should splice/shift/unshift emit one event or all CRUD events\n\t */\n\tconstructor(target, { strict=true, emitMethods=true, debug={} } = {}) {\n\t\tthis.strict = strict;\n\t\tthis.emitMethods = emitMethods;\n\t\tthis.destroyDelay = 1000;\n\n\t\tif(debug && debug.destroyDelay) this.destroyDelay = debug.destroyDelay;\n\n\t\tthis.dataTree = createDataNode({\n\t\t\t[NID]: {\n\t\t\t\tstatus: nodeStatuses.ACTIVE\n\t\t\t},\n\t\t\t[ND]: {\n\t\t\t\tobjects: { status: proxyStatuses.ALIVE }\n\t\t\t},\n\t\t\tisTreePrototype: true\n\t\t}, '');\n\t\tthis.dataTree[ND].path = '';\n\t\tthis.dataTree[ND].propertyPath = '';\n\t\tthis.dataTree[ND].objects.target = target;\n\n\t\treturn this.createProxy(this.dataTree);\n\t}\n\n\t/**\n\t * create a new proxy and a new node for a property of the parent's target-object\n\t * @param {Object} parentNode\n\t * @param {String} [targetProperty]\n\t */\n\tcreateProxy(parentNode, targetProperty) {\n\t\tlet dataNode;\n\n\t\tif(targetProperty === undefined) { //refering to own node and not a child property (meaning root object)\n\t\t\tdataNode = parentNode;\n\t\t}\n\t\telse {\n\t\t\tdataNode = createDataNode(parentNode, targetProperty); //either creates new or returns an existing one with cleaned properties\n\t\t\tdataNode[ND].objects.target = parentNode[ND].objects.target[ targetProperty ]; //assign said 'target' to the dataNode\n\t\t}\n\n\t\tlet objects = dataNode[ND].objects; //a new one for every iteration\n\t\tlet target = objects.target;\n\n\t\tlet typeoftarget = realtypeof(target);\n\n\t\tif(proxyTypes.includes(typeoftarget)) {\n\t\t\tlet revocable = Proxy.revocable(target, {\n\t\t\t\tget: (target/*same as parent scope 'target'*/, property, proxy) => {\n\t\t\t\t\tif(this.emitMethods && proxyMethods.hasOwnProperty(property) && property in Object.getPrototypeOf(target)) {\n\t\t\t\t\t\t//use a proxy method instead of the built-in method that is on the prototype chain\n\t\t\t\t\t\treturn proxyMethods[property].bind(this, dataNode, objects);\n\t\t\t\t\t}\n\t\t\t\t\telse if(pseudoMethodsNames.includes(property) && typeof target[property] === 'undefined') {\n\t\t\t\t\t\t//can access a pseudo function (or its synonym) if their keywords isn't used\n\t\t\t\t\t\treturn pseudoMethods[property].bind(this, dataNode, objects);\n\t\t\t\t\t}\n\t\t\t\t\telse if(!target.propertyIsEnumerable(property) || typeof property === 'symbol') {\n\t\t\t\t\t\treturn target[property]; //non-enumerable or non-path'able aren't proxied\n\t\t\t\t\t}\n\t\t\t\t\telse if(dataNode[property] //there's a child node\n\t\t\t\t\t\t\t&& dataNode[property][ND].objects.proxy //it holds a proxy\n\t\t\t\t\t\t\t&& dataNode[property][ND].objects.status === proxyStatuses.ALIVE) {\n\t\t\t\t\t\treturn dataNode[property][ND].objects.proxy;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn target[property];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\n\t\t\t\tset: (target/*same as parent scope 'target'*/, property, value, proxy) => { //'receiver' is proxy\n\t\t\t\t\t/**\n\t\t\t\t\t * property can be a regular object because of 3 possible reasons:\n\t\t\t\t\t * 1. proxy is deleted from tree but user keeps accessing it then it means he saved a reference\n\t\t\t\t\t * 2. it is a non-enumerable property which means it was intentionally hidden\n\t\t\t\t\t * 3. property is a symbol and symbols can't be proxied because we can't create a normal path for them.\n\t\t\t\t\t *    these properties are not proxied and should not emit change-event.\n\t\t\t\t\t *    except for: length\n\t\t\t\t\t * TODO - make a list of all possible properties exceptions (maybe function 'name'?)\n\t\t\t\t\t */\n\t\t\t\t\tif(dataNode[NID].status === nodeStatuses.BLOCKED) { //blocked from changing values\n\t\t\t\t\t\tconsole.error(`can't change value of property '${property}'. object is blocked.`);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(typeof property === 'symbol') {\n\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(property !== 'length' && !target.propertyIsEnumerable(property)) {\n\t\t\t\t\t\t//if setting a whole new property then it is non-enumerable (yet) so a further test is needed\n\t\t\t\t\t\tlet descriptor = Object.getOwnPropertyDescriptor(target, property);\n\t\t\t\t\t\tif(typeof descriptor === 'object' && descriptor.enumerable === false) { //property was previously set\n\t\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet oldValue = target[property]; //should not be proxy\n\t\t\t\t\tlet isOldValueProxy = false;\n\t\t\t\t\tif(dataNode[property] !== undefined && dataNode[property][ND].objects.proxy !== undefined) {\n\t\t\t\t\t\t//about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\tdataNode[property][ND].objects.status = proxyStatuses.DELETED;\n\t\t\t\t\t\tisOldValueProxy = true;\n\t\t\t\t\t\tif(this.strict) {\n\t\t\t\t\t\t\t//postpone this cpu intense function for later, probably when proxserve is not in use\n\t\t\t\t\t\t\tsetTimeout(Proxserve.destroy, this.destroyDelay, dataNode[property][ND].objects.proxy); \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue = unproxify(value);\n\t\t\t\t\ttarget[property] = value; //assign new value\n\n\t\t\t\t\tlet isValueProxy = false;\n\t\t\t\t\tlet typeofvalue = realtypeof(value);\n\t\t\t\t\tif(proxyTypes.includes(typeofvalue)) {\n\t\t\t\t\t\tthis.createProxy(dataNode, property); //if trying to add a new value which is an object then make it a proxy\n\t\t\t\t\t\tisValueProxy = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tinitEmitEvent(dataNode, property, oldValue, isOldValueProxy, value, isValueProxy);\n\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\t/**\n\t\t\t\t * TODO - this function is incomplete and doesn't handle all of 'descriptor' scenarios\n\t\t\t\t */\n\t\t\t\tdefineProperty: (target/*same as parent scope 'target'*/, property, descriptor) => {\n\t\t\t\t\tif(typeof property === 'symbol') {\n\t\t\t\t\t\tObject.defineProperty(target, property, descriptor);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet oldValue = target[property]; //should not be proxy\n\t\t\t\t\tlet isOldValueProxy = false;\n\t\t\t\t\tif(dataNode[property] !== undefined && dataNode[property][ND].objects.proxy !== undefined) {\n\t\t\t\t\t\t//about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\tdataNode[property][ND].objects.status = proxyStatuses.DELETED;\n\t\t\t\t\t\tisOldValueProxy = true;\n\t\t\t\t\t\tif(this.strict) {\n\t\t\t\t\t\t\t//postpone this cpu intense function for later, probably when proxserve is not is use\n\t\t\t\t\t\t\tsetTimeout(Proxserve.destroy, this.destroyDelay, dataNode[property][ND].objects.proxy);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdescriptor.value = unproxify(descriptor.value);\n\t\t\t\t\tObject.defineProperty(target, property, descriptor); //defining the new value\n\t\t\t\t\tlet value = descriptor.value;\n\t\t\t\t\tlet isValueProxy = false;\n\t\t\t\t\t//excluding non-enumerable properties from being proxied\n\t\t\t\t\tlet typeofvalue = realtypeof(descriptor.value);\n\t\t\t\t\tif(proxyTypes.includes(typeofvalue) && descriptor.enumerable === true) {\n\t\t\t\t\t\tthis.createProxy(dataNode, property); //if trying to add a new value which is an object then make it a proxy\n\t\t\t\t\t\tisValueProxy = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tinitEmitEvent(dataNode, property, oldValue, isOldValueProxy, value, isValueProxy);\n\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\tdeleteProperty: (target/*same as parent scope 'target'*/, property) => {\n\t\t\t\t\tif(!target.propertyIsEnumerable(property) || typeof property === 'symbol') {\n\t\t\t\t\t\t//non-proxied properties simply get deleted and nothing more\n\t\t\t\t\t\tdelete target[property];\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dataNode[NID].status === nodeStatuses.BLOCKED) { //blocked from changing values\n\t\t\t\t\t\tconsole.error(`can't delete property '${property}'. object is blocked.`);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(property in target) {\n\t\t\t\t\t\tlet oldValue = target[property]; //should not be proxy\n\t\t\t\t\t\tlet isOldValueProxy = false;\n\t\t\t\t\t\tif(dataNode[property] !== undefined && dataNode[property][ND].objects.proxy !== undefined) {\n\t\t\t\t\t\t\t//about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\t\tdataNode[property][ND].objects.status = proxyStatuses.DELETED;\n\t\t\t\t\t\t\tisOldValueProxy = true;\n\t\t\t\t\t\t\tif(this.strict) {\n\t\t\t\t\t\t\t\t//postpone this cpu intense function for later, probably when proxserve is not is use\n\t\t\t\t\t\t\t\tsetTimeout(Proxserve.destroy, this.destroyDelay, dataNode[property][ND].objects.proxy);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete target[property]; //actual delete\n\n\t\t\t\t\t\tinitEmitEvent(dataNode, property, oldValue, isOldValueProxy, undefined, false);\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn true; //do nothing because there's nothing to delete\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tdataNode[ND].objects.proxy = revocable.proxy;\n\t\t\tdataNode[ND].objects.revoke = revocable.revoke;\n\n\t\t\tif(typeoftarget === 'Object') {\n\t\t\t\tlet keys = Object.keys(target);\n\t\t\t\tfor(let key of keys) {\n\t\t\t\t\tlet typeofproperty = realtypeof(target[key]);\n\t\t\t\t\tif(proxyTypes.includes(typeofproperty)) {\n\t\t\t\t\t\tthis.createProxy(dataNode, key); //recursively make child objects also proxies\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(typeoftarget === 'Array') {\n\t\t\t\tfor(let i = 0; i < target.length; i++) {\n\t\t\t\t\tlet typeofproperty = realtypeof(target[i]);\n\t\t\t\t\tif(proxyTypes.includes(typeofproperty)) {\n\t\t\t\t\t\tthis.createProxy(dataNode, i); //recursively make child objects also proxies\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconsole.warn('Not Implemented');\n\t\t\t}\n\n\t\t\treturn revocable.proxy;\n\t\t}\n\t\telse {\n\t\t\tthrow new Error('Must observe an '+proxyTypes.join('/'));\n\t\t}\n\t}\n\n\t/**\n\t * Recursively revoke proxies, allowing them to be garbage collected.\n\t * this functions delays 1000 milliseconds to let time for all events to finish\n\t * @param {*} proxy \n\t */\n\tstatic destroy(proxy) {\n\t\tlet dataNode, objects;\n\t\ttry {\n\t\t\tdataNode = proxy.$getProxserveDataNode();\n\t\t\tobjects = proxy.$getProxserveObjects();\n\t\t} catch(error) {\n\t\t\treturn; //proxy variable isn't a proxy\n\t\t}\n\n\t\tif(objects.status === proxyStatuses.ALIVE) {\n\t\t\tobjects.status = proxyStatuses.DELETED;\n\t\t}\n\n\t\tlet typeofproxy = realtypeof(proxy);\n\n\t\tif(proxyTypes.includes(typeofproxy)) {\n\t\t\tlet keys = Object.keys(proxy); //handles both Objects and Arrays\n\t\t\tfor(let key of keys) {\n\t\t\t\ttry {\n\t\t\t\t\tlet typeofproperty = realtypeof(proxy[key]);\n\t\t\t\t\tif(proxyTypes.includes(typeofproperty)) {\n\t\t\t\t\t\tProxserve.destroy(dataNode[key][ND].objects.proxy);\n\t\t\t\t\t}\n\t\t\t\t} catch(error) {\n\t\t\t\t\tconsole.error(error); //don't throw and kill the whole process just if this iteration fails\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tobjects.revoke();\n\t\t\tobjects.proxy = undefined;\n\t\t\tobjects.status = proxyStatuses.REVOKED;\n\t\t}\n\t\telse {\n\t\t\tconsole.warn(`Type of \"${typeofproxy}\" is not implemented`);\n\t\t}\n\t}\n\n\tstatic splitPath(path) {\n\t\treturn splitPath(path);\n\t}\n\n\tstatic evalPath(obj, path) {\n\t\treturn evalPath(obj, path);\n\t}\n}\n\nmodule.exports = exports = Proxserve; //makes ParcelJS expose this globally (for all platforms) after bundling everything"]}