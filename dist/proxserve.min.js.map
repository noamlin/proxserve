{"version":3,"sources":["general-functions.js","supporting-functions.js","reserved-methods.js","index.js"],"names":["realtypeof","variable","rawType","Object","prototype","toString","call","substring","length","simpleCloneSet","WeakSet","simpleClone","obj","typeofobj","cloned","add","keys","key","has","i","console","warn","splitPath","path","betweenBrackets","onlyDigits","resultsArr","tmp","char","push","parseInt","code","charCodeAt","evalPath","object","property","undefined","value","segments","Error","acceptableTypes","acceptableEvents","statuses","ND","Symbol","for","NID","property2path","add2emitQueue","delay","dataNode","oldValue","changeType","listeners","change","eventPool","emit","setTimeout","add2emitQueue_bubble","wasOldValueProxy","isValueProxy","objects","isDeleted","add2emitQueue_capture","target","status","parentNode","isTreePrototype","propertyPath","subValue","subOldValue","listener","type","splice","proxy","unproxify","typeofvalue","includes","$getOriginalTarget","error","createDataNode","node","create","assign","stop","block","activate","dataTree","on","events","id","once","Array","isArray","event","join","removeListener","arguments","fullPath","removeAllListeners","getOriginalTarget","getProxserveObjects","getProxserveDataNode","getProxserveInstance","reservedMethodsNames","reservedMethods","name","synonym","Proxserve","options","strict","emitReference","createProxy","targetProperty","typeoftarget","revocable","Proxy","get","bind","propertyIsEnumerable","getPrototypeOf","set","descriptor","getOwnPropertyDescriptor","enumerable","emitOldValue","shouldDestroy","emitValue","destroy","defineProperty","deleteProperty","revoke","typeofproperty","$getProxserveObjects","typeofproxy","module","exports"],"mappings":"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","file":"proxserve.min.js","sourceRoot":"../src","sourcesContent":["/**\n * Copyright 2020 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\n/**\n * return a string representing the full type of the variable\n * @param {*} variable \n * @returns {String} - Object, Array, Number, String, Boolean, Null, Undefined, BigInt, Symbol, Date ...\n */\nexport function realtypeof(variable) {\n\tlet rawType = Object.prototype.toString.call(variable); //[object Object], [object Array], [object Number] ...\n\treturn rawType.substring(8, rawType.length - 1);\n}\n\n/**\n * check if variable is a number or a string of a number\n * @param {*} variable \n */\n/*export function isNumeric(variable) {\n\tif(typeof variable === 'string' && variable === '') return false;\n\telse return !isNaN(variable);\n}*/\n\n/**\n * recursively clones objects and array\n * @param {Proxy|Object|Array} proxy \n */\nlet simpleCloneSet = new WeakSet();\nexport function simpleClone(obj) {\n\tlet typeofobj = realtypeof(obj);\n\tlet cloned;\n\tif(typeofobj === 'Object') {\n\t\tsimpleCloneSet.add(obj);\n\t\tcloned = {};\n\t\tlet keys = Object.keys(obj);\n\t\tfor(let key of keys) {\n\t\t\tif(simpleCloneSet.has(obj[key])) {\n\t\t\t\tcloned[key] = obj[key];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcloned[key] = simpleClone(obj[key]);\n\t\t\t}\n\t\t}\n\t}\n\telse if(typeofobj === 'Array') {\n\t\tsimpleCloneSet.add(obj);\n\t\tcloned = [];\n\t\tfor(let i = 0; i < obj.length; i++) {\n\t\t\tif(simpleCloneSet.has(obj[i])) {\n\t\t\t\tcloned[i] = obj[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcloned[i] = simpleClone(obj[i]);\n\t\t\t}\n\t\t}\n\t}\n\telse { //hopefully a primitive\n\t\tcloned = obj;\n\n\t\tif(typeofobj !== 'Undefined' && typeofobj !== 'Null' && typeofobj !== 'Boolean' && typeofobj !== 'Number'\n\t\t&& typeofobj !== 'BigInt' && typeofobj !== 'String') {\n\t\t\tconsole.warn(`Can't clone a variable of type ${typeofobj}`);\n\t\t}\n\t}\n\n\treturn cloned;\n}\n\n/**\n * splits a path to an array of properties\n * (benchmarked and is faster than regex and split())\n * @param {String} path \n */\nexport function splitPath(path) {\n\tif(typeof path !== 'string' || path === '') {\n\t\treturn [];\n\t}\n\t\n\tlet i = 0, betweenBrackets = false, onlyDigits = false;\n\t//loop will skip over openning '.' or '['\n\tif(path[0] === '.') {\n\t\ti = 1;\n\t} else if(path[0] === '[') {\n\t\ti = 1;\n\t\tbetweenBrackets = true;\n\t\tonlyDigits = true;\n\t}\n\n\tlet resultsArr = [];\n\tlet tmp='';\n\tfor(; i < path.length; i++) {\n\t\tlet char = path[i];\n\n\t\tif(betweenBrackets) {\n\t\t\tif(char === ']') {\n\t\t\t\tif(onlyDigits) resultsArr.push(parseInt(tmp, 10));\n\t\t\t\telse resultsArr.push(tmp);\n\n\t\t\t\tbetweenBrackets = false;\n\t\t\t\tonlyDigits = false;\n\t\t\t\ttmp = '';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(onlyDigits) {\n\t\t\t\t\tlet code = char.charCodeAt(0);\n\t\t\t\t\tif(code < 48 || code > 57) { //less than '0' char or greater than '9' char\n\t\t\t\t\t\tonlyDigits = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp += char;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(char === '[') {\n\t\t\t\tbetweenBrackets = true;\n\t\t\t\tonlyDigits = true;\n\t\t\t}\n\t\t\t\n\t\t\t//check if starting a new property but avoid special case of [prop][prop]\n\t\t\tif(char === '.' || char === '[') {\n\t\t\t\tif(tmp !== '') {\n\t\t\t\t\tresultsArr.push(tmp);\n\t\t\t\t\ttmp = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttmp += char;\n\t\t\t}\n\t\t}\n\t}\n\tif(tmp!=='') {\n\t\tresultsArr.push(tmp);\n\t}\n\treturn resultsArr;\n}\n\n/**\n * evaluate a long path and return the designated object and its referred property\n * @param {Object} obj\n * @param {String} path\n * @returns {Object} - returns {object, property, value}\n */\nexport function evalPath(obj, path) {\n\tif(path === '') {\n\t\treturn { object: obj, property: undefined, value: obj };\n\t}\n\n\tlet segments = splitPath(path);\n\tlet i;\n\tfor(i = 0; i <= segments.length - 2; i++) { //iterate until one before last property because they all must exist\n\t\tobj = obj[segments[i]];\n\t\tif(typeof obj === 'undefined') {\n\t\t\tthrow new Error(`Invalid path was given - \"${path}\"`);\n\t\t}\n\t}\n\treturn { object: obj, property: segments[i], value: obj[ segments[i] ] };\n}","/**\n * Copyright 2020 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nimport { realtypeof } from './general-functions.js';\n\nexport let acceptableTypes = ['Object', 'Array', 'Map']; //acceptable types to be proxied\nexport let acceptableEvents = ['change', 'create', 'update', 'delete'];\nexport let statuses = ['active', 'stopped', 'blocked']; //statuses of proxies\n\nlet ND = Symbol.for('proxserve_node_data'); //key for the data of a node\nlet NID = Symbol.for('proxserve_node_inherited_data'); //key for the inherited data of a node\n\n/**\n * Convert property name to valid path segment\n * @param {*} obj \n * @param {String} property \n */\nexport function property2path(obj, property) {\n\tif(typeof property === 'symbol') {\n\t\tthrow new Error(`property of type \"symbol\" isn't path'able`);\n\t}\n\n\tlet typeofobj = realtypeof(obj);\n\tswitch(typeofobj) {\n\t\tcase 'Object': return `.${property}`;\n\t\tcase 'Array': return `[${property}]`;\n\t\tdefault: console.warn(`Not Implemented (type of '${typeofobj}')`); return property;\n\t}\n}\n\n/**\n * add change-events to a queue and then emits them immediately or later as a batch\n * @param {Number} delay \n * @param {Object} dataNode \n * @param {String} path\n * @param {*} oldValue \n * @param {*} value \n * @param {String} changeType\n */\nexport function add2emitQueue(delay, dataNode, path, oldValue, value, changeType) {\n\tif(dataNode[ND].listeners && dataNode[ND].listeners.length > 0) {\n\t\tlet change = {\n\t\t\t'path': path, 'value': value, 'oldValue': oldValue, 'type': changeType\n\t\t};\n\t\tdataNode[ND].eventPool.push(change);\n\n\t\tif(delay <= 0) {\n\t\t\temit(dataNode); //emit immediately\n\t\t}\n\t\telse if(dataNode[ND].eventPool.length === 1) {\n\t\t\tsetTimeout(emit, delay, dataNode); //initiate timeout once, when starting to accumulate events\n\t\t}\n\t}\n}\n\n/**\n * bubbles up the data tree for 'add2emitQueue'\n * @param {Number} delay\n * @param {Object} dataNode\n * @param {String} property\n * @param {*} oldValue\n * @param {Boolean} wasOldValueProxy\n * @param {*} value\n * @param {Boolean} isValueProxy\n */\nexport function add2emitQueue_bubble(delay, dataNode, property, oldValue, wasOldValueProxy, value, isValueProxy) {\n\tif(oldValue === value/*no new change was made*/\n\t\t|| dataNode[ND].objects.isDeleted/*altered a deleted or detached proxy*/) {\n\t\treturn;\n\t}\n\n\tlet changeType = acceptableEvents[2]; //update\n\tif(value === undefined) changeType = acceptableEvents[3]; //delete\n\telse if(oldValue === undefined) changeType = acceptableEvents[1]; //create\n\n\tlet path;\n\tif(dataNode[property]) { //changed a property which has its own data node on the tree\n\t\tdataNode = dataNode[property];\n\t\tpath = '';\n\n\t\tif(wasOldValueProxy || isValueProxy) {\n\t\t\tadd2emitQueue_capture(delay, dataNode, oldValue, value, changeType);\n\t\t}\n\t} else {\n\t\tpath = property2path(dataNode[ND].objects.target, property);\n\t}\n\n\twhile(true) {\n\t\tif(dataNode[NID].status === statuses[1]) { //stop and don't propagate\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tadd2emitQueue(delay, dataNode, path, oldValue, value, changeType);\n\t\t}\n\n\t\tif(!dataNode[ND].parentNode.isTreePrototype) { //we are not on root node yet\n\t\t\tpath = dataNode[ND].propertyPath + path;\n\t\t\tdataNode = dataNode[ND].parentNode;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * capturing phase - going down the data tree for 'add2emitQueue'\n * @param {Number} delay \n * @param {Object} dataNode - traverse down this node\n * @param {*} oldValue \n * @param {*} value \n */\nexport function add2emitQueue_capture(delay, dataNode, oldValue, value) {\n\tlet keys = Object.keys(dataNode);\n\tfor(let key of keys) {\n\t\tlet subValue = (typeof value === 'object' && value !== null) ? value[key] : undefined;\n\t\tlet subOldValue = (typeof oldValue === 'object' && oldValue !== null) ? oldValue[key] : undefined;\n\t\tif(subValue !== subOldValue) { //if not both undefined or same primitive or the same object\n\t\t\t//TODO - both will never be the same object because 'oldValue' is the target object while 'value' is the proxy,\n\t\t\t//\t\t\tbut can a concerning scenario even happen?\n\t\t\tlet changeType = acceptableEvents[2]; //update\n\t\t\tif(subValue === undefined) changeType = acceptableEvents[3]; //delete\n\t\t\telse if(subOldValue === undefined) changeType = acceptableEvents[1]; //create\n\t\t\tadd2emitQueue(delay, dataNode[key], '', subOldValue, subValue, changeType);\n\t\t\tadd2emitQueue_capture(delay, dataNode[key], subOldValue, subValue);\n\t\t}\n\t}\n}\n\nexport function emit(dataNode) {\n\t//save a reference to the event-pool because we are about to immediately empty it, so all future changes, even those\n\t//that can occur now because of the listeners, will go to a new event-pool and will be emitted next round (after delay).\n\t//NOTICE - an event listener for one path can still manipulate event-pools of other path's that are next on this cycle\n\tlet listeners = dataNode[ND].listeners;\n\tlet eventPool = dataNode[ND].eventPool;\n\tdataNode[ND].eventPool = [];\n\n\tif(!listeners || !eventPool) {\n\t\t//rare case where an event triggers a listener that removed-all-listeners and also causes a new event\n\t\t//before all emits of this loop have finished\n\t\treturn;\n\t}\n\n\t//FIFO - first event in, first event out. listeners will be called by their turn according to which event fires first\n\tfor(let change of eventPool) {\n\t\tfor(let i = listeners.length-1; i >= 0; i--) {\n\t\t\tlet listener = listeners[i]; //listener = [event, function, id, once]\n\n\t\t\tif(listener[0] === change.type) { //will invoke only create/update/delete listeners\n\t\t\t\tif(listener[3] === true) { //first delete the one-time listener, so the upcoming listener's-function won't meddle with it\n\t\t\t\t\tlisteners.splice(i, 1);\n\t\t\t\t}\n\n\t\t\t\tlistener[1].call(dataNode[ND].objects.proxy, change);\n\t\t\t}\n\t\t}\n\t}\n\n\t//iterate over all 'change' listeners and emit with an (ordered) array of all events\n\tfor(let i = listeners.length-1; i >= 0; i--) {\n\t\tlet listener = listeners[i]; //listener = [event, function, id, once]\n\n\t\tif(listener[0] === acceptableEvents[0]) { // 'change'\n\t\t\tif(listener[3] === true) { //first delete the one-time listener, so the upcoming listener's-function won't meddle with it\n\t\t\t\tlisteners.splice(i, 1);\n\t\t\t}\n\n\t\t\tlistener[1].call(dataNode[ND].objects.proxy, eventPool); //on(change) is always called with an array of one or more changes\n\t\t}\n\t}\n}\n\n/**\n * recursively switch between all proxies to their original targets.\n * note: original targets should never hold proxies under them,\n * thus altering the object references (getting from 'value') should be ok.\n * if the programmer decided to\n * \t1. create a proxy with children (sub-proxies)\n * \t2. create a regular object\n * \t3. adding sub-proxies to the regular object\n * \t4. attaching the regular object to the proxy\n * then this regular object will be altered.\n * @param {*} value\n */\nexport function unproxify(value) {\n\tlet typeofvalue = realtypeof(value);\n\tif(acceptableTypes.includes(typeofvalue)) {\n\t\tlet target = value;\n\t\ttry {\n\t\t\ttarget = value.$getOriginalTarget();\n\t\t} catch(error) {}\n\n\t\tswitch(typeofvalue) {\n\t\t\tcase 'Object':\n\t\t\t\tlet keys = Object.keys(target);\n\t\t\t\tfor(let key of keys) {\n\t\t\t\t\ttarget[key] = unproxify(target[key]); //maybe alters target and maybe returning the exact same object\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'Array':\n\t\t\t\tfor(let i=0; i < target.length; i++) {\n\t\t\t\t\ttarget[i] = unproxify(target[i]); //maybe alters target and maybe returning the exact same object\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.warn(`Not Implemented (type of '${typeofobj}')`);\n\t\t}\n\n\t\treturn target;\n\t}\n\telse {\n\t\treturn value; //primitive\n\t}\n}\n\n/**\n * create a node in a tree that mimics the proxserve's object and holds meta-data\n * @param {Object} parentNode \n * @param {String|Number} property \n */\nexport function createDataNode(parentNode, property) {\n\tlet propertyPath;\n\tif(parentNode[ND] && parentNode[ND].objects && parentNode[ND].objects.target) {\n\t\tpropertyPath = property2path(parentNode[ND].objects.target, property);\n\t} else {\n\t\tpropertyPath = property2path({}, property); //if parent doesn't have target then treat it as object\n\t}\n\t\n\tlet node = parentNode[property];\n\tif(!node) {\n\t\tnode = {\n\t\t\t[NID]: Object.create(parentNode[NID]),\n\t\t\t[ND]: {\n\t\t\t\t'parentNode': parentNode\n\t\t\t}\n\t\t};\n\t\tparentNode[property] = node;\n\t}\n\n\tdelete node[NID].status; //clears old status in case a node previously existed\n\t//updates path (for rare case where parent was array and then changed to object or vice versa)\n\t//and also makes a new and clean 'objects' property\n\tObject.assign(node[ND], {\n\t\t'path': parentNode[ND].path + propertyPath,\n\t\t'propertyPath': propertyPath,\n\t\t'objects': Object.assign(Object.create(parentNode[ND].objects), {\n\t\t\t'target': null,\n\t\t\t'proxy': null\n\t\t})\n\t});\n\n\treturn node;\n}\n","/**\n * Copyright 2020 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nimport { acceptableEvents, statuses, createDataNode } from './supporting-functions.js';\nimport { splitPath } from './general-functions.js';\n\nlet ND = Symbol.for('proxserve_node_data'); //key for the data of a node\nlet NID = Symbol.for('proxserve_node_inherited_data'); //key for the inherited data of a node\n\n/**\n * stop object and children from emitting change events\n * @param {Object} dataNode\n */\nexport function stop(dataNode) {\n\tdataNode[NID].status = statuses[1];\n}\n\n/**\n * block object and children from any changes.\n * user can't set nor delete any property\n * @param {Object} dataNode\n */\nexport function block(dataNode) {\n\tdataNode[NID].status = statuses[2];\n}\n\n/**\n * resume default behavior of emitting change events, inherited from parent\n * @param {Object} dataNode\n * @param {Object} objects\n * @param {Boolean} [force] - force being active regardless of parent\n */\nexport function activate(dataNode, objects, force=false) {\n\tif(force || dataNode === this.dataTree) { //force activation or we are on root proxy\n\t\tdataNode[NID].status = statuses[0];\n\t}\n\telse {\n\t\tdelete dataNode[NID].status;\n\t}\n}\n\n/**\n * add event listener on a proxy or on a descending path\n * @param {Object} dataNode\n * @param {Object} objects\n * @param {String|Array.String} events\n * @param {String} [path] - path selector\n * @param {Function} listener \n * @param {String} [id] - identifier for removing this listener\n * @param {Boolean} [once] - whether this listener will run only once or always\n */\nexport function on(dataNode, objects, events, path, listener, id, once=false) {\n\tif(!Array.isArray(events)) events = [events];\n\n\tfor(let event of events) {\n\t\tif(!acceptableEvents.includes(event)) {\n\t\t\tthrow new Error(`${event} is not a valid event. valid events are ${acceptableEvents.join(',')}`);\n\t\t}\n\t}\n\t\n\tif(typeof path === 'function') { //if called without path\n\t\tid = listener;\n\t\tlistener = path;\n\t\tpath = '';\n\t} else if(typeof listener !== 'function') {\n\t\tthrow new Error(`invalid arguments were given. listener must be a function`);\n\t}\n\t\n\tlet segments = splitPath(path);\n\t//traverse down the tree. create data-nodes if needed\n\tfor(let property of segments) {\n\t\tif(!dataNode[property]) {\n\t\t\tcreateDataNode(dataNode, property);\n\t\t}\n\t\tdataNode = dataNode[property];\n\t}\n\n\tif(!dataNode[ND].listeners) {\n\t\tdataNode[ND].listeners = [];\n\t\tdataNode[ND].eventPool = [];\n\t}\n\tfor(let event of events) {\n\t\tdataNode[ND].listeners.push([event, listener, id, once]);\n\t}\n}\n\n/**\n * add event listener on a proxy or on a descending path which will run only once\n * @param {Object} dataNode\n * @param {Object} objects\n * @param {String|Array.String} events\n * @param {String} [path] - path selector\n * @param {Function} listener \n * @param {String} [id] - identifier for removing this listener\n */\nexport function once(dataNode, objects, events, path, listener, id) {\n\ton.call(this, dataNode, objects, events, path, listener, id, true);\n}\n\n/**\n * removes a listener from a path by an identifier (can have multiple listeners with the same ID)\n * or by the listener function itself\n * @param {Object} dataNode\n * @param {Object} objects\n * @param {String} [path] - path selector\n * @param {String} id - the listener(s) identifier or listener-function\n */\nexport function removeListener(dataNode, objects, path, id) {\n\tif(arguments.length === 3) { //if called without path\n\t\tid = path;\n\t\tpath = '';\n\t}\n\n\tlet fullPath = `${dataNode[ND].path}${path}`;\n\tlet segments = splitPath(path);\n\t//traverse down the tree\n\tfor(let property of segments) {\n\t\tif(!dataNode[property]) {\n\t\t\tconsole.warn(`can't remove listener from a non-existent path '${fullPath}'`);\n\t\t\treturn;\n\t\t}\n\t\tdataNode = dataNode[property];\n\t}\n\n\tif(dataNode[ND].listeners) {\n\t\tlet listeners = dataNode[ND].listeners;\n\t\n\t\tfor(let i = listeners.length - 1; i >= 0; i--) {\n\t\t\tif((typeof id !== 'function' && listeners[i][2] === id)\n\t\t\t|| (typeof id === 'function' && listeners[i][1] === id)) {\n\t\t\t\tlisteners.splice(i, 1);\n\t\t\t}\n\t\t}\n\n\t\tif(listeners.length === 0) {\n\t\t\tdelete dataNode[ND].listeners;\n\t\t\tdelete dataNode[ND].eventPool;\n\t\t}\n\t}\n}\n\n/**\n * removing all listeners of a path\n * @param {Object} dataNode\n * @param {Object} objects\n * @param {String} [path] - path selector\n */\nexport function removeAllListeners(dataNode, objects, path='') {\n\tlet fullPath = `${dataNode[ND].path}${path}`;\n\tlet segments = splitPath(path);\n\t//traverse down the tree\n\tfor(let property of segments) {\n\t\tif(!dataNode[property]) {\n\t\t\tconsole.warn(`can't remove all listeners from a non-existent path '${fullPath}'`);\n\t\t\treturn;\n\t\t}\n\t\tdataNode = dataNode[property];\n\t}\n\n\tif(dataNode[ND].listeners) {\n\t\tdelete dataNode[ND].listeners;\n\t\tdelete dataNode[ND].eventPool;\n\t}\n}\n\n/**\n * the following functions (getOriginalTarget, getProxserveObjects, getProxserveDataNode, getProxserveInstance) seem silly\n * because they could have been written directly on the handler's get() method but it's here as part of the convention of\n * exposing proxy-\"inherited\"-methods\n */\n/**\n * get original target that is behind the proxy\n * @param {Object} dataNode\n * @param {Object} objects\n */\nexport function getOriginalTarget(dataNode, objects) {\n\treturn objects.target;\n}\n\n/**\n * get 'objects' (which hold all related objects) of a proxy\n * @param {Object} dataNode\n * @param {Object} objects\n */\nexport function getProxserveObjects(dataNode, objects) {\n\treturn objects;\n}\n\n/**\n * get the data-node of the proxy or sub-proxy\n * @param {Object} dataNode\n */\nexport function getProxserveDataNode(dataNode) {\n\treturn dataNode;\n}\n\n/**\n * get the Proxserve's instance that created this proxy\n */\nexport function getProxserveInstance() {\n\treturn this;\n}\n","/**\n * Copyright 2020 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nimport { acceptableTypes, statuses, add2emitQueue_bubble, unproxify, createDataNode } from './supporting-functions.js';\nimport * as reservedMethods from './reserved-methods.js';\nimport { realtypeof, simpleClone, splitPath, evalPath } from './general-functions.js';\n\nlet ND = Symbol.for('proxserve_node_data'); //key for the data of a node\nlet NID = Symbol.for('proxserve_node_inherited_data'); //key for the inherited data of a node\n\n/**\n * save an array of all reserved function names\n * and also add synonyms to these functions\n */\nlet reservedMethodsNames = Object.keys(reservedMethods);\nfor(let i = reservedMethodsNames.length - 1; i >= 0; i--) {\n\tlet name = reservedMethodsNames[i];\n\tlet synonym = '$'+name;\n\treservedMethods[synonym] = reservedMethods[name];\n\treservedMethodsNames.push(synonym);\n}\n\nclass Proxserve {\n\t/**\n\t * construct a new proxserve instance\n\t * @param {Object|Array} target \n\t * @param {Object} [options] \n\t * \t@property {Number} [options.delay] - delay change-event emitting in milliseconds, letting them pile up and then fire all at once\n\t * \t@property {Boolean} [options.strict] - should destroy detached child-objects or deleted properties automatically\n\t * \t@property {Boolean} [options.emitReference] - events emit new/old values. true: reference to original objects, false: deep clones that are created on the spot\n\t */\n\tconstructor(target, options = {}) {\n\t\tthis.delay = (options.delay !== undefined) ? options.delay : 10;\n\t\tthis.strict = (options.strict !== undefined) ? options.strict : true;\n\t\tthis.emitReference = (options.emitReference !== undefined) ? options.emitReference : false;\n\n\t\tthis.dataTree = createDataNode({\n\t\t\t[NID]: { 'status': statuses[0] },\n\t\t\t[ND]: { 'objects': { 'isDeleted': false } },\n\t\t\t'isTreePrototype': true\n\t\t}, '');\n\t\tthis.dataTree[ND].path = '';\n\t\tthis.dataTree[ND].propertyPath = '';\n\t\tthis.dataTree[ND].objects.target = target;\n\n\t\treturn this.createProxy(this.dataTree);\n\t}\n\n\t/**\n\t * create a new proxy and a new node for a property of the parent's target-object\n\t * @param {Object} parentNode\n\t * @param {String} [targetProperty]\n\t */\n\tcreateProxy(parentNode, targetProperty) {\n\t\tlet dataNode;\n\n\t\tif(targetProperty === undefined) { //refering to own node and not a child property (meaning root object)\n\t\t\tdataNode = parentNode;\n\t\t}\n\t\telse {\n\t\t\tdataNode = createDataNode(parentNode, targetProperty); //either creates new or returns an existing one with cleaned properties\n\t\t\tdataNode[ND].objects.target = parentNode[ND].objects.target[ targetProperty ]; //assign said 'target' to the dataNode\n\t\t}\n\n\t\tlet objects = dataNode[ND].objects; //a new one for every iteration\n\t\tlet target = objects.target;\n\n\t\tlet typeoftarget = realtypeof(target);\n\n\t\tif(acceptableTypes.includes(typeoftarget)) {\n\t\t\tlet revocable = Proxy.revocable(target, {\n\t\t\t\tget: (target/*same as parent scope 'target'*/, property, proxy) => {\n\t\t\t\t\t//can access a function (or its synonym) if their keywords isn't used\n\t\t\t\t\tif(reservedMethodsNames.includes(property) && typeof target[property] === 'undefined') {\n\t\t\t\t\t\treturn reservedMethods[property].bind(this, dataNode, objects);\n\t\t\t\t\t}\n\t\t\t\t\telse if(!target.propertyIsEnumerable(property) || typeof property === 'symbol') {\n\t\t\t\t\t\treturn target[property]; //non-enumerable or non-path'able aren't proxied\n\t\t\t\t\t}\n\t\t\t\t\telse if(dataNode[property] //there's a child node\n\t\t\t\t\t\t\t&& dataNode[property][ND].objects.proxy //it holds a proxy\n\t\t\t\t\t\t\t&& Object.getPrototypeOf(dataNode[property][ND].objects) === objects) { //is child of this proxy, and not a ghost object left there after deletion\n\t\t\t\t\t\treturn dataNode[property][ND].objects.proxy;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn target[property];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\n\t\t\t\tset: (target/*same as parent scope 'target'*/, property, value, proxy) => { //'receiver' is proxy\n\t\t\t\t\t/**\n\t\t\t\t\t * property can be a regular object because of 3 possible reasons:\n\t\t\t\t\t * 1. proxy is deleted from tree but user keeps accessing it then it means he saved a reference\n\t\t\t\t\t * 2. it is a non-enumerable property which means it was intentionally hidden\n\t\t\t\t\t * 3. property is a symbol and symbols can't be proxied because we can't create a normal path for them.\n\t\t\t\t\t *    these properties are not proxied and should not emit change-event.\n\t\t\t\t\t *    except for: length\n\t\t\t\t\t * TODO - make a list of all possible properties exceptions (maybe function 'name'?)\n\t\t\t\t\t */\n\t\t\t\t\tif(dataNode[NID].status === statuses[2]) { //blocked from changing values\n\t\t\t\t\t\tconsole.error(`can't change value of property '${property}'. object is blocked.`);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(typeof property === 'symbol') {\n\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(property !== 'length' && !target.propertyIsEnumerable(property)) {\n\t\t\t\t\t\t//if setting a whole new property then it is non-enumerable (yet) so a further test is needed\n\t\t\t\t\t\tlet descriptor = Object.getOwnPropertyDescriptor(target, property);\n\t\t\t\t\t\tif(typeof descriptor === 'object' && descriptor.enumerable === false) { //property was previously set\n\t\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet oldValue;\n\t\t\t\t\tlet emitOldValue = target[property]; //should not be proxy\n\t\t\t\t\tlet shouldDestroy = false;\n\t\t\t\t\tif(dataNode[property] !== undefined && dataNode[property][ND].objects.proxy !== undefined) {\n\t\t\t\t\t\t//about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\toldValue = dataNode[property][ND].objects.proxy; //the sub-proxy\n\t\t\t\t\t\tdataNode[property][ND].objects.isDeleted = true;\n\t\t\t\t\t\tif(this.strict) {\n\t\t\t\t\t\t\tshouldDestroy = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue = unproxify(value);\n\t\t\t\t\ttarget[property] = value; //assign new value\n\n\t\t\t\t\tlet emitValue = value; //currently not a proxy but this might change later\n\t\t\t\t\tlet isValueProxy = false;\n\t\t\t\t\tlet typeofvalue = realtypeof(value);\n\t\t\t\t\tif(acceptableTypes.includes(typeofvalue)) {\n\t\t\t\t\t\tthis.createProxy(dataNode, property); //if trying to add a new value which is an object then make it a proxy\n\t\t\t\t\t\temitValue = dataNode[property][ND].objects.proxy; //is a proxy\n\t\t\t\t\t\tisValueProxy = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!this.emitReference) { //deep copy with no proxies inside\n\t\t\t\t\t\temitValue = simpleClone(emitValue);\n\t\t\t\t\t\temitOldValue = simpleClone(emitOldValue);\n\t\t\t\t\t}\n\n\t\t\t\t\tadd2emitQueue_bubble(this.delay, dataNode, property, emitOldValue, oldValue!==undefined, emitValue, isValueProxy);\n\t\t\t\t\tif(shouldDestroy) {\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\tProxserve.destroy(oldValue);\n\t\t\t\t\t\t}, this.delay + 1000); //postpone this cpu intense function for later, probably when proxserve is not is use\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\t/**\n\t\t\t\t * TODO - this function is incomplete and doesn't handle all of 'descriptor' scenarios\n\t\t\t\t */\n\t\t\t\tdefineProperty: (target/*same as parent scope 'target'*/, property, descriptor) => {\n\t\t\t\t\tif(typeof property === 'symbol') {\n\t\t\t\t\t\tObject.defineProperty(target, property, descriptor);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet oldValue;\n\t\t\t\t\tlet emitOldValue = target[property]; //should not be proxy\n\t\t\t\t\tlet shouldDestroy = false;\n\t\t\t\t\tif(dataNode[property] !== undefined && dataNode[property][ND].objects.proxy !== undefined) {\n\t\t\t\t\t\t//about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\toldValue = dataNode[property][ND].objects.proxy; //the sub-proxy\n\t\t\t\t\t\tdataNode[property][ND].objects.isDeleted = true;\n\t\t\t\t\t\tif(this.strict) {\n\t\t\t\t\t\t\tshouldDestroy = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdescriptor.value = unproxify(descriptor.value);\n\t\t\t\t\tObject.defineProperty(target, property, descriptor); //defining the new value\n\t\t\t\t\tlet value = descriptor.value;\n\t\t\t\t\tlet emitValue = value; //currently not a proxy but this might change later\n\n\t\t\t\t\tlet isValueProxy = false;\n\t\t\t\t\t//excluding non-enumerable properties from being proxied\n\t\t\t\t\tlet typeofvalue = realtypeof(descriptor.value);\n\t\t\t\t\tif(acceptableTypes.includes(typeofvalue) && descriptor.enumerable === true) {\n\t\t\t\t\t\tthis.createProxy(dataNode, property); //if trying to add a new value which is an object then make it a proxy\n\n\t\t\t\t\t\tvalue = dataNode[property][ND].objects.proxy; //value is now the proxy, not the target\n\t\t\t\t\t\tisValueProxy = true;\n\t\t\t\t\t\temitValue = value; //is a proxy\n\t\t\t\t\t\tif(!this.emitReference) {\n\t\t\t\t\t\t\temitValue = simpleClone(emitValue);\n\t\t\t\t\t\t\temitOldValue = simpleClone(emitOldValue); //deep copy with no proxies inside\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tadd2emitQueue_bubble(this.delay, dataNode, property, emitOldValue, oldValue!==undefined, emitValue, isValueProxy);\n\t\t\t\t\tif(shouldDestroy) {\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\tProxserve.destroy(oldValue);\n\t\t\t\t\t\t}, this.delay + 1000); //postpone this cpu intense function for later, probably when proxserve is not is use\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\tdeleteProperty: (target/*same as parent scope 'target'*/, property) => {\n\t\t\t\t\tif(!target.propertyIsEnumerable(property) || typeof property === 'symbol') {\n\t\t\t\t\t\t//non-proxied properties simply get deleted and nothing more\n\t\t\t\t\t\tdelete target[property];\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dataNode[NID].status === statuses[2]) { //blocked from changing values\n\t\t\t\t\t\tconsole.error(`can't delete property '${property}'. object is blocked.`);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(property in target) {\n\t\t\t\t\t\tlet oldValue;\n\t\t\t\t\t\tlet emitOldValue = target[property]; //should not be proxy\n\t\t\t\t\t\tif(!this.emitReference) {\n\t\t\t\t\t\t\temitOldValue = simpleClone(emitOldValue); //deep copy with no proxies inside\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet shouldDestroy = false;\n\t\t\t\t\t\tif(dataNode[property] !== undefined && dataNode[property][ND].objects.proxy !== undefined) {\n\t\t\t\t\t\t\t//about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\t\toldValue = dataNode[property][ND].objects.proxy; //the sub-proxy\n\t\t\t\t\t\t\tdataNode[property][ND].objects.isDeleted = true;\n\t\t\t\t\t\t\tif(this.strict) {\n\t\t\t\t\t\t\t\tshouldDestroy = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete target[property]; //actual delete\n\n\t\t\t\t\t\tadd2emitQueue_bubble(this.delay, dataNode, property, emitOldValue, oldValue!==undefined, undefined, false);\n\t\t\t\t\t\tif(shouldDestroy) {\n\t\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\t\tProxserve.destroy(oldValue);\n\t\t\t\t\t\t\t}, this.delay + 1000); //postpone this cpu intense function for later, probably when proxserve is not is use\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn true; //do nothing because there's nothing to delete\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tdataNode[ND].objects.proxy = revocable.proxy;\n\t\t\tdataNode[ND].objects.revoke = revocable.revoke;\n\n\t\t\tif(typeoftarget === 'Object') {\n\t\t\t\tlet keys = Object.keys(target);\n\t\t\t\tfor(let key of keys) {\n\t\t\t\t\tlet typeofproperty = realtypeof(target[key]);\n\t\t\t\t\tif(acceptableTypes.includes(typeofproperty)) {\n\t\t\t\t\t\tthis.createProxy(dataNode, key); //recursively make child objects also proxies\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(typeoftarget === 'Array') {\n\t\t\t\tfor(let i = 0; i < target.length; i++) {\n\t\t\t\t\tlet typeofproperty = realtypeof(target[i]);\n\t\t\t\t\tif(acceptableTypes.includes(typeofproperty)) {\n\t\t\t\t\t\tthis.createProxy(dataNode, i); //recursively make child objects also proxies\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconsole.warn('Not Implemented');\n\t\t\t}\n\n\t\t\treturn revocable.proxy;\n\t\t}\n\t\telse {\n\t\t\tthrow new Error('Must observe an '+acceptableTypes.join('/'));\n\t\t}\n\t}\n\n\t/**\n\t * Recursively revoke proxies, allowing them to be garbage collected.\n\t * this functions delays by delay+1000 milliseconds to let time for all events to finish\n\t * @param {*} proxy \n\t */\n\tstatic destroy(proxy) {\n\t\tlet objects;\n\t\ttry {\n\t\t\tobjects = proxy.$getProxserveObjects();\n\t\t} catch(error) {\n\t\t\treturn; //proxy variable isn't a proxy\n\t\t}\n\n\t\tif(!objects.isDeleted) {\n\t\t\tobjects.isDeleted = true;\n\t\t}\n\n\t\tlet typeofproxy = realtypeof(proxy);\n\n\t\tif(acceptableTypes.includes(typeofproxy)) {\n\t\t\tif(typeofproxy === 'Object') {\n\t\t\t\tlet keys = Object.keys(proxy);\n\t\t\t\tfor(let key of keys) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet typeofproperty = realtypeof(proxy[key]);\n\t\t\t\t\t\tif(acceptableTypes.includes(typeofproperty)) {\n\t\t\t\t\t\t\tProxserve.destroy(proxy[key]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(error) {\n\t\t\t\t\t\tconsole.error(error); //don't throw and kill the whole process just if this iteration fails\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(typeofproxy === 'Array') {\n\t\t\t\tfor(let i = proxy.length - 1; i >= 0; i--) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet typeofproperty = realtypeof(proxy[i]);\n\t\t\t\t\t\tif(acceptableTypes.includes(typeofproperty)) {\n\t\t\t\t\t\t\tProxserve.destroy(proxy[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(error) {\n\t\t\t\t\t\tconsole.error(error); //don't throw and kill the whole process just if this iteration fails\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconsole.warn('Not Implemented');\n\t\t\t}\n\n\t\t\tobjects.revoke();\n\t\t\tobjects.proxy = null;\n\t\t}\n\t}\n\n\tstatic splitPath(path) {\n\t\treturn splitPath(path);\n\t}\n\n\tstatic evalPath(obj, path) {\n\t\treturn evalPath(obj, path);\n\t}\n}\n\nmodule.exports = exports = Proxserve; //makes ParcelJS expose this globally (for all platforms) after bundling everything"]}