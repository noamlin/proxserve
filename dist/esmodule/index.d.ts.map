{"mappings":"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","sources":["src/src/globals.ts","src/src/types/pseudo-methods.ts","src/src/types/proxserve-class.ts","src/src/types/globals.ts","src/src/general-functions.ts","src/src/supporting-functions.ts","src/src/pseudo-methods.ts","src/src/types/proxy-methods.ts","src/src/event-emitter.ts","src/src/proxy-methods.ts","src/src/index.ts","src/index.ts"],"sourcesContent":[null,null,null,null,null,null,null,null,null,null,null,"/**\n * 2022 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nimport { proxyTypes, NODE_STATUSES, PROXY_STATUSES, ND, NID } from './globals';\nimport type { TargetVariable, SomeObject } from './types/globals';\nimport type { ProxserveInstance, DataNode, ProxyNode, ProxserveInstanceMetadata } from './types/proxserve-class';\nimport { unproxify, createNodes, stackTraceLog } from './supporting-functions';\nimport * as pseudoMethods from './pseudo-methods';\nimport * as proxyMethods from './proxy-methods';\nimport { realtypeof, splitPath, evalPath } from './general-functions';\nimport { initEmitEvent } from './event-emitter';\n\nconst doNotProxifyPrefix = '_$';\nconst pseudoMethodsAlternativeNamingPrefix = '$';\n\n/**\n * save an array of all reserved function names\n * and also add synonyms to these functions\n */\nlet pseudoMethodsNames = Object.keys(pseudoMethods);\nfor(let i = pseudoMethodsNames.length - 1; i >= 0; i--) {\n\tlet name = pseudoMethodsNames[i];\n\tlet synonym = pseudoMethodsAlternativeNamingPrefix + name;\n\tpseudoMethods[synonym] = pseudoMethods[name];\n\tpseudoMethodsNames.push(synonym);\n}\n\ninterface MakeOptions {\n\tstrict?: ProxserveInstanceMetadata['strict'];\n\tmethodsEmitRaw?: ProxserveInstanceMetadata['methodsEmitRaw'];\n\t/** internal root name of the instance */\n\tname?: string;\n\tdebug?: {\n\t\tdestroyDelay?: ProxserveInstanceMetadata['destroyDelay'];\n\t\ttrace?: ProxserveInstanceMetadata['trace'];\n\t};\n}\n\nexport class Proxserve {\n\t/**\n\t * make a new proxserve instance\n\t */\n\tstatic make<T>(target: TargetVariable, options = {} as MakeOptions): ProxserveInstance & T {\n\t\tconst {\n\t\t\tstrict = true,\n\t\t\tmethodsEmitRaw = false,\n\t\t\tname = '',\n\t\t\tdebug,\n\t\t} = options;\n\n\t\tconst destroyDelay = debug?.destroyDelay ?? 1000;\n\t\tconst trace = debug?.trace ?? 'none';\n\n\t\tlet dataTreePrototype: DataNode = {\n\t\t\t[NID]: {\n\t\t\t\tstatus: NODE_STATUSES.active,\n\t\t\t\tname,\n\t\t\t},\n\t\t\t[ND]: { isTreePrototype: true } as DataNode[typeof ND],\n\t\t};\n\t\tlet proxyTreePrototype: ProxyNode = {\n\t\t\t[NID]: { status: PROXY_STATUSES.alive },\n\t\t\t[ND]: { isTreePrototype: true } as ProxyNode[typeof ND],\n\t\t};\n\n\t\tconst newNodes = createNodes(dataTreePrototype, '', proxyTreePrototype, target);\n\n\t\tconst metadata = {\n\t\t\tstrict,\n\t\t\tmethodsEmitRaw,\n\t\t\tdestroyDelay,\n\t\t\ttrace,\n\t\t\tdataTree: newNodes.dataNode,\n\t\t\tproxyTree: newNodes.proxyNode,\n\t\t} as ProxserveInstanceMetadata;\n\n\t\treturn Proxserve.createProxy<T>(metadata, metadata.dataTree);\n\t}\n\n\t/**\n\t * create a new proxy and a new node for a property of the parent's target-object\n\t */\n\tstatic createProxy<T>(\n\t\tmetadata: ProxserveInstanceMetadata,\n\t\tparentDataNode: DataNode,\n\t\ttargetProperty?: string,\n\t): ProxserveInstance & T {\n\t\tconst parentProxyNode = parentDataNode[ND].proxyNode!;\n\t\tlet dataNode: DataNode;\n\t\tlet proxyNode: ProxyNode;\n\n\t\tif(targetProperty === undefined) { //refering to own node and not a child property (meaning root object)\n\t\t\tdataNode = parentDataNode;\n\t\t\tproxyNode = parentProxyNode;\n\t\t}\n\t\telse {\n\t\t\t//create new or reset an existing data-node and then creates a new proxy-node\n\t\t\tconst newNodes = createNodes(\n\t\t\t\tparentDataNode,\n\t\t\t\ttargetProperty,\n\t\t\t\tparentProxyNode,\n\t\t\t\tparentProxyNode[ND].target[targetProperty],\n\t\t\t);\n\t\t\tdataNode = newNodes.dataNode;\n\t\t\tproxyNode = newNodes.proxyNode!;\n\t\t}\n\n\t\tlet target = proxyNode[ND].target;\n\n\t\tlet typeoftarget = realtypeof(target);\n\n\t\tif(proxyTypes[typeoftarget]) {\n\t\t\tlet revocable = Proxy.revocable<TargetVariable>(target, {\n\t\t\t\tget: (target: TargetVariable/*same as parent scope 'target'*/, property: string|symbol, proxy) => {\n\t\t\t\t\tif(metadata.methodsEmitRaw === false && Object.prototype.hasOwnProperty.call(proxyMethods, property) && property in Object.getPrototypeOf(target)) {\n\t\t\t\t\t\t// use a proxy method instead of the built-in method that is on the prototype chain\n\t\t\t\t\t\treturn proxyMethods[property].bind({ metadata, dataNode, proxyNode });\n\t\t\t\t\t}\n\t\t\t\t\telse if(pseudoMethodsNames.includes(property as string) && typeof target[property] === 'undefined') {\n\t\t\t\t\t\t// can access a pseudo function (or its synonym) if their keywords isn't used\n\t\t\t\t\t\treturn pseudoMethods[property].bind({ metadata, dataNode, proxyNode });\n\t\t\t\t\t}\n\t\t\t\t\telse if(!target.propertyIsEnumerable(property) || typeof property === 'symbol') {\n\t\t\t\t\t\treturn target[property]; // non-enumerable or non-path'able aren't proxied\n\t\t\t\t\t}\n\t\t\t\t\telse if(\n\t\t\t\t\t\tproxyNode[property] // there's a child node\n\t\t\t\t\t\t&& proxyNode[property][ND].proxy // it holds a proxy\n\t\t\t\t\t\t&& proxyNode[property][NID].status === PROXY_STATUSES.alive\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn proxyNode[property][ND].proxy;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn target[property];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\n\t\t\t\tset: (target/*same as parent scope 'target'*/, property, value, proxy) => { //'receiver' is proxy\n\t\t\t\t\t/**\n\t\t\t\t\t * property can be a regular object because of a few possible reasons:\n\t\t\t\t\t * 1. proxy is deleted from tree but user keeps accessing it then it means he saved a reference.\n\t\t\t\t\t * 2. it is a non-enumerable property which means it was intentionally hidden.\n\t\t\t\t\t * 3. property is a symbol and symbols can't be proxied because we can't create a normal path for them.\n\t\t\t\t\t *    these properties are not proxied and should not emit change-event.\n\t\t\t\t\t *    except for: length\n\t\t\t\t\t * 4. property is manually set as raw object with the special prefix.\n\t\t\t\t\t * TODO - make a list of all possible properties exceptions (maybe function 'name'?)\n\t\t\t\t\t */\n\t\t\t\t\tif(dataNode[NID].status === NODE_STATUSES.blocked) { //blocked from changing values\n\t\t\t\t\t\tconsole.error('object is blocked. can\\'t change value of property:', property);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(\n\t\t\t\t\t\ttypeof property === 'symbol'\n\t\t\t\t\t\t|| property.indexOf(doNotProxifyPrefix) === 0\n\t\t\t\t\t) {\n\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(property !== 'length' && !target.propertyIsEnumerable(property)) {\n\t\t\t\t\t\t//if setting a whole new property then it is non-enumerable (yet) so a further test is needed\n\t\t\t\t\t\tlet descriptor = Object.getOwnPropertyDescriptor(target, property);\n\t\t\t\t\t\tif(typeof descriptor === 'object' && descriptor.enumerable === false) { //property was previously set\n\t\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet oldValue = target[property]; // should not be proxy\n\t\t\t\t\tlet isOldValueProxy = false;\n\t\t\t\t\tif(proxyNode[property] !== undefined && proxyNode[property][ND].proxy !== undefined) {\n\t\t\t\t\t\t// about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\tproxyNode[property][NID].status = PROXY_STATUSES.deleted;\n\t\t\t\t\t\tdelete dataNode[property][ND].proxyNode; // detach reference from data-node to proxy-node\n\t\t\t\t\t\tisOldValueProxy = true;\n\t\t\t\t\t\tif(metadata.strict) {\n\t\t\t\t\t\t\t// postpone this cpu intense function for later, probably when proxserve is not in use\n\t\t\t\t\t\t\tsetTimeout(Proxserve.destroy, metadata.destroyDelay, proxyNode[property][ND].proxy);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue = unproxify(value);\n\t\t\t\t\ttarget[property] = value; //assign new value\n\n\t\t\t\t\tlet isValueProxy = false;\n\t\t\t\t\tlet typeofvalue = realtypeof(value);\n\t\t\t\t\tif(proxyTypes[typeofvalue]) {\n\t\t\t\t\t\tProxserve.createProxy(metadata, dataNode, property); // if trying to add a new value which is an object then make it a proxy\n\t\t\t\t\t\tisValueProxy = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (metadata.trace !== 'none') {\n\t\t\t\t\t\tstackTraceLog(metadata.trace);\n\t\t\t\t\t}\n\n\t\t\t\t\tinitEmitEvent(dataNode, property, oldValue, isOldValueProxy, value, isValueProxy);\n\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\t/**\n\t\t\t\t * TODO - this function is incomplete and doesn't handle all of 'descriptor' scenarios\n\t\t\t\t */\n\t\t\t\tdefineProperty: (target/*same as parent scope 'target'*/, property, descriptor) => {\n\t\t\t\t\tif(typeof property === 'symbol') {\n\t\t\t\t\t\tObject.defineProperty(target, property, descriptor);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet oldValue = target[property]; //should not be proxy\n\t\t\t\t\tlet isOldValueProxy = false;\n\t\t\t\t\tif(proxyNode[property] !== undefined && proxyNode[property][ND].proxy !== undefined) {\n\t\t\t\t\t\t//about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\tproxyNode[property][NID].status = PROXY_STATUSES.deleted;\n\t\t\t\t\t\tdelete dataNode[property][ND].proxyNode; //detach reference from data-node to proxy-node\n\t\t\t\t\t\tisOldValueProxy = true;\n\t\t\t\t\t\tif(metadata.strict) {\n\t\t\t\t\t\t\t//postpone this cpu intense function for later, probably when proxserve is not is use\n\t\t\t\t\t\t\tsetTimeout(Proxserve.destroy, metadata.destroyDelay, proxyNode[property][ND].proxy);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdescriptor.value = unproxify(descriptor.value);\n\t\t\t\t\tObject.defineProperty(target, property, descriptor); //defining the new value\n\t\t\t\t\tlet value = descriptor.value;\n\t\t\t\t\tlet isValueProxy = false;\n\t\t\t\t\t//excluding non-enumerable properties from being proxied\n\t\t\t\t\tlet typeofvalue = realtypeof(descriptor.value);\n\t\t\t\t\tif(proxyTypes[typeofvalue] && descriptor.enumerable === true) {\n\t\t\t\t\t\tProxserve.createProxy(metadata, dataNode, property); //if trying to add a new value which is an object then make it a proxy\n\t\t\t\t\t\tisValueProxy = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tinitEmitEvent(dataNode, property, oldValue, isOldValueProxy, value, isValueProxy);\n\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\tdeleteProperty: (target/*same as parent scope 'target'*/, property) => {\n\t\t\t\t\tif(!target.propertyIsEnumerable(property) || typeof property === 'symbol') {\n\t\t\t\t\t\t//non-proxied properties simply get deleted and nothing more\n\t\t\t\t\t\tdelete target[property];\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dataNode[NID].status === NODE_STATUSES.blocked) { //blocked from changing values\n\t\t\t\t\t\tconsole.error(`can't delete property '${property}'. object is blocked.`);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(property in target) {\n\t\t\t\t\t\tlet oldValue = target[property]; //should not be proxy\n\t\t\t\t\t\tlet isOldValueProxy = false;\n\t\t\t\t\t\tif(proxyNode[property] !== undefined && proxyNode[property][ND].proxy !== undefined) {\n\t\t\t\t\t\t\t//about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\t\tproxyNode[property][NID].status = PROXY_STATUSES.deleted;\n\t\t\t\t\t\t\tdelete dataNode[property][ND].proxyNode; //detach reference from data-node to proxy-node\n\t\t\t\t\t\t\tisOldValueProxy = true;\n\t\t\t\t\t\t\tif(metadata.strict) {\n\t\t\t\t\t\t\t\t//postpone this cpu intense function for later, probably when proxserve is not is use\n\t\t\t\t\t\t\t\tsetTimeout(Proxserve.destroy, metadata.destroyDelay, proxyNode[property][ND].proxy);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete target[property]; // actual delete\n\n\t\t\t\t\t\tinitEmitEvent(dataNode, property, oldValue, isOldValueProxy, undefined, false);\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn true; //do nothing because there's nothing to delete\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as ProxyHandler<TargetVariable>) as { proxy: ProxserveInstance & T, revoke: () => void };\n\n\t\t\tproxyNode[ND].proxy = revocable.proxy;\n\t\t\tproxyNode[ND].revoke = revocable.revoke;\n\n\t\t\tif(proxyTypes[typeoftarget]) {\n\t\t\t\tlet keys = Object.keys(target); //handles both Objects and Arrays\n\t\t\t\tfor(let key of keys) {\n\t\t\t\t\tif (key.indexOf(doNotProxifyPrefix) === 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tlet typeofproperty = realtypeof(target[key]);\n\t\t\t\t\tif(proxyTypes[typeofproperty]) {\n\t\t\t\t\t\tProxserve.createProxy(metadata, dataNode, key); //recursively make child objects also proxies\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconsole.warn(`Type of \"${typeoftarget}\" is not implemented`);\n\t\t\t}\n\n\t\t\treturn revocable.proxy;\n\t\t}\n\t\telse {\n\t\t\tconst types = Object.keys(proxyTypes);\n\t\t\tthrow new Error(`Must observe an ${types.join('/')}`);\n\t\t}\n\t}\n\n\t/**\n\t * Recursively revoke proxies, allowing them to be garbage collected.\n\t * this functions delays 1000 milliseconds to let time for all events to finish\n\t */\n\tstatic destroy(proxy: ProxserveInstance) {\n\t\tlet proxyNode: ProxyNode;\n\t\ttry {\n\t\t\tconst nodes = proxy.$getProxserveNodes();\n\t\t\tproxyNode = nodes.proxyNode;\n\t\t} catch(error) {\n\t\t\treturn; // proxy variable isn't a proxy\n\t\t}\n\n\t\tif(proxyNode[NID].status === PROXY_STATUSES.alive) {\n\t\t\tproxyNode[NID].status = PROXY_STATUSES.deleted;\n\t\t}\n\n\t\tlet typeofproxy = realtypeof(proxy);\n\n\t\tif(proxyTypes[typeofproxy]) {\n\t\t\tlet keys = Object.keys(proxy); // handles both Objects and Arrays\n\t\t\tfor(let key of keys) {\n\t\t\t\tif (key.indexOf(doNotProxifyPrefix) === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tlet typeofproperty = realtypeof(proxy[key]);\n\t\t\t\t\tif(proxyTypes[typeofproperty]) {\n\t\t\t\t\t\t// going to proxy[key], which is deleted, will return the original target so we will bypass it\n\t\t\t\t\t\tProxserve.destroy(proxyNode[key][ND].proxy!);\n\t\t\t\t\t}\n\t\t\t\t} catch(error) {\n\t\t\t\t\tconsole.error(error); // don't throw and kill the whole process just if this iteration fails\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tproxyNode[ND].revoke?.();\n\t\t\t//proxyNode[ND].proxy = undefined;\n\t\t\tproxyNode[NID].status = PROXY_STATUSES.revoked;\n\t\t}\n\t\telse {\n\t\t\tconsole.warn(`Type of \"${typeofproxy}\" is not implemented`);\n\t\t}\n\t}\n\n\t/**\n\t * splits a path to an array of properties\n\t */\n\tstatic splitPath(path: string): Array<string|number> {\n\t\treturn splitPath(path);\n\t}\n\n\t/**\n\t * evaluate a long path and return the designated object and its referred property\n\t */\n\tstatic evalPath(obj: SomeObject, path: string): {\n\t\tobject: SomeObject,\n\t\tproperty: string|number,\n\t\tvalue: any,\n\t} {\n\t\treturn evalPath(obj, path);\n\t}\n}"],"names":[],"version":3,"file":"index.d.ts.map"}