function e(e,t,r,o){Object.defineProperty(e,t,{get:r,set:o,enumerable:!0,configurable:!0})}const t=Symbol.for("proxserve_node_data"),r=Symbol.for("proxserve_node_inherited_data"),o={Object:!0,Array:!0};let a;var s;let n;var i;let l;var d;function p(e){let t=Object.prototype.toString.call(e);return t.substring(8,t.length-1)}(s=a||(a={})).ACTIVE="active",s.STOPPED="stopped",s.BLOCKED="blocked",s.SPLICING="splicing",(i=n||(n={})).ALIVE="alive",i.DELETED="deleted",i.REVOKED="revoked",(d=l||(l={})).create="create",d.update="update",d.delete="delete",d.splice="splice",d.shift="shift",d.unshift="unshift";new WeakSet;function u(e){if("string"!=typeof e||""===e)return[];let t=0,r=!1,o=!1;"."===e[0]?t=1:"["===e[0]&&(t=1,r=!0,o=!0);let a=[],s="";for(;t<e.length;t++){let n=e[t];if(r)if("]"===n)o?a.push(parseInt(s,10)):a.push(s),r=!1,o=!1,s="";else{if(o){let e=n.charCodeAt(0);(e<48||e>57)&&(o=!1)}s+=n}else"["===n&&(r=!0,o=!0),"."===n||"["===n?""!==s&&(a.push(s),s=""):s+=n}return""!==s&&a.push(s),a}function c(e,t){if(""===t)return{object:e,property:"",value:e};let r,o=u(t);for(r=0;r<=o.length-2;r++)if(void 0===(e=e[o[r]]))throw new Error(`Invalid path was given - "${t}"`);return{object:e,property:o[r],value:e[o[r]]}}function y(e,t){if("symbol"==typeof t)throw new Error("property of type \"symbol\" isn't path'able");const r=p(e);switch(r){case"Object":return`.${t}`;case"Array":return`[${t}]`;default:return console.warn(`Not Implemented (type of '${r}')`),t}}function f(e){const t=p(e);if(o[t]){let r=e;try{r=e.$getOriginalTarget()}catch(e){}switch(t){case"Object":let e=Object.keys(r);for(let t of e)r[t]=f(r[t]);break;case"Array":for(let e=0;e<r.length;e++)r[e]=f(r[e]);break;default:console.warn(`Not Implemented (type of '${t}')`)}return r}return e}function h(e,o,a,s){let n;n=a?.[t].target?y(a[t].target,o):y({},o);let i,l=e[o];return l||(l={[r]:Object.create(e[r]),[t]:{parentNode:e,listeners:{shallow:[],deep:[]}}},e[o]=l),delete l[r].status,e[t].isTreePrototype?Object.assign(l[t],{path:"",propertyPath:""}):Object.assign(l[t],{path:e[t].path+n,propertyPath:n}),a?(i={[r]:Object.create(a[r]),[t]:{target:s,dataNode:l}},a[o]=i,l[t].proxyNode=i):i=void 0,{dataNode:l,proxyNode:i}}var N={};e(N,"alternativeNamingPrefix",(function(){return v})),e(N,"stop",(function(){return x})),e(N,"block",(function(){return b})),e(N,"activate",(function(){return E})),e(N,"on",(function(){return g})),e(N,"once",(function(){return P})),e(N,"removeListener",(function(){return O})),e(N,"removeAllListeners",(function(){return I})),e(N,"getOriginalTarget",(function(){return T})),e(N,"getProxserveNodes",(function(){return w}));const v="$",x=function(){this.dataNode[r].status=a.STOPPED},b=function(){this.dataNode[r].status=a.BLOCKED},E=function(e=!1){e||this.dataNode===this.metadata.dataTree?this.dataNode[r].status=a.ACTIVE:delete this.dataNode[r].status},g=function(e){const{path:r="",listener:o,id:a,deep:s=!1,once:n=!1}=e;let{event:i}=e;"change"===i?i=Object.keys(l):Array.isArray(i)||(i=[i]);for(let e of i)if(!l[e]){const t=Object.keys(l);throw new Error(`${e} is not a valid event. valid events are ${t.join(",")}`)}let d=this.dataNode,p=u(r);for(let e of p)d[e]||h(d,e),d=d[e];let c=d[t].listeners.shallow;s&&(c=d[t].listeners.deep);let y={type:i,once:n,func:o};void 0!==a&&(y.id=a),c.push(y)},P=function(e){e.once=!0,g.call(this,e)};function m(e,t){for(let r=e.length-1;r>=0;r--){let o=e[r];(void 0!==t&&o.id===t||o.func===t)&&e.splice(r,1)}}const O=function(e){const{id:r,path:o=""}=e,a=`${this.dataNode[t].path}${o}`;let s=this.dataNode;const n=u(o);for(let e of n){if(!s[e])return void console.warn(`can't remove listener from a non-existent path '${a}'`);s=s[e]}m(s[t].listeners.shallow,r),m(s[t].listeners.deep,r)},I=function(e=""){const r=`${this.dataNode[t].path}${e}`,o=u(e);let a=this.dataNode;for(let e of o){if(!a[e])return void console.warn(`can't remove all listeners from a non-existent path '${r}'`);a=a[e]}a[t].listeners.shallow=[],a[t].listeners.deep=[]},T=function(){return this.proxyNode[t].target},w=function(){return{dataNode:this.dataNode,proxyNode:this.proxyNode}};var j={};function A(e,o){if(e[t].proxyNode&&e[t].proxyNode[r].status===n.ALIVE)return e[t].proxyNode[t].proxy;{o||(o=u(e[t].propertyPath)[0]);let a=e[t].parentNode;if(a[t].proxyNode&&a[t].proxyNode[r].status===n.ALIVE)return a[t].proxyNode[t].proxy?.[o]}}function D(e,o,s,i,d,p){if(s===d||!e[t].proxyNode)return;let u=e[t].proxyNode;if(u[r].status!==n.ALIVE)return;let c,f,h=l.update;void 0===d?h=l.delete:void 0===s&&(h=l.create),e[r].status===a.SPLICING&&(e[t].deferredEvents||(e[t].deferredEvents=[]),c=e[t].deferredEvents),e[o]?(e=e[o],f=""):f=y(u[t].target,o);let N={path:f,value:d,oldValue:s,type:h};c?c.push({dataNode:e,change:N,shouldCapture:i||p}):(V(e,N,o),(i||p)&&L(e,N))}function V(e,o,s){if(e[r].status===a.STOPPED)return;let n=A(e,s);if(""===o.path&&C(e[t].listeners.shallow,n,o),C(e[t].listeners.deep,n,o),!e[t].parentNode[t].isTreePrototype){let r={...o,path:e[t].propertyPath+o.path};V(e[t].parentNode,r)}}function L(e,o){let s=Object.keys(e);for(let n of s){let s="object"==typeof o.value&&null!==o.value?o.value[n]:void 0,i="object"==typeof o.oldValue&&null!==o.oldValue?o.oldValue[n]:void 0;if(s!==i){let o=l.update;void 0===s?o=l.delete:void 0===i&&(o=l.create);let d={path:"",oldValue:i,value:s,type:o},p=e[n];if(p[r].status!==a.STOPPED){let e=A(p,n);C(p[t].listeners.shallow,e,d)}L(p,d)}}}function C(e,t,r){for(let o=e.length-1;o>=0;o--){let a=e[o];a.type.includes(r.type)&&(!0===a.once&&e.splice(o,1),a.func.call(t,r))}}function $(e,r,o,a,s){if(V(e,{path:"",value:s,oldValue:a,type:r,args:o}),e[t].deferredEvents){for(let r of e[t].deferredEvents){if(""===r.change.path){let e=A(r.dataNode);C(r.dataNode[t].listeners.shallow,e,r.change),C(r.dataNode[t].listeners.deep,e,r.change)}r.shouldCapture&&L(r.dataNode,r.change)}delete e[t].deferredEvents}else console.warn(`no side effect events for ${r} were made`)}e(j,"splice",(function(){return k})),e(j,"shift",(function(){return S})),e(j,"unshift",(function(){return K}));const k=function(e,o,...s){if(this.dataNode[r].status!==a.ACTIVE)return Array.prototype.splice.call(this.proxyNode[t].proxy,e,o,...s);let n=!this.dataNode[r].hasOwnProperty("status");this.dataNode[r].status=a.SPLICING;let i=this.proxyNode[t].target.slice(0),d=Array.prototype.splice.call(this.proxyNode[t].proxy,e,o,...s),p={start:e,deleteCount:o,items:s};return n?delete this.dataNode[r].status:this.dataNode[r].status=a.ACTIVE,$(this.dataNode,l.splice,p,i,this.proxyNode[t].target),d},S=function(){if(this.dataNode[r].status!==a.ACTIVE)return Array.prototype.shift.call(this.proxyNode[t].proxy);let e=!this.dataNode[r].hasOwnProperty("status");this.dataNode[r].status=a.SPLICING;let o=this.proxyNode[t].target.slice(0),s=Array.prototype.shift.call(this.proxyNode[t].proxy);return e?delete this.dataNode[r].status:this.dataNode[r].status=a.ACTIVE,$(this.dataNode,l.shift,{},o,this.proxyNode[t].target),s},K=function(...e){if(this.dataNode[r].status!==a.ACTIVE)return Array.prototype.shift.call(this.proxyNode[t].proxy);let o=!this.dataNode[r].hasOwnProperty("status");this.dataNode[r].status=a.SPLICING;let s=this.proxyNode[t].target.slice(0),n=Array.prototype.unshift.call(this.proxyNode[t].proxy,...e),i={items:e};return o?delete this.dataNode[r].status:this.dataNode[r].status=a.ACTIVE,$(this.dataNode,l.unshift,i,s,this.proxyNode[t].target),n};let G=Object.keys(N);for(let e=G.length-1;e>=0;e--){let t=G[e],r=N.alternativeNamingPrefix+t;N[r]=N[t],G.push(r)}class _{static make(e,o={}){const{strict:s=!0,emitMethods:i=!0,debug:l={destroyDelay:1e3}}=o;const d=h({[r]:{status:a.ACTIVE},[t]:{isTreePrototype:!0}},"",{[r]:{status:n.ALIVE},[t]:{isTreePrototype:!0}},e),p={strict:s,emitMethods:i,destroyDelay:l.destroyDelay,dataTree:d.dataNode,proxyTree:d.proxyNode};return _.createProxy(p,p.dataTree)}static createProxy(e,s,i){let l,d,u=s[t].proxyNode;if(void 0===i)l=s,d=u;else{const e=h(s,i,u,u[t].target[i]);l=e.dataNode,d=e.proxyNode}let c=d[t].target,y=p(c);if(o[y]){let s=Proxy.revocable(c,{get:(o,a,s)=>e.emitMethods&&Object.prototype.hasOwnProperty.call(j,a)&&a in Object.getPrototypeOf(o)?j[a].bind({metadata:e,dataNode:l,proxyNode:d}):G.includes(a)&&void 0===o[a]?N[a].bind({metadata:e,dataNode:l,proxyNode:d}):o.propertyIsEnumerable(a)&&"symbol"!=typeof a&&d[a]&&d[a][t].proxy&&d[a][r].status===n.ALIVE?d[a][t].proxy:o[a],set:(s,i,u,c)=>{if(l[r].status===a.BLOCKED)return console.error("object is blocked. can't change value of property:",i),!0;if("symbol"==typeof i)return s[i]=u,!0;if("length"!==i&&!s.propertyIsEnumerable(i)){let e=Object.getOwnPropertyDescriptor(s,i);if("object"==typeof e&&!1===e.enumerable)return s[i]=u,!0}let y=s[i],h=!1;void 0!==d[i]&&void 0!==d[i][t].proxy&&(d[i][r].status=n.DELETED,delete l[i][t].proxyNode,h=!0,e.strict&&setTimeout(_.destroy,e.destroyDelay,d[i][t].proxy)),u=f(u),s[i]=u;let N=!1,v=p(u);return o[v]&&(_.createProxy(e,l,i),N=!0),D(l,i,y,h,u,N),!0},defineProperty:(a,s,i)=>{if("symbol"==typeof s)return Object.defineProperty(a,s,i),!0;let u=a[s],c=!1;void 0!==d[s]&&void 0!==d[s][t].proxy&&(d[s][r].status=n.DELETED,delete l[s][t].proxyNode,c=!0,e.strict&&setTimeout(_.destroy,e.destroyDelay,d[s][t].proxy)),i.value=f(i.value),Object.defineProperty(a,s,i);let y=i.value,h=!1,N=p(i.value);return o[N]&&!0===i.enumerable&&(_.createProxy(e,l,s),h=!0),D(l,s,u,c,y,h),!0},deleteProperty:(o,s)=>{if(!o.propertyIsEnumerable(s)||"symbol"==typeof s)return delete o[s],!0;if(l[r].status===a.BLOCKED)return console.error(`can't delete property '${s}'. object is blocked.`),!0;if(s in o){let a=o[s],i=!1;return void 0!==d[s]&&void 0!==d[s][t].proxy&&(d[s][r].status=n.DELETED,delete l[s][t].proxyNode,i=!0,e.strict&&setTimeout(_.destroy,e.destroyDelay,d[s][t].proxy)),delete o[s],D(l,s,a,i,void 0,!1),!0}return!0}});if(d[t].proxy=s.proxy,d[t].revoke=s.revoke,o[y]){let t=Object.keys(c);for(let r of t){let t=p(c[r]);o[t]&&_.createProxy(e,l,r)}}else console.warn(`Type of "${y}" is not implemented`);return s.proxy}{const e=Object.keys(o);throw new Error(`Must observe an ${e.join("/")}`)}}static destroy(e){let a;try{a=e.$getProxserveNodes().proxyNode}catch(e){return}a[r].status===n.ALIVE&&(a[r].status=n.DELETED);let s=p(e);if(o[s]){let s=Object.keys(e);for(let r of s)try{let s=p(e[r]);o[s]&&_.destroy(a[r][t].proxy)}catch(e){console.error(e)}a[t].revoke(),a[r].status=n.REVOKED}else console.warn(`Type of "${s}" is not implemented`)}static splitPath(e){return u(e)}static evalPath(e,t){return c(e,t)}}export{_ as Proxserve};
//# sourceMappingURL=index.min.js.map
