{"mappings":"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","sources":["src/src/globals.ts","src/src/types.ts","src/src/general-functions.ts","src/src/supporting-functions.ts","src/src/pseudo-methods.ts","src/src/event-emitter.ts","src/src/proxy-methods.ts","src/src/index.ts","src/index.ts"],"sourcesContent":[null,null,null,null,null,null,null,null,"/**\n * Copyright 2021 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nimport { proxyTypes, nodeStatuses, proxyStatuses, ND, NID } from './globals';\nimport { ProxserveInstance, DataNode, ProxyNode, TargetVariable, SomeObject, ProxserveInstanceMetadata } from './types';\nimport { unproxify, createNodes } from './supporting-functions';\nimport * as pseudoMethods from './pseudo-methods';\nimport * as proxyMethods from './proxy-methods';\nimport { realtypeof, splitPath, evalPath } from './general-functions';\nimport { initEmitEvent } from './event-emitter';\n\n/**\n * save an array of all reserved function names\n * and also add synonyms to these functions\n */\nlet pseudoMethodsNames = Object.keys(pseudoMethods);\nfor(let i = pseudoMethodsNames.length - 1; i >= 0; i--) {\n\tlet name = pseudoMethodsNames[i];\n\tlet synonym = '$'+name;\n\tpseudoMethods[synonym] = pseudoMethods[name];\n\tpseudoMethodsNames.push(synonym);\n}\n\ninterface MakeOptions {\n\t/**\n\t * should destroy detached child-objects or deleted properties automatically\n\t */\n\tstrict?: boolean;\n\t/**\n\t * should splice, shift or unshift emit one event or all internal CRUD events\n\t */\n\temitMethods?: boolean;\n\tdebug?: {\n\t\t/**\n\t\t * delay before destroying a detached child-object\n\t\t */\n\t\tdestroyDelay: number;\n\t};\n}\n\nexport class Proxserve {\n\t/**\n\t * make a new proxserve instance\n\t */\n\tstatic make(target: TargetVariable, options = {} as MakeOptions): ProxserveInstance {\n\t\tconst {\n\t\t\tstrict = true,\n\t\t\temitMethods = true,\n\t\t\tdebug = { destroyDelay: 1000 },\n\t\t} = options;\n\n\t\tlet dataTreePrototype: DataNode = {\n\t\t\t[NID]: { status: nodeStatuses.ACTIVE },\n\t\t\t[ND]: { isTreePrototype: true } as DataNode[typeof ND],\n\t\t};\n\t\tlet proxyTreePrototype: ProxyNode = {\n\t\t\t[NID]: { status: proxyStatuses.ALIVE },\n\t\t\t[ND]: { isTreePrototype: true } as ProxyNode[typeof ND],\n\t\t};\n\n\t\tconst newNodes = createNodes(dataTreePrototype, '', proxyTreePrototype, target);\n\n\t\tconst metadata = {\n\t\t\tstrict,\n\t\t\temitMethods,\n\t\t\tdestroyDelay: debug.destroyDelay,\n\t\t\tdataTree: newNodes.dataNode,\n\t\t\tproxyTree: newNodes.proxyNode,\n\t\t} as ProxserveInstanceMetadata;\n\n\t\treturn Proxserve.createProxy(metadata, metadata.dataTree);\n\t}\n\n\t/**\n\t * create a new proxy and a new node for a property of the parent's target-object\n\t */\n\tstatic createProxy(metadata: ProxserveInstanceMetadata, parentDataNode: DataNode, targetProperty?: string): ProxserveInstance {\n\t\tlet parentProxyNode = parentDataNode[ND].proxyNode\n\t\tlet dataNode: DataNode, proxyNode: ProxyNode;\n\n\t\tif(targetProperty === undefined) { //refering to own node and not a child property (meaning root object)\n\t\t\tdataNode = parentDataNode;\n\t\t\tproxyNode = parentProxyNode;\n\t\t}\n\t\telse {\n\t\t\t//creates new or reset an existing data-node and then creates a new proxy-node\n\t\t\tconst newNodes = createNodes(\n\t\t\t\tparentDataNode,\n\t\t\t\ttargetProperty,\n\t\t\t\tparentProxyNode,\n\t\t\t\tparentProxyNode[ND].target[targetProperty],\n\t\t\t);\n\t\t\tdataNode = newNodes.dataNode;\n\t\t\tproxyNode = newNodes.proxyNode;\n\t\t}\n\n\t\tlet target = proxyNode[ND].target;\n\n\t\tlet typeoftarget = realtypeof(target);\n\n\t\tif(proxyTypes[typeoftarget]) {\n\t\t\tlet revocable = Proxy.revocable<TargetVariable>(target, {\n\t\t\t\tget: (target: TargetVariable/*same as parent scope 'target'*/, property: string|symbol, proxy) => {\n\t\t\t\t\tif(metadata.emitMethods && Object.prototype.hasOwnProperty.call(proxyMethods, property) && property in Object.getPrototypeOf(target)) {\n\t\t\t\t\t\t// use a proxy method instead of the built-in method that is on the prototype chain\n\t\t\t\t\t\treturn proxyMethods[property].bind({ metadata, dataNode, proxyNode });\n\t\t\t\t\t}\n\t\t\t\t\telse if(pseudoMethodsNames.includes(property as string) && typeof target[property] === 'undefined') {\n\t\t\t\t\t\t// can access a pseudo function (or its synonym) if their keywords isn't used\n\t\t\t\t\t\treturn pseudoMethods[property].bind({ metadata, dataNode, proxyNode });\n\t\t\t\t\t}\n\t\t\t\t\telse if(!target.propertyIsEnumerable(property) || typeof property === 'symbol') {\n\t\t\t\t\t\treturn target[property]; // non-enumerable or non-path'able aren't proxied\n\t\t\t\t\t}\n\t\t\t\t\telse if(proxyNode[property] // there's a child node\n\t\t\t\t\t\t\t&& proxyNode[property][ND].proxy // it holds a proxy\n\t\t\t\t\t\t\t&& proxyNode[property][NID].status === proxyStatuses.ALIVE) {\n\t\t\t\t\t\treturn proxyNode[property][ND].proxy;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn target[property];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\n\t\t\t\tset: (target/*same as parent scope 'target'*/, property, value, proxy) => { //'receiver' is proxy\n\t\t\t\t\t/**\n\t\t\t\t\t * property can be a regular object because of 3 possible reasons:\n\t\t\t\t\t * 1. proxy is deleted from tree but user keeps accessing it then it means he saved a reference\n\t\t\t\t\t * 2. it is a non-enumerable property which means it was intentionally hidden\n\t\t\t\t\t * 3. property is a symbol and symbols can't be proxied because we can't create a normal path for them.\n\t\t\t\t\t *    these properties are not proxied and should not emit change-event.\n\t\t\t\t\t *    except for: length\n\t\t\t\t\t * TODO - make a list of all possible properties exceptions (maybe function 'name'?)\n\t\t\t\t\t */\n\t\t\t\t\tif(dataNode[NID].status === nodeStatuses.BLOCKED) { //blocked from changing values\n\t\t\t\t\t\tconsole.error('object is blocked. can\\'t change value of property:', property);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(typeof property === 'symbol') {\n\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(property !== 'length' && !target.propertyIsEnumerable(property)) {\n\t\t\t\t\t\t//if setting a whole new property then it is non-enumerable (yet) so a further test is needed\n\t\t\t\t\t\tlet descriptor = Object.getOwnPropertyDescriptor(target, property);\n\t\t\t\t\t\tif(typeof descriptor === 'object' && descriptor.enumerable === false) { //property was previously set\n\t\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet oldValue = target[property]; // should not be proxy\n\t\t\t\t\tlet isOldValueProxy = false;\n\t\t\t\t\tif(proxyNode[property] !== undefined && proxyNode[property][ND].proxy !== undefined) {\n\t\t\t\t\t\t// about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\tproxyNode[property][NID].status = proxyStatuses.DELETED;\n\t\t\t\t\t\tdelete dataNode[property][ND].proxyNode; // detach reference from data-node to proxy-node\n\t\t\t\t\t\tisOldValueProxy = true;\n\t\t\t\t\t\tif(metadata.strict) {\n\t\t\t\t\t\t\t// postpone this cpu intense function for later, probably when proxserve is not in use\n\t\t\t\t\t\t\tsetTimeout(Proxserve.destroy, metadata.destroyDelay, proxyNode[property][ND].proxy);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue = unproxify(value);\n\t\t\t\t\ttarget[property] = value; //assign new value\n\n\t\t\t\t\tlet isValueProxy = false;\n\t\t\t\t\tlet typeofvalue = realtypeof(value);\n\t\t\t\t\tif(proxyTypes[typeofvalue]) {\n\t\t\t\t\t\tProxserve.createProxy(metadata, dataNode, property); // if trying to add a new value which is an object then make it a proxy\n\t\t\t\t\t\tisValueProxy = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tinitEmitEvent(dataNode, property, oldValue, isOldValueProxy, value, isValueProxy);\n\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\t/**\n\t\t\t\t * TODO - this function is incomplete and doesn't handle all of 'descriptor' scenarios\n\t\t\t\t */\n\t\t\t\tdefineProperty: (target/*same as parent scope 'target'*/, property, descriptor) => {\n\t\t\t\t\tif(typeof property === 'symbol') {\n\t\t\t\t\t\tObject.defineProperty(target, property, descriptor);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet oldValue = target[property]; //should not be proxy\n\t\t\t\t\tlet isOldValueProxy = false;\n\t\t\t\t\tif(proxyNode[property] !== undefined && proxyNode[property][ND].proxy !== undefined) {\n\t\t\t\t\t\t//about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\tproxyNode[property][NID].status = proxyStatuses.DELETED;\n\t\t\t\t\t\tdelete dataNode[property][ND].proxyNode; //detach reference from data-node to proxy-node\n\t\t\t\t\t\tisOldValueProxy = true;\n\t\t\t\t\t\tif(metadata.strict) {\n\t\t\t\t\t\t\t//postpone this cpu intense function for later, probably when proxserve is not is use\n\t\t\t\t\t\t\tsetTimeout(Proxserve.destroy, metadata.destroyDelay, proxyNode[property][ND].proxy);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdescriptor.value = unproxify(descriptor.value);\n\t\t\t\t\tObject.defineProperty(target, property, descriptor); //defining the new value\n\t\t\t\t\tlet value = descriptor.value;\n\t\t\t\t\tlet isValueProxy = false;\n\t\t\t\t\t//excluding non-enumerable properties from being proxied\n\t\t\t\t\tlet typeofvalue = realtypeof(descriptor.value);\n\t\t\t\t\tif(proxyTypes[typeofvalue] && descriptor.enumerable === true) {\n\t\t\t\t\t\tProxserve.createProxy(metadata, dataNode, property); //if trying to add a new value which is an object then make it a proxy\n\t\t\t\t\t\tisValueProxy = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tinitEmitEvent(dataNode, property, oldValue, isOldValueProxy, value, isValueProxy);\n\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\tdeleteProperty: (target/*same as parent scope 'target'*/, property) => {\n\t\t\t\t\tif(!target.propertyIsEnumerable(property) || typeof property === 'symbol') {\n\t\t\t\t\t\t//non-proxied properties simply get deleted and nothing more\n\t\t\t\t\t\tdelete target[property];\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dataNode[NID].status === nodeStatuses.BLOCKED) { //blocked from changing values\n\t\t\t\t\t\tconsole.error(`can't delete property '${property}'. object is blocked.`);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(property in target) {\n\t\t\t\t\t\tlet oldValue = target[property]; //should not be proxy\n\t\t\t\t\t\tlet isOldValueProxy = false;\n\t\t\t\t\t\tif(proxyNode[property] !== undefined && proxyNode[property][ND].proxy !== undefined) {\n\t\t\t\t\t\t\t//about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\t\tproxyNode[property][NID].status = proxyStatuses.DELETED;\n\t\t\t\t\t\t\tdelete dataNode[property][ND].proxyNode; //detach reference from data-node to proxy-node\n\t\t\t\t\t\t\tisOldValueProxy = true;\n\t\t\t\t\t\t\tif(metadata.strict) {\n\t\t\t\t\t\t\t\t//postpone this cpu intense function for later, probably when proxserve is not is use\n\t\t\t\t\t\t\t\tsetTimeout(Proxserve.destroy, metadata.destroyDelay, proxyNode[property][ND].proxy);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete target[property]; // actual delete\n\n\t\t\t\t\t\tinitEmitEvent(dataNode, property, oldValue, isOldValueProxy, undefined, false);\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn true; //do nothing because there's nothing to delete\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as ProxyHandler<TargetVariable>) as { proxy: ProxserveInstance, revoke: ()=>void };\n\n\t\t\tproxyNode[ND].proxy = revocable.proxy;\n\t\t\tproxyNode[ND].revoke = revocable.revoke;\n\n\t\t\tif(proxyTypes[typeoftarget]) {\n\t\t\t\tlet keys = Object.keys(target); //handles both Objects and Arrays\n\t\t\t\tfor(let key of keys) {\n\t\t\t\t\tlet typeofproperty = realtypeof(target[key]);\n\t\t\t\t\tif(proxyTypes[typeofproperty]) {\n\t\t\t\t\t\tProxserve.createProxy(metadata, dataNode, key); //recursively make child objects also proxies\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconsole.warn(`Type of \"${typeoftarget}\" is not implemented`);\n\t\t\t}\n\n\t\t\treturn revocable.proxy;\n\t\t}\n\t\telse {\n\t\t\tconst types = Object.keys(proxyTypes);\n\t\t\tthrow new Error(`Must observe an ${types.join('/')}`);\n\t\t}\n\t}\n\n\t/**\n\t * Recursively revoke proxies, allowing them to be garbage collected.\n\t * this functions delays 1000 milliseconds to let time for all events to finish\n\t */\n\tstatic destroy(proxy: ProxserveInstance) {\n\t\tlet proxyNode;\n\t\ttry {\n\t\t\tconst nodes = proxy.$getProxserveNodes();\n\t\t\tproxyNode = nodes.proxyNode;\n\t\t} catch(error) {\n\t\t\treturn; // proxy variable isn't a proxy\n\t\t}\n\n\t\tif(proxyNode[NID].status === proxyStatuses.ALIVE) {\n\t\t\tproxyNode[NID].status = proxyStatuses.DELETED;\n\t\t}\n\n\t\tlet typeofproxy = realtypeof(proxy);\n\n\t\tif(proxyTypes[typeofproxy]) {\n\t\t\tlet keys = Object.keys(proxy); // handles both Objects and Arrays\n\t\t\tfor(let key of keys) {\n\t\t\t\ttry {\n\t\t\t\t\tlet typeofproperty = realtypeof(proxy[key]);\n\t\t\t\t\tif(proxyTypes[typeofproperty]) {\n\t\t\t\t\t\t// going to proxy[key], which is deleted, will return the original target so we will bypass it\n\t\t\t\t\t\tProxserve.destroy(proxyNode[key][ND].proxy);\n\t\t\t\t\t}\n\t\t\t\t} catch(error) {\n\t\t\t\t\tconsole.error(error); // don't throw and kill the whole process just if this iteration fails\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tproxyNode[ND].revoke();\n\t\t\t//proxyNode[ND].proxy = undefined;\n\t\t\tproxyNode[NID].status = proxyStatuses.REVOKED;\n\t\t}\n\t\telse {\n\t\t\tconsole.warn(`Type of \"${typeofproxy}\" is not implemented`);\n\t\t}\n\t}\n\n\t/**\n\t * splits a path to an array of properties\n\t */\n\tstatic splitPath(path: string): Array<string|number> {\n\t\treturn splitPath(path);\n\t}\n\n\t/**\n\t * evaluate a long path and return the designated object and its referred property\n\t */\n\tstatic evalPath(obj: SomeObject, path: string): {\n\t\tobject: SomeObject,\n\t\tproperty: string|number,\n\t\tvalue: any,\n\t} {\n\t\treturn evalPath(obj, path);\n\t}\n}"],"names":[],"version":3,"file":"index.d.ts.map"}