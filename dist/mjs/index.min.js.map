{"mappings":"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","sources":["src/globals.ts","src/general-functions.ts","src/supporting-functions.ts","src/pseudo-methods.ts","src/event-emitter.ts","src/proxy-methods.ts","src/index.ts"],"sourcesContent":["/**\n * Copyright 2021 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nexport const ND = Symbol.for('proxserve_node_data'); // key for the data of a node\nexport const NID = Symbol.for('proxserve_node_inherited_data'); // key for the inherited data of a node\n\n// acceptable types to be proxied\nexport const proxyTypes = {\n\t\"Object\": true,\n\t\"Array\": true,\n};\n\n// statuses of data-nodes\nexport enum nodeStatuses {\n\tACTIVE = 'active',\n\tSTOPPED = 'stopped',\n\tBLOCKED = 'blocked',\n\tSPLICING = 'splicing',\n};\n\n// statuses of proxies\nexport enum proxyStatuses {\n\tALIVE = 'alive',\n\tDELETED = 'deleted',\n\tREVOKED = 'revoked',\n};\n\n// event names that can be emitted\nexport enum eventNames {\n\tcreate = 'create',\n\tupdate = 'update',\n\tdelete = 'delete',\n\tsplice = 'splice',\n\tshift = 'shift',\n\tunshift = 'unshift',\n};\n\nexport type SomeObject = {\n\t[key: string | number | symbol]: any,\n};\nexport type SomeArray = Array<any>;\nexport type TargetVariable = SomeObject | SomeArray;\n\nexport interface ProxserveInstance {\n\t[ND]: ProxyNode[typeof ND];\n\t[NID]: ProxyNode[typeof NID];\n\t[property: string]: any;\n}\n\nexport interface ProxserveInstanceMetadata {\n\t/**\n\t * should destroy detached child-objects or deleted properties automatically\n\t */\n\tstrict: boolean;\n\t/**\n\t * should splice, shift or unshift emit one event or all internal CRUD events\n\t */\n\temitMethods: boolean;\n\t/**\n\t * delay before destroying a detached child-object\n\t */\n\tdestroyDelay: number;\n\tdataTree: DataNode;\n\tproxyTree: ProxyNode;\n}\n\n// theoretically can have any string possible as a type. but these are the most common and they help our TS autocomplete\nexport type variableTypes = 'Object'|'Array'|'Number'|'String'|'Boolean'|'Null'|'Undefined'|'BigInt'|'Symbol'|'Date';\n\nexport type ListenerData = {\n\ttype: eventNames[],\n\tonce: boolean,\n\tfunc: Function,\n\tid?: string | number;\n};\n\nexport type DeferredEvent = {\n\tdataNode: DataNode,\n\tchange: ChangeEvent,\n\tshouldCapture: boolean,\n};\n\nexport type ChangeEvent = {\n\tpath: string,\n\tvalue: any,\n\toldValue: any,\n\ttype: eventNames,\n\targs?: {\n\t\tstart?: number;\n\t\tdeleteCount?: number;\n\t\titems?: any[];\n\t},\n};\n\nexport interface DataNode {\n\t// Node Inherited Data\n\t[NID]: {\n\t\tstatus?: nodeStatuses;\n\t};\n\t// Node Data\n\t[ND]: {\n\t\tproxyNode: ProxyNode;\n\t\tparentNode: DataNode;\n\t\tlisteners: {\n\t\t\tshallow: ListenerData[];\n\t\t\tdeep: ListenerData[];\n\t\t},\n\t\tpath: string;\n\t\tpropertyPath: string;\n\t\tdeferredEvents?: DeferredEvent[];\n\t\tisTreePrototype?: boolean;\n\t};\n};\n\nexport interface ProxyNode {\n\t[NID]: {\n\t\tstatus?: proxyStatuses;\n\t};\n\t[ND]: {\n\t\ttarget: TargetVariable;\n\t\tdataNode: DataNode;\n\t\tproxy?: ProxserveInstance;\n\t\trevoke?: () => void;\n\t\tisTreePrototype?: boolean;\n\t};\n\t[property: string]: ProxyNode;\n};","/**\n * Copyright 2021 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nimport { SomeObject, SomeArray, variableTypes } from './globals';\n\n/**\n * return a string representing the full type of the variable\n */\nexport function realtypeof(variable: any): variableTypes {\n\tlet rawType = Object.prototype.toString.call(variable); //[object Object], [object Array], [object Number]...\n\treturn rawType.substring(8, rawType.length - 1) as variableTypes;\n}\n\n/**\n * check if variable is a number or a string of a number\n * @param variable \n */\n/*export function isNumeric(variable: any): boolean {\n\tif(typeof variable === 'string' && variable === '') {\n\t\treturn false;\n\t}\n\t\n\treturn !isNaN(variable as number);\n}*/\n\n/**\n * recursively clones objects and array\n */\nconst simpleCloneSet = new WeakSet();\nexport function simpleClone(variable: any): any {\n\tlet typeofvar = realtypeof(variable);\n\n\tif(typeofvar === 'Object') {\n\t\tconst obj = variable as SomeObject;\n\t\tsimpleCloneSet.add(obj);\n\t\tconst cloned = {};\n\t\tlet keys = Object.keys(obj);\n\t\tfor(let key of keys) {\n\t\t\tif(simpleCloneSet.has(obj[key])) {\n\t\t\t\tcloned[key] = obj[key];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcloned[key] = simpleClone(obj[key]);\n\t\t\t}\n\t\t}\n\t\treturn cloned;\n\t}\n\telse if(typeofvar === 'Array') {\n\t\tconst arr = variable as SomeArray;\n\t\tsimpleCloneSet.add(arr);\n\t\tconst cloned = [] as any[];\n\t\tfor(let i = 0; i < arr.length; i++) {\n\t\t\tif(simpleCloneSet.has(arr[i])) {\n\t\t\t\tcloned[i] = arr[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcloned[i] = simpleClone(arr[i]);\n\t\t\t}\n\t\t}\n\t\treturn cloned;\n\t}\n\telse { // hopefully a primitive\n\t\tif(typeofvar !== 'Undefined' && typeofvar !== 'Null' && typeofvar !== 'Boolean' && typeofvar !== 'Number'\n\t\t&& typeofvar !== 'BigInt' && typeofvar !== 'String') {\n\t\t\tconsole.warn(`Can't clone a variable of type ${typeofvar}`);\n\t\t}\n\t\treturn variable;\n\t}\n}\n\n/**\n * splits a path to an array of properties\n * (benchmarked and is faster than regex and split())\n * @param path \n */\nexport function splitPath(path: string): Array<string|number> {\n\tif(typeof path !== 'string' || path === '') {\n\t\treturn [];\n\t}\n\t\n\tlet i = 0, betweenBrackets = false, onlyDigits = false;\n\t//loop will skip over openning '.' or '['\n\tif(path[0] === '.') {\n\t\ti = 1;\n\t} else if(path[0] === '[') {\n\t\ti = 1;\n\t\tbetweenBrackets = true;\n\t\tonlyDigits = true;\n\t}\n\n\tlet resultsArr = [] as Array<string|number>;\n\tlet tmp = '';\n\tfor(; i < path.length; i++) {\n\t\tlet char = path[i];\n\n\t\tif(betweenBrackets) {\n\t\t\tif(char === ']') {\n\t\t\t\tif(onlyDigits) {\n\t\t\t\t\tresultsArr.push(parseInt(tmp, 10));\n\t\t\t\t} else {\n\t\t\t\t\tresultsArr.push(tmp);\n\t\t\t\t}\n\n\t\t\t\tbetweenBrackets = false;\n\t\t\t\tonlyDigits = false;\n\t\t\t\ttmp = '';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(onlyDigits) {\n\t\t\t\t\tlet code = char.charCodeAt(0);\n\t\t\t\t\tif(code < 48 || code > 57) { //less than '0' char or greater than '9' char\n\t\t\t\t\t\tonlyDigits = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp += char;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(char === '[') {\n\t\t\t\tbetweenBrackets = true;\n\t\t\t\tonlyDigits = true;\n\t\t\t}\n\t\t\t\n\t\t\t//check if starting a new property but avoid special case of [prop][prop]\n\t\t\tif(char === '.' || char === '[') {\n\t\t\t\tif(tmp !== '') {\n\t\t\t\t\tresultsArr.push(tmp);\n\t\t\t\t\ttmp = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttmp += char;\n\t\t\t}\n\t\t}\n\t}\n\tif(tmp !== '') {\n\t\tresultsArr.push(tmp);\n\t}\n\treturn resultsArr;\n}\n\n/**\n * evaluate a long path and return the designated object and its referred property\n */\nexport function evalPath(obj: SomeObject, path: string): {\n\tobject: SomeObject,\n\tproperty: string|number,\n\tvalue: any,\n} {\n\tif(path === '') {\n\t\treturn {\n\t\t\tobject: obj,\n\t\t\tproperty: '',\n\t\t\tvalue: obj,\n\t\t};\n\t}\n\n\tlet segments = splitPath(path);\n\tlet i: number;\n\tfor(i = 0; i <= segments.length - 2; i++) { // iterate until one before last property because they all must exist\n\t\tobj = obj[segments[i]];\n\t\tif(typeof obj === 'undefined') {\n\t\t\tthrow new Error(`Invalid path was given - \"${path}\"`);\n\t\t}\n\t}\n\treturn {\n\t\tobject: obj,\n\t\tproperty: segments[i],\n\t\tvalue: obj[ segments[i] ],\n\t};\n}","/**\n * Copyright 2021 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nimport { proxyTypes, ND, NID, DataNode, ProxyNode, TargetVariable, ListenerData } from './globals';\nimport { realtypeof } from './general-functions';\n\n/**\n * Convert property name to valid path segment\n */\nexport function property2path(obj: any, property: string|number): string {\n\tif(typeof property === 'symbol') {\n\t\tthrow new Error(`property of type \"symbol\" isn't path'able`);\n\t}\n\n\tconst typeofobj = realtypeof(obj);\n\tswitch(typeofobj) {\n\t\tcase 'Object': {\n\t\t\treturn `.${property}`;\n\t\t}\n\t\tcase 'Array': {\n\t\t\treturn `[${property}]`;\n\t\t}\n\t\tdefault: {\n\t\t\tconsole.warn(`Not Implemented (type of '${typeofobj}')`);\n\t\t\treturn property as string;\n\t\t}\n\t}\n}\n\n/**\n * recursively switch between all proxies to their original targets.\n * note: original targets should never hold proxies under them,\n * thus altering the object references (getting from 'value') should be ok.\n * if whoever uses this library decides to\n * \t1. create a proxy with children (sub-proxies)\n * \t2. create a regular object\n * \t3. adding sub-proxies to the regular object\n * \t4. attaching the regular object to the proxy\n * then this regular object will be altered.\n */\nexport function unproxify(value: any): any {\n\tconst typeofvalue = realtypeof(value);\n\n\tif(proxyTypes[typeofvalue]) {\n\t\tlet target = value;\n\t\ttry {\n\t\t\ttarget = value.$getOriginalTarget();\n\t\t} catch(error) {}\n\n\t\tswitch(typeofvalue) {\n\t\t\tcase 'Object':\n\t\t\t\tlet keys = Object.keys(target);\n\t\t\t\tfor(let key of keys) {\n\t\t\t\t\ttarget[key] = unproxify(target[key]); // maybe alters target and maybe returning the exact same object\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'Array':\n\t\t\t\tfor(let i=0; i < target.length; i++) {\n\t\t\t\t\ttarget[i] = unproxify(target[i]); // maybe alters target and maybe returning the exact same object\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.warn(`Not Implemented (type of '${typeofvalue}')`);\n\t\t}\n\n\t\treturn target;\n\t}\n\telse {\n\t\treturn value; // primitive\n\t}\n}\n\n/**\n * create or reset a node in a tree of meta-data (mainly path related)\n * and optionally create a node in a tree of proxy data (mainly objects related)\n */\nexport function createNodes(\n\tparentDataNode: DataNode,\n\tproperty: string | number,\n\tparentProxyNode?: ProxyNode,\n\ttarget?: TargetVariable,\n): { dataNode: DataNode, proxyNode: ProxyNode } {\n\t//handle property path\n\tlet propertyPath: string;\n\tif(parentProxyNode?.[ND].target) {\n\t\tpropertyPath = property2path(parentProxyNode[ND].target, property);\n\t} else {\n\t\tpropertyPath = property2path({}, property); // if parent doesn't have target then treat it as object\n\t}\n\t\n\t//handle data node\n\tlet dataNode: DataNode = parentDataNode[property]; // try to receive existing data-node\n\tif(!dataNode) {\n\t\tdataNode = {\n\t\t\t[NID]: Object.create(parentDataNode[NID]),\n\t\t\t[ND]: {\n\t\t\t\tparentNode: parentDataNode,\n\t\t\t\tlisteners: {\n\t\t\t\t\tshallow: [] as ListenerData[],\n\t\t\t\t\tdeep: [] as ListenerData[],\n\t\t\t\t},\n\t\t\t}\n\t\t} as DataNode;\n\t\tparentDataNode[property] = dataNode;\n\t}\n\n\tdelete dataNode[NID].status; // clears old status in case a node previously existed\n\t// updates path (for rare case where parent was array and then changed to object or vice versa)\n\tif(!parentDataNode[ND].isTreePrototype) {\n\t\tObject.assign(dataNode[ND], {\n\t\t\tpath: parentDataNode[ND].path + propertyPath,\n\t\t\tpropertyPath\n\t\t});\n\t}\n\telse {\n\t\tObject.assign(dataNode[ND], {\n\t\t\tpath: '',\n\t\t\tpropertyPath: ''\n\t\t});\n\t}\n\n\t// handle proxy node\n\tlet proxyNode: ProxyNode;\n\tif(parentProxyNode) {\n\t\tproxyNode = {\n\t\t\t[NID]: Object.create(parentProxyNode[NID]),\n\t\t\t[ND]: {\n\t\t\t\ttarget: target as TargetVariable,\n\t\t\t\tdataNode,\n\t\t\t},\n\t\t};\n\n\t\tparentProxyNode[property] = proxyNode;\n\n\t\t// attach nodes to each other\n\t\tdataNode[ND].proxyNode = proxyNode;\n\t} else {\n\t\t// hack to satisfy TS.\n\t\t// this scenario is dangerous and exists only for `on()` of future variables (paths) that don't yet exist\n\t\tproxyNode = undefined as unknown as ProxyNode;\n\t}\n\n\treturn { dataNode, proxyNode };\n}\n","/**\n * Copyright 2021 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n// Pseudo methods are methods that aren't really on the object - not as a property nor via its prototype\n// thus they will not be retrieved via \"for..in\" and etcetera. Their property name is actually undefined, but\n// calling it will return the method via the JS proxy's \"get\" handler.\n// (i.e. someProxserve.pseudoFunction will return the pseudoFunction)\n\"use strict\"\n\nimport { eventNames, nodeStatuses, ND, NID, DataNode, ProxyNode, ListenerData, TargetVariable } from './globals';\nimport { createNodes } from './supporting-functions';\nimport { splitPath } from './general-functions';\n\n/**\n * stop object and children from emitting change events\n * automatically filled param {Object} dataNode\n */\nexport function stop(dataNode: DataNode): void {\n\tdataNode[NID].status = nodeStatuses.STOPPED;\n}\n\n/**\n * block object and children from any changes.\n * user can't set nor delete any property\n * automatically filled param {Object} dataNode\n */\nexport function block(dataNode: DataNode): void {\n\tdataNode[NID].status = nodeStatuses.BLOCKED;\n}\n\n/**\n * resume default behavior of emitting change events, inherited from parent\n * automatically filled param {Object} dataNode\n * automatically filled param {Object} proxyNode\n * @param {Boolean} [force] - force being active regardless of parent\n */\nexport function activate(dataNode: DataNode, proxyNode: ProxyNode, force=false): void {\n\tif(force || dataNode === this.dataTree) { //force activation or we are on root proxy\n\t\tdataNode[NID].status = nodeStatuses.ACTIVE;\n\t}\n\telse {\n\t\tdelete dataNode[NID].status;\n\t}\n}\n\ninterface OnOptions {\n\tdeep?: boolean;\n\tid?: number | string;\n\tonce?: boolean;\n}\n/**\n * add event listener on a proxy or on a descending path\n * \n * @remarks\n * automatically filled param {Object} dataNode\n * automatically filled param {Object} proxyNode\n * \n * @param events\n * @param [path] - path selector\n * @param listener\n * @param [options]\n * \t@property [options.deep] - should listen for event emitted by sub-objects or not\n * \t@property [options.id] - identifier for removing this listener later\n * \t@property [options.once] - whether this listener will run only once or always\n */\nexport function on(\n\tdataNode: DataNode,\n\tproxyNode: ProxyNode,\n\tevents: eventNames | eventNames[],\n\tpath: string,\n\tlistener: Function,\n\toptions?: OnOptions,\n): void {\n\tlet deep: boolean = options?.deep ?? false;\n\tlet id: number | string | undefined = options?.id ?? undefined;\n\tlet once: boolean = options?.once ?? false;\n\n\tif((events as string) === 'change') {\n\t\tevents = Object.keys(eventNames) as eventNames[]; // will listen to all events\n\t} else if(!Array.isArray(events)) {\n\t\tevents = [events];\n\t}\n\n\tfor(let event of events) {\n\t\tif(!eventNames[event]) {\n\t\t\tconst names = Object.keys(eventNames);\n\t\t\tthrow new Error(`${event} is not a valid event. valid events are ${names.join(',')}`);\n\t\t}\n\t}\n\n\tif(typeof path === 'function') { // if called without path\n\t\tif(typeof listener === 'object') { // listener is options\n\t\t\tconst optionsFromListener = listener as OnOptions;\n\t\t\tif(typeof optionsFromListener.deep === 'boolean') {\n\t\t\t\tdeep = optionsFromListener.deep;\n\t\t\t}\n\t\t\tif(optionsFromListener.id !== undefined) {\n\t\t\t\tid = optionsFromListener.id;\n\t\t\t}\n\t\t\tif(typeof optionsFromListener.once === 'boolean') {\n\t\t\t\tonce = optionsFromListener.once;\n\t\t\t}\n\t\t}\n\t\tlistener = path as Function;\n\t\tpath = '';\n\t} else if(typeof listener !== 'function') {\n\t\tthrow new Error(`invalid arguments were given. listener must be a function`);\n\t}\n\t\n\tlet segments = splitPath(path);\n\tfor(let property of segments) { // traverse down the tree\n\t\tif(!dataNode[property]) {\n\t\t\t// create data-nodes if needed, but don't create/overwrite proxy-nodes\n\t\t\tcreateNodes(dataNode, property);\n\t\t}\n\n\t\tdataNode = dataNode[property];\n\t}\n\n\tlet listenersPool = dataNode[ND].listeners.shallow;\n\tif(deep) {\n\t\tlistenersPool = dataNode[ND].listeners.deep;\n\t}\n\n\tlet listenerObj = {\n\t\ttype: events,\n\t\tonce: once,\n\t\tfunc: listener\n\t} as ListenerData;\n\n\tif(id !== undefined) {\n\t\tlistenerObj.id = id;\n\t}\n\tlistenersPool.push(listenerObj);\n}\n\n/**\n * just like `on` but the listener will run only once\n * @see on() function\n */\nexport function once(\n\tdataNode: DataNode,\n\tproxyNode: ProxyNode,\n\tevents: eventNames | eventNames[],\n\tpath: string,\n\tlistener: Function,\n\toptions?: OnOptions): void {\n\tif(typeof options !== 'object') {\n\t\toptions = {};\n\t}\n\toptions.once = true;\n\ton.call(this, dataNode, proxyNode, events, path, listener, options);\n}\n\nfunction removeById(listenersArr: ListenerData[], id: string | number | Function): void {\n\tfor(let i = listenersArr.length - 1; i >= 0; i--) {\n\t\tlet listenerObj = listenersArr[i];\n\t\tif((id !== undefined && listenerObj.id === id) || listenerObj.func === id) {\n\t\t\tlistenersArr.splice(i, 1);\n\t\t}\n\t}\n}\n\n/**\n * removes a listener from a path by an identifier (can have multiple listeners with the same ID)\n * or by the listener function itself\n * \n * @remarks\n * automatically filled param {Object} dataNode\n * automatically filled param {Object} proxyNode\n * \n * @param [path] - path selector\n * @param id - the listener(s) identifier or listener-function\n */\nexport function removeListener(dataNode: DataNode, proxyNode: ProxyNode, path: string, id: string | number | Function): void {\n\tif(arguments.length === 3) { // if called without path\n\t\tid = path as string | number | Function;\n\t\tpath = '';\n\t}\n\n\tlet fullPath = `${dataNode[ND].path}${path}`;\n\tlet segments = splitPath(path);\n\t// traverse down the tree\n\tfor(let property of segments) {\n\t\tif(!dataNode[property]) {\n\t\t\tconsole.warn(`can't remove listener from a non-existent path '${fullPath}'`);\n\t\t\treturn;\n\t\t}\n\t\tdataNode = dataNode[property];\n\t}\n\n\tremoveById(dataNode[ND].listeners.shallow, id);\n\tremoveById(dataNode[ND].listeners.deep, id);\n}\n\n/**\n * removing all listeners of a path\n * \n * @remarks\n * automatically filled param {Object} dataNode\n * automatically filled param {Object} proxyNode\n * \n * @param [path] - path selector\n */\nexport function removeAllListeners(dataNode: DataNode, proxyNode: ProxyNode, path = ''): void {\n\tlet fullPath = `${dataNode[ND].path}${path}`;\n\tlet segments = splitPath(path);\n\t//traverse down the tree\n\tfor(let property of segments) {\n\t\tif(!dataNode[property]) {\n\t\t\tconsole.warn(`can't remove all listeners from a non-existent path '${fullPath}'`);\n\t\t\treturn;\n\t\t}\n\t\tdataNode = dataNode[property];\n\t}\n\n\tdataNode[ND].listeners.shallow = [] as ListenerData[];\n\tdataNode[ND].listeners.deep = [] as ListenerData[];\n}\n\n/**\n * the following functions (getOriginalTarget, getProxserveNodes) seem silly\n * because they could have been written directly on the handler's get() method but it's here as part of the convention of\n * exposing proxy-\"inherited\"-methods\n */\n/**\n * get original target that is behind the proxy\n * \n * @remarks\n * automatically filled param {Object} dataNode\n * automatically filled param {Object} proxyNode\n */\nexport function getOriginalTarget(dataNode: DataNode, proxyNode: ProxyNode): TargetVariable {\n\treturn proxyNode[ND].target;\n}\n\n/**\n * get the data-node of a proxy (which holds all meta data)\n * and also get proxy-node of a proxy (which holds all related objects)\n * \n * @remarks\n * automatically filled param {Object} dataNode\n * automatically filled param {Object} proxyNode\n */\nexport function getProxserveNodes(dataNode: DataNode, proxyNode: ProxyNode): {\n\tdataNode: DataNode;\n\tproxyNode: ProxyNode;\n} {\n\treturn { dataNode, proxyNode };\n}","/**\n * Copyright 2021 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nimport { eventNames, nodeStatuses, proxyStatuses, ND, NID, DataNode, ChangeEvent, DeferredEvent, ListenerData } from './globals';\nimport { property2path } from './supporting-functions';\nimport { splitPath } from './general-functions';\n\n/**\n * try to get the proxy-object from a data-node. if can't then from it's parent's proxy\n * @param dataNode \n * @param [property] - the property as the dataNode is assigned on its parent\n */\nfunction getProxyValue(dataNode: DataNode, property?: string): any {\n\tif(dataNode[ND].proxyNode && dataNode[ND].proxyNode[NID].status === proxyStatuses.ALIVE) {\n\t\treturn dataNode[ND].proxyNode[ND].proxy; // actual proxy of child node\n\t}\n\telse {\n\t\tif(!property) {\n\t\t\t// my property on the parent\n\t\t\tproperty = splitPath(dataNode[ND].propertyPath)[0] as string;\n\t\t}\n\n\t\tlet parentNode = dataNode[ND].parentNode;\n\n\t\tif(parentNode[ND].proxyNode && parentNode[ND].proxyNode[NID].status === proxyStatuses.ALIVE) {\n\t\t\treturn parentNode[ND].proxyNode[ND].proxy?.[property]; // proxy or primitive via parent's proxy object\n\t\t}\n\t\telse {\n\t\t\t// if we reached here then probably we are on a capture phase of a deep deletion.\n\t\t\t// for example 'obj.sub1.sub2' gets 'delete obj.sub1' so now there are no values for 'sub2' nor its parent 'sub1'.\n\t\t\t// the warning is turned off because this situation seems okay\n\t\t\t// console.warn(`reached a capture level where neither child not parent proxy-nodes exist`);\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\n/**\n * process event and then bubble up and capture down the data tree\n * @param dataNode\n * @param property\n * @param oldValue\n * @param wasOldValueProxy\n * @param value\n * @param isValueProxy\n */\nexport function initEmitEvent(\n\tdataNode: DataNode,\n\tproperty: string,\n\toldValue: any,\n\twasOldValueProxy: boolean,\n\tvalue: any,\n\tisValueProxy: boolean,\n) {\n\tif(oldValue === value // no new change was made\n\t|| !dataNode[ND].proxyNode) { // proxy-node is detached from data-node\n\t\treturn;\n\t}\n\n\tlet proxyNode = dataNode[ND].proxyNode;\n\tif(proxyNode[NID].status !== proxyStatuses.ALIVE) { // altered a deleted proxy\n\t\treturn;\n\t}\n\n\tlet changeType = eventNames.update;\n\tif(value === undefined) {\n\t\tchangeType = eventNames.delete;\n\t} else if(oldValue === undefined) {\n\t\tchangeType = eventNames.create;\n\t}\n\n\tlet deferredEvents: DeferredEvent[] | undefined;\n\t// altering properties of an array that's in the middle of a splicing phase\n\tif(dataNode[NID].status === nodeStatuses.SPLICING) {\n\t\t// initiate (if needed) an object to hold side effect events\n\t\tif(!dataNode[ND].deferredEvents) {\n\t\t\tdataNode[ND].deferredEvents = [];\n\t\t}\n\t\t// save a reference to the deferredEvents\n\t\tdeferredEvents = dataNode[ND].deferredEvents;\n\t}\n\n\tlet path;\n\tif(dataNode[property]) { // changed a property which has its own data node on the tree\n\t\tdataNode = dataNode[property];\n\t\tpath = '';\n\t} else {\n\t\tpath = property2path(proxyNode[ND].target, property);\n\t}\n\n\tlet change: ChangeEvent = {\n\t\tpath, value, oldValue, type: changeType,\n\t};\n\n\tif(!deferredEvents) {\n\t\tbubbleEmit(dataNode, change, property);\n\t\n\t\tif(wasOldValueProxy || isValueProxy) { // old value or new value are proxy meaning they are objects with children\n\t\t\tcaptureEmit(dataNode, change);\n\t\t}\n\t}\n\telse {\n\t\tdeferredEvents.push({dataNode, change, shouldCapture: wasOldValueProxy || isValueProxy});\n\t}\n}\n\n/**\n * bubbling phase - go up the data tree and emit\n * @param dataNode\n * @param change\n * @param [property] - property name of the data-node (i.e. as the data-node is assigned to its parent)\n */\nfunction bubbleEmit(dataNode: DataNode, change: ChangeEvent, property?: string): void {\n\tif(dataNode[NID].status === nodeStatuses.STOPPED) {\n\t\treturn; // not allowed to emit\n\t}\n\n\tlet thisValue = getProxyValue(dataNode, property);\n\n\tif(change.path === '') { // iterate over 'shallow' listeners\n\t\titerateAndEmit(dataNode[ND].listeners.shallow, thisValue, change);\n\t}\n\n\t// iterate over 'deep' listeners\n\titerateAndEmit(dataNode[ND].listeners.deep, thisValue, change);\n\n\tif(!dataNode[ND].parentNode[ND].isTreePrototype) { // we are not on root node yet\n\t\t// create a shallow copy of 'change' and update its path\n\t\t// (we don't want to alter the 'change' object that was just emitted to a listener)\n\t\tlet nextChange: ChangeEvent = {\n\t\t\t...change,\n\t\t\tpath: dataNode[ND].propertyPath + change.path\n\t\t};\n\n\t\tbubbleEmit(dataNode[ND].parentNode, nextChange);\n\t}\n}\n\n/**\n * capturing phase - go down the data tree and emit\n * @param dataNode\n * @param change\n */\nfunction captureEmit(dataNode: DataNode, change: ChangeEvent): void {\n\tlet keys = Object.keys(dataNode);\n\tfor(let key of keys) {\n\t\tlet subValue = (typeof change.value === 'object' && change.value !== null) ? change.value[key] : undefined;\n\t\tlet subOldValue = (typeof change.oldValue === 'object' && change.oldValue !== null) ? change.oldValue[key] : undefined;\n\t\tif(subValue !== subOldValue) { //if not both undefined or same primitive or the same object\n\t\t\tlet changeType = eventNames.update;\n\t\t\tif(subValue === undefined) {\n\t\t\t\tchangeType = eventNames.delete;\n\t\t\t} else if(subOldValue === undefined) {\n\t\t\t\tchangeType = eventNames.create;\n\t\t\t}\n\n\t\t\tlet subChange: ChangeEvent = {\n\t\t\t\tpath: '',\n\t\t\t\toldValue: subOldValue,\n\t\t\t\tvalue: subValue,\n\t\t\t\ttype: changeType\n\t\t\t}\n\n\t\t\t// failing the status check will not emit for current property (but sub-properties might still be forcibly active)\n\t\t\tlet childNode = dataNode[key];\n\t\t\tif(childNode[NID].status !== nodeStatuses.STOPPED) {\n\t\t\t\tlet thisValue = getProxyValue(childNode, key);\n\t\t\t\titerateAndEmit(childNode[ND].listeners.shallow, thisValue, subChange);\n\t\t\t}\n\n\t\t\tcaptureEmit(childNode, subChange);\n\t\t}\n\t}\n}\n\n/**\n * iterate over an array of listeners, handle 'once' listeners and emit\n * @param listenersArr \n * @param thisValue \n * @param change \n */\nfunction iterateAndEmit(listenersArr: ListenerData[], thisValue: any, change: ChangeEvent): void {\n\tfor(let i = listenersArr.length - 1; i >= 0; i--) {\n\t\tlet listener = listenersArr[i];\n\t\tif(listener.type.includes(change.type)) {\n\t\t\tif(listener.once === true) {\n\t\t\t\tlistenersArr.splice(i, 1);\n\t\t\t}\n\t\t\tlistener.func.call(thisValue, change);\n\t\t}\n\t}\n}\n\n/**\n * process special event for a built-in method and then bubble up the data tree\n * @param dataNode\n * @param funcName - the method's name\n * @param funcArgs - the method's arguments\n * @param oldValue\n * @param value\n */\nexport function initFunctionEmitEvent(\n\tdataNode: DataNode,\n\tfuncName: eventNames,\n\tfuncArgs: ChangeEvent['args'],\n\toldValue: any,\n\tvalue: any,\n) {\n\tlet change: ChangeEvent = {\n\t\tpath: '', value, oldValue, type: funcName, args: funcArgs,\n\t};\n\n\tbubbleEmit(dataNode, change);\n\n\tif(dataNode[ND].deferredEvents) {\n\t\t// manually handle the side-effect events that were caught\n\t\t// in order to not bubble up, but should capture down\n\t\tfor(let event of dataNode[ND].deferredEvents!) {\n\t\t\tif(event.change.path === '') {\n\t\t\t\t// no path means its an event directly on the property, not on the parent.\n\t\t\t\t// i.e: not an event with path \"0\" on \".arr\", but an event with no path on \".arr[0]\".\n\t\t\t\t// function event on \"arr\" already ran, but now a regular event on \"arr[0]\" is due\n\t\t\t\tlet thisValue = getProxyValue(event.dataNode);\n\t\t\t\titerateAndEmit(event.dataNode[ND].listeners.shallow, thisValue, event.change);\n\t\t\t\titerateAndEmit(event.dataNode[ND].listeners.deep, thisValue, event.change);\n\t\t\t}\n\n\t\t\tif(event.shouldCapture) {\n\t\t\t\tcaptureEmit(event.dataNode, event.change);\n\t\t\t}\n\t\t}\n\t\tdelete dataNode[ND].deferredEvents;\n\t}\n\telse {\n\t\tconsole.warn(`no side effect events for ${funcName} were made`);\n\t}\n}","/**\n * Copyright 2021 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n// Proxy methods are methods that will proxy JS built-in methods.\n// For examply, the proxy function for \"splice\" will handle some event stuff and then use\n// the actual \"splice\" function internally\n\"use strict\"\n\nimport { nodeStatuses, eventNames, ND, NID, DataNode, ProxyNode } from './globals';\nimport { initFunctionEmitEvent } from './event-emitter';\n\n/**\n * a wrapper function for the 'splice' method\n * \n * @remarks\n * automatically filled param {Object} dataNode\n * automatically filled param {Object} proxyNode\n * \n * @param start \n * @param deleteCount \n * @param items - rest of arguments\n */\nexport function splice(\n\tdataNode: DataNode,\n\tproxyNode: ProxyNode,\n\tstart: number,\n\tdeleteCount: number,\n\t...items: any[]\n): any[] {\n\tif(dataNode[NID].status !== nodeStatuses.ACTIVE) {\n\t\treturn Array.prototype.splice.call(proxyNode[ND].proxy, start, deleteCount, ...items);\n\t}\n\n\tlet isActiveByInheritance = !dataNode[NID].hasOwnProperty('status');\n\tdataNode[NID].status = nodeStatuses.SPLICING;\n\tlet oldValue = proxyNode[ND].target.slice(0);\n\tlet deleted = Array.prototype.splice.call(proxyNode[ND].proxy, start, deleteCount, ...items); // creates many side-effect events\n\tlet args = { start, deleteCount, items };\n\t\n\tif(isActiveByInheritance) {\n\t\tdelete dataNode[NID].status;\n\t} else {\n\t\tdataNode[NID].status = nodeStatuses.ACTIVE;\n\t}\n\n\tinitFunctionEmitEvent(dataNode, eventNames.splice, args, oldValue, proxyNode[ND].target);\n\n\treturn deleted;\n}\n\n/**\n * a wrapper function for the 'shift' method\n * \n * @remarks\n * automatically filled param {Object} dataNode\n * automatically filled param {Object} proxyNode\n */\nexport function shift(dataNode: DataNode, proxyNode: ProxyNode): any {\n\tif(dataNode[NID].status !== nodeStatuses.ACTIVE) {\n\t\t// if not active then run regular `shift`\n\t\t// which will reach the `set` of the ProxyHandler and will be blocked or events stopped, etc.\n\t\treturn Array.prototype.shift.call(proxyNode[ND].proxy);\n\t}\n\n\tlet isActiveByInheritance = !dataNode[NID].hasOwnProperty('status');\n\tdataNode[NID].status = nodeStatuses.SPLICING;\n\tlet oldValue = proxyNode[ND].target.slice(0);\n\tlet deleted = Array.prototype.shift.call(proxyNode[ND].proxy); // creates many side-effect events\n\t\n\tif(isActiveByInheritance) {\n\t\tdelete dataNode[NID].status;\n\t} else {\n\t\tdataNode[NID].status = nodeStatuses.ACTIVE;\n\t}\n\n\tinitFunctionEmitEvent(dataNode, eventNames.shift, {}, oldValue, proxyNode[ND].target);\n\n\treturn deleted;\n}\n\n/**\n * a wrapper function for the 'unshift' method\n * \n * @remarks\n * automatically filled param {Object} dataNode\n * automatically filled param {Object} proxyNode\n * \n * @param items \n */\nexport function unshift(dataNode: DataNode, proxyNode: ProxyNode, ...items: any[]): number {\n\tif(dataNode[NID].status !== nodeStatuses.ACTIVE) {\n\t\treturn Array.prototype.shift.call(proxyNode[ND].proxy) as number;\n\t}\n\n\tlet isActiveByInheritance = !dataNode[NID].hasOwnProperty('status');\n\tdataNode[NID].status = nodeStatuses.SPLICING;\n\tlet oldValue = proxyNode[ND].target.slice(0);\n\tlet newLength: number = Array.prototype.unshift.call(proxyNode[ND].proxy, ...items); // creates many side-effect events\n\tlet args = { items };\n\t\n\tif(isActiveByInheritance) {\n\t\tdelete dataNode[NID].status;\n\t} else {\n\t\tdataNode[NID].status = nodeStatuses.ACTIVE;\n\t}\n\n\tinitFunctionEmitEvent(dataNode, eventNames.unshift, args, oldValue, proxyNode[ND].target);\n\n\treturn newLength;\n}\n","/**\n * Copyright 2021 Noam Lin <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\"use strict\"\n\nimport { proxyTypes, nodeStatuses, proxyStatuses,\n\tND, NID, ProxserveInstance, DataNode, ProxyNode,\n\tTargetVariable, SomeObject, ProxserveInstanceMetadata } from './globals';\nimport { unproxify, createNodes } from './supporting-functions';\nimport * as pseudoMethods from './pseudo-methods';\nimport * as proxyMethods from './proxy-methods';\nimport { realtypeof, splitPath, evalPath } from './general-functions';\nimport { initEmitEvent } from './event-emitter';\n\n/**\n * save an array of all reserved function names\n * and also add synonyms to these functions\n */\nlet pseudoMethodsNames = Object.keys(pseudoMethods);\nfor(let i = pseudoMethodsNames.length - 1; i >= 0; i--) {\n\tlet name = pseudoMethodsNames[i];\n\tlet synonym = '$'+name;\n\tpseudoMethods[synonym] = pseudoMethods[name];\n\tpseudoMethodsNames.push(synonym);\n}\n\ninterface MakeOptions {\n\t/**\n\t * should destroy detached child-objects or deleted properties automatically\n\t */\n\tstrict: boolean;\n\t/**\n\t * should splice, shift or unshift emit one event or all internal CRUD events\n\t */\n\temitMethods: boolean;\n\tdebug?: {\n\t\t/**\n\t\t * delay before destroying a detached child-object\n\t\t */\n\t\tdestroyDelay: number;\n\t};\n}\n\nexport class Proxserve {\n\t/**\n\t * make a new proxserve instance\n\t */\n\tstatic make(target: TargetVariable, options = {} as MakeOptions): ProxserveInstance {\n\t\tconst {\n\t\t\tstrict = true,\n\t\t\temitMethods = true,\n\t\t\tdebug = { destroyDelay: 1000 },\n\t\t} = options;\n\n\t\tlet dataTreePrototype: DataNode = {\n\t\t\t[NID]: { status: nodeStatuses.ACTIVE },\n\t\t\t[ND]: { isTreePrototype: true } as DataNode[typeof ND],\n\t\t};\n\t\tlet proxyTreePrototype: ProxyNode = {\n\t\t\t[NID]: { status: proxyStatuses.ALIVE },\n\t\t\t[ND]: { isTreePrototype: true } as ProxyNode[typeof ND],\n\t\t};\n\n\t\tconst newNodes = createNodes(dataTreePrototype, '', proxyTreePrototype, target);\n\n\t\tconst metadata = {\n\t\t\tstrict,\n\t\t\temitMethods,\n\t\t\tdestroyDelay: debug.destroyDelay,\n\t\t\tdataTree: newNodes.dataNode,\n\t\t\tproxyTree: newNodes.proxyNode,\n\t\t} as ProxserveInstanceMetadata;\n\n\t\treturn Proxserve.createProxy(metadata, metadata.dataTree);\n\t}\n\n\t/**\n\t * create a new proxy and a new node for a property of the parent's target-object\n\t */\n\tstatic createProxy(metadata: ProxserveInstanceMetadata, parentDataNode: DataNode, targetProperty?: string): ProxserveInstance {\n\t\tlet parentProxyNode = parentDataNode[ND].proxyNode\n\t\tlet dataNode: DataNode, proxyNode: ProxyNode;\n\n\t\tif(targetProperty === undefined) { //refering to own node and not a child property (meaning root object)\n\t\t\tdataNode = parentDataNode;\n\t\t\tproxyNode = parentProxyNode;\n\t\t}\n\t\telse {\n\t\t\t//creates new or reset an existing data-node and then creates a new proxy-node\n\t\t\tconst newNodes = createNodes(\n\t\t\t\tparentDataNode,\n\t\t\t\ttargetProperty,\n\t\t\t\tparentProxyNode,\n\t\t\t\tparentProxyNode[ND].target[targetProperty],\n\t\t\t);\n\t\t\tdataNode = newNodes.dataNode;\n\t\t\tproxyNode = newNodes.proxyNode;\n\t\t}\n\n\t\tlet target = proxyNode[ND].target;\n\n\t\tlet typeoftarget = realtypeof(target);\n\n\t\tif(proxyTypes[typeoftarget]) {\n\t\t\tlet revocable = Proxy.revocable<TargetVariable>(target, {\n\t\t\t\tget: (target: TargetVariable/*same as parent scope 'target'*/, property: string|symbol, proxy) => {\n\t\t\t\t\tif(metadata.emitMethods && Object.prototype.hasOwnProperty.call(proxyMethods, property) && property in Object.getPrototypeOf(target)) {\n\t\t\t\t\t\t// use a proxy method instead of the built-in method that is on the prototype chain\n\t\t\t\t\t\treturn proxyMethods[property].bind(metadata, dataNode, proxyNode);\n\t\t\t\t\t}\n\t\t\t\t\telse if(pseudoMethodsNames.includes(property as string) && typeof target[property] === 'undefined') {\n\t\t\t\t\t\t// can access a pseudo function (or its synonym) if their keywords isn't used\n\t\t\t\t\t\treturn pseudoMethods[property].bind(metadata, dataNode, proxyNode);\n\t\t\t\t\t}\n\t\t\t\t\telse if(!target.propertyIsEnumerable(property) || typeof property === 'symbol') {\n\t\t\t\t\t\treturn target[property]; // non-enumerable or non-path'able aren't proxied\n\t\t\t\t\t}\n\t\t\t\t\telse if(proxyNode[property] // there's a child node\n\t\t\t\t\t\t\t&& proxyNode[property][ND].proxy // it holds a proxy\n\t\t\t\t\t\t\t&& proxyNode[property][NID].status === proxyStatuses.ALIVE) {\n\t\t\t\t\t\treturn proxyNode[property][ND].proxy;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn target[property];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\n\t\t\t\tset: (target/*same as parent scope 'target'*/, property, value, proxy) => { //'receiver' is proxy\n\t\t\t\t\t/**\n\t\t\t\t\t * property can be a regular object because of 3 possible reasons:\n\t\t\t\t\t * 1. proxy is deleted from tree but user keeps accessing it then it means he saved a reference\n\t\t\t\t\t * 2. it is a non-enumerable property which means it was intentionally hidden\n\t\t\t\t\t * 3. property is a symbol and symbols can't be proxied because we can't create a normal path for them.\n\t\t\t\t\t *    these properties are not proxied and should not emit change-event.\n\t\t\t\t\t *    except for: length\n\t\t\t\t\t * TODO - make a list of all possible properties exceptions (maybe function 'name'?)\n\t\t\t\t\t */\n\t\t\t\t\tif(dataNode[NID].status === nodeStatuses.BLOCKED) { //blocked from changing values\n\t\t\t\t\t\tconsole.error('object is blocked. can\\'t change value of property:', property);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(typeof property === 'symbol') {\n\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(property !== 'length' && !target.propertyIsEnumerable(property)) {\n\t\t\t\t\t\t//if setting a whole new property then it is non-enumerable (yet) so a further test is needed\n\t\t\t\t\t\tlet descriptor = Object.getOwnPropertyDescriptor(target, property);\n\t\t\t\t\t\tif(typeof descriptor === 'object' && descriptor.enumerable === false) { //property was previously set\n\t\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet oldValue = target[property]; // should not be proxy\n\t\t\t\t\tlet isOldValueProxy = false;\n\t\t\t\t\tif(proxyNode[property] !== undefined && proxyNode[property][ND].proxy !== undefined) {\n\t\t\t\t\t\t// about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\tproxyNode[property][NID].status = proxyStatuses.DELETED;\n\t\t\t\t\t\tdelete dataNode[property][ND].proxyNode; // detach reference from data-node to proxy-node\n\t\t\t\t\t\tisOldValueProxy = true;\n\t\t\t\t\t\tif(metadata.strict) {\n\t\t\t\t\t\t\t// postpone this cpu intense function for later, probably when proxserve is not in use\n\t\t\t\t\t\t\tsetTimeout(Proxserve.destroy, metadata.destroyDelay, proxyNode[property][ND].proxy);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue = unproxify(value);\n\t\t\t\t\ttarget[property] = value; //assign new value\n\n\t\t\t\t\tlet isValueProxy = false;\n\t\t\t\t\tlet typeofvalue = realtypeof(value);\n\t\t\t\t\tif(proxyTypes[typeofvalue]) {\n\t\t\t\t\t\tProxserve.createProxy(metadata, dataNode, property); // if trying to add a new value which is an object then make it a proxy\n\t\t\t\t\t\tisValueProxy = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tinitEmitEvent(dataNode, property, oldValue, isOldValueProxy, value, isValueProxy);\n\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\t/**\n\t\t\t\t * TODO - this function is incomplete and doesn't handle all of 'descriptor' scenarios\n\t\t\t\t */\n\t\t\t\tdefineProperty: (target/*same as parent scope 'target'*/, property, descriptor) => {\n\t\t\t\t\tif(typeof property === 'symbol') {\n\t\t\t\t\t\tObject.defineProperty(target, property, descriptor);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet oldValue = target[property]; //should not be proxy\n\t\t\t\t\tlet isOldValueProxy = false;\n\t\t\t\t\tif(proxyNode[property] !== undefined && proxyNode[property][ND].proxy !== undefined) {\n\t\t\t\t\t\t//about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\tproxyNode[property][NID].status = proxyStatuses.DELETED;\n\t\t\t\t\t\tdelete dataNode[property][ND].proxyNode; //detach reference from data-node to proxy-node\n\t\t\t\t\t\tisOldValueProxy = true;\n\t\t\t\t\t\tif(metadata.strict) {\n\t\t\t\t\t\t\t//postpone this cpu intense function for later, probably when proxserve is not is use\n\t\t\t\t\t\t\tsetTimeout(Proxserve.destroy, metadata.destroyDelay, proxyNode[property][ND].proxy);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdescriptor.value = unproxify(descriptor.value);\n\t\t\t\t\tObject.defineProperty(target, property, descriptor); //defining the new value\n\t\t\t\t\tlet value = descriptor.value;\n\t\t\t\t\tlet isValueProxy = false;\n\t\t\t\t\t//excluding non-enumerable properties from being proxied\n\t\t\t\t\tlet typeofvalue = realtypeof(descriptor.value);\n\t\t\t\t\tif(proxyTypes[typeofvalue] && descriptor.enumerable === true) {\n\t\t\t\t\t\tProxserve.createProxy(metadata, dataNode, property); //if trying to add a new value which is an object then make it a proxy\n\t\t\t\t\t\tisValueProxy = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tinitEmitEvent(dataNode, property, oldValue, isOldValueProxy, value, isValueProxy);\n\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\tdeleteProperty: (target/*same as parent scope 'target'*/, property) => {\n\t\t\t\t\tif(!target.propertyIsEnumerable(property) || typeof property === 'symbol') {\n\t\t\t\t\t\t//non-proxied properties simply get deleted and nothing more\n\t\t\t\t\t\tdelete target[property];\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dataNode[NID].status === nodeStatuses.BLOCKED) { //blocked from changing values\n\t\t\t\t\t\tconsole.error(`can't delete property '${property}'. object is blocked.`);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(property in target) {\n\t\t\t\t\t\tlet oldValue = target[property]; //should not be proxy\n\t\t\t\t\t\tlet isOldValueProxy = false;\n\t\t\t\t\t\tif(proxyNode[property] !== undefined && proxyNode[property][ND].proxy !== undefined) {\n\t\t\t\t\t\t\t//about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\t\tproxyNode[property][NID].status = proxyStatuses.DELETED;\n\t\t\t\t\t\t\tdelete dataNode[property][ND].proxyNode; //detach reference from data-node to proxy-node\n\t\t\t\t\t\t\tisOldValueProxy = true;\n\t\t\t\t\t\t\tif(metadata.strict) {\n\t\t\t\t\t\t\t\t//postpone this cpu intense function for later, probably when proxserve is not is use\n\t\t\t\t\t\t\t\tsetTimeout(Proxserve.destroy, metadata.destroyDelay, proxyNode[property][ND].proxy);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete target[property]; // actual delete\n\n\t\t\t\t\t\tinitEmitEvent(dataNode, property, oldValue, isOldValueProxy, undefined, false);\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn true; //do nothing because there's nothing to delete\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as ProxyHandler<TargetVariable>) as { proxy: ProxserveInstance, revoke: ()=>void };\n\n\t\t\tproxyNode[ND].proxy = revocable.proxy;\n\t\t\tproxyNode[ND].revoke = revocable.revoke;\n\n\t\t\tif(proxyTypes[typeoftarget]) {\n\t\t\t\tlet keys = Object.keys(target); //handles both Objects and Arrays\n\t\t\t\tfor(let key of keys) {\n\t\t\t\t\tlet typeofproperty = realtypeof(target[key]);\n\t\t\t\t\tif(proxyTypes[typeofproperty]) {\n\t\t\t\t\t\tProxserve.createProxy(metadata, dataNode, key); //recursively make child objects also proxies\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconsole.warn(`Type of \"${typeoftarget}\" is not implemented`);\n\t\t\t}\n\n\t\t\treturn revocable.proxy;\n\t\t}\n\t\telse {\n\t\t\tconst types = Object.keys(proxyTypes);\n\t\t\tthrow new Error(`Must observe an ${types.join('/')}`);\n\t\t}\n\t}\n\n\t/**\n\t * Recursively revoke proxies, allowing them to be garbage collected.\n\t * this functions delays 1000 milliseconds to let time for all events to finish\n\t */\n\tstatic destroy(proxy: ProxserveInstance) {\n\t\tlet proxyNode;\n\t\ttry {\n\t\t\tconst nodes = proxy.$getProxserveNodes();\n\t\t\tproxyNode = nodes.proxyNode;\n\t\t} catch(error) {\n\t\t\treturn; // proxy variable isn't a proxy\n\t\t}\n\n\t\tif(proxyNode[NID].status === proxyStatuses.ALIVE) {\n\t\t\tproxyNode[NID].status = proxyStatuses.DELETED;\n\t\t}\n\n\t\tlet typeofproxy = realtypeof(proxy);\n\n\t\tif(proxyTypes[typeofproxy]) {\n\t\t\tlet keys = Object.keys(proxy); // handles both Objects and Arrays\n\t\t\tfor(let key of keys) {\n\t\t\t\ttry {\n\t\t\t\t\tlet typeofproperty = realtypeof(proxy[key]);\n\t\t\t\t\tif(proxyTypes[typeofproperty]) {\n\t\t\t\t\t\t// going to proxy[key], which is deleted, will return the original target so we will bypass it\n\t\t\t\t\t\tProxserve.destroy(proxyNode[key][ND].proxy);\n\t\t\t\t\t}\n\t\t\t\t} catch(error) {\n\t\t\t\t\tconsole.error(error); // don't throw and kill the whole process just if this iteration fails\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tproxyNode[ND].revoke();\n\t\t\t//proxyNode[ND].proxy = undefined;\n\t\t\tproxyNode[NID].status = proxyStatuses.REVOKED;\n\t\t}\n\t\telse {\n\t\t\tconsole.warn(`Type of \"${typeofproxy}\" is not implemented`);\n\t\t}\n\t}\n\n\tstatic splitPath(path: string): Array<string|number> {\n\t\treturn splitPath(path);\n\t}\n\n\tstatic evalPath(obj: SomeObject, path: string): {\n\t\tobject: SomeObject,\n\t\tproperty: string|number,\n\t\tvalue: any,\n\t} {\n\t\treturn evalPath(obj, path);\n\t}\n}"],"names":["$66763b9de58a4cbb$export$f7e0aa381a5261fc","Symbol","for","$66763b9de58a4cbb$export$d1c20e4ad7d32581","$66763b9de58a4cbb$export$94b8be4ec3303efd","Object","Array","nodeStatuses","proxyStatuses","eventNames","$fda00bc7ddcd3bc7$export$99a2acdf670c1bf4","variable","rawType","prototype","toString","call","substring","length","$66763b9de58a4cbb$export$eb0c55c6f2ee7170","$66763b9de58a4cbb$export$89e04a1d3d3065f6","$66763b9de58a4cbb$export$4a2e650c134b86af","WeakSet","$fda00bc7ddcd3bc7$export$824c337f43f2b64d","path","i","betweenBrackets","onlyDigits","resultsArr","tmp","char","push","parseInt","code","charCodeAt","$a72f28e28e24748b$export$1b787634d8e3bf02","obj","property","Error","typeofobj","console","warn","$a72f28e28e24748b$export$a58c3ed528c9c399","value","typeofvalue","target","$getOriginalTarget","error","keys","key","$a72f28e28e24748b$export$953dd193a01bd6ec","parentDataNode","parentProxyNode","propertyPath","proxyNode","dataNode","create","parentNode","listeners","shallow","deep","status","isTreePrototype","assign","undefined","$cb4cc1e2f387f5a6$export$fa6813432f753b0d","STOPPED","$cb4cc1e2f387f5a6$export$837bd02682cd3db9","BLOCKED","$cb4cc1e2f387f5a6$export$234c45b355edd85b","force","this","dataTree","ACTIVE","$cb4cc1e2f387f5a6$export$af631764ddc44097","events","listener","options","ref","ref1","id","ref2","once","isArray","event","names","join","optionsFromListener","segments","listenersPool","listenerObj","type","func","$cb4cc1e2f387f5a6$export$d2de3aaeafa91619","$cb4cc1e2f387f5a6$var$removeById","listenersArr","splice","$cb4cc1e2f387f5a6$export$b03e9483f936dccb","arguments","fullPath","$cb4cc1e2f387f5a6$export$6f2e3a6079f109b1","$cb4cc1e2f387f5a6$export$35f261dd63190ac1","$cb4cc1e2f387f5a6$export$c3c6db5039118967","$08aa8f4cfdbb0713$var$getProxyValue","ALIVE","proxy","$08aa8f4cfdbb0713$export$febbc75e71f4ca1b","oldValue","wasOldValueProxy","isValueProxy","deferredEvents","changeType","update","delete","SPLICING","change","shouldCapture","$08aa8f4cfdbb0713$var$bubbleEmit","$08aa8f4cfdbb0713$var$captureEmit","thisValue","$08aa8f4cfdbb0713$var$iterateAndEmit","nextChange","subValue","subOldValue","subChange","childNode","includes","$08aa8f4cfdbb0713$export$29f2d3a310653bb4","funcName","funcArgs","args","$f5798ab020ffb663$export$869882364835d202","start","deleteCount","items","isActiveByInheritance","hasOwnProperty","slice","deleted","$f5798ab020ffb663$export$fba63a578e423eb","shift","$f5798ab020ffb663$export$37cdb546b806ae87","newLength","unshift","$f3a59425b0ffb76f$var$pseudoMethodsNames","$cb4cc1e2f387f5a6$exports","name","synonym","$f3a59425b0ffb76f$export$d402cf8388053971","static","target2","strict","emitMethods","debug","destroyDelay","newNodes","metadata","proxyTree","createProxy","targetProperty","target1","typeoftarget","revocable","Proxy","get","$f5798ab020ffb663$exports","getPrototypeOf","bind","propertyIsEnumerable","set","descriptor","getOwnPropertyDescriptor","enumerable","isOldValueProxy","DELETED","setTimeout","destroy","defineProperty","deleteProperty","revoke","typeofproperty","types","$getProxserveNodes","typeofproxy","REVOKED","path1","object","$fda00bc7ddcd3bc7$export$8ffa680996c65fde"],"version":3,"file":"index.min.js.map"}